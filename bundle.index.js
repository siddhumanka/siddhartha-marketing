var Jy = e => {
        throw TypeError(e)
    }
;
var rf = (e, t, n) => t.has(e) || Jy("Cannot " + n);
var L = (e, t, n) => (rf(e, t, "read from private field"),
    n ? n.call(e) : t.get(e))
    , xe = (e, t, n) => t.has(e) ? Jy("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, n)
    , le = (e, t, n, s) => (rf(e, t, "write to private field"),
    s ? s.call(e, n) : t.set(e, n),
    n)
    , Oe = (e, t, n) => (rf(e, t, "access private method"),
    n);
var Xl = (e, t, n, s) => ({
    set _(o) {
        le(e, t, o, n)
    },
    get _() {
        return L(e, t, s)
    }
});
function DP(e, t) {
    for (var n = 0; n < t.length; n++) {
        const s = t[n];
        if (typeof s != "string" && !Array.isArray(s)) {
            for (const o in s)
                if (o !== "default" && !(o in e)) {
                    const u = Object.getOwnPropertyDescriptor(s, o);
                    u && Object.defineProperty(e, o, u.get ? u : {
                        enumerable: !0,
                        get: () => s[o]
                    })
                }
        }
    }
    return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, {
        value: "Module"
    }))
}
(function() {
        const t = document.createElement("link").relList;
        if (t && t.supports && t.supports("modulepreload"))
            return;
        for (const o of document.querySelectorAll('link[rel="modulepreload"]'))
            s(o);
        new MutationObserver(o => {
                for (const u of o)
                    if (u.type === "childList")
                        for (const l of u.addedNodes)
                            l.tagName === "LINK" && l.rel === "modulepreload" && s(l)
            }
        ).observe(document, {
            childList: !0,
            subtree: !0
        });
        function n(o) {
            const u = {};
            return o.integrity && (u.integrity = o.integrity),
            o.referrerPolicy && (u.referrerPolicy = o.referrerPolicy),
                o.crossOrigin === "use-credentials" ? u.credentials = "include" : o.crossOrigin === "anonymous" ? u.credentials = "omit" : u.credentials = "same-origin",
                u
        }
        function s(o) {
            if (o.ep)
                return;
            o.ep = !0;
            const u = n(o);
            fetch(o.href, u)
        }
    }
)();
function Xh(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}
var sf = {
    exports: {}
}
    , Wo = {}
    , of = {
    exports: {}
}
    , Ae = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Zy;
function IP() {
    if (Zy)
        return Ae;
    Zy = 1;
    var e = Symbol.for("react.element")
        , t = Symbol.for("react.portal")
        , n = Symbol.for("react.fragment")
        , s = Symbol.for("react.strict_mode")
        , o = Symbol.for("react.profiler")
        , u = Symbol.for("react.provider")
        , l = Symbol.for("react.context")
        , d = Symbol.for("react.forward_ref")
        , f = Symbol.for("react.suspense")
        , p = Symbol.for("react.memo")
        , m = Symbol.for("react.lazy")
        , y = Symbol.iterator;
    function v(j) {
        return j === null || typeof j != "object" ? null : (j = y && j[y] || j["@@iterator"],
            typeof j == "function" ? j : null)
    }
    var S = {
        isMounted: function() {
            return !1
        },
        enqueueForceUpdate: function() {},
        enqueueReplaceState: function() {},
        enqueueSetState: function() {}
    }
        , E = Object.assign
        , w = {};
    function x(j, K, ce) {
        this.props = j,
            this.context = K,
            this.refs = w,
            this.updater = ce || S
    }
    x.prototype.isReactComponent = {},
        x.prototype.setState = function(j, K) {
            if (typeof j != "object" && typeof j != "function" && j != null)
                throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
            this.updater.enqueueSetState(this, j, K, "setState")
        }
        ,
        x.prototype.forceUpdate = function(j) {
            this.updater.enqueueForceUpdate(this, j, "forceUpdate")
        }
    ;
    function T() {}
    T.prototype = x.prototype;
    function k(j, K, ce) {
        this.props = j,
            this.context = K,
            this.refs = w,
            this.updater = ce || S
    }
    var R = k.prototype = new T;
    R.constructor = k,
        E(R, x.prototype),
        R.isPureReactComponent = !0;
    var _ = Array.isArray
        , D = Object.prototype.hasOwnProperty
        , H = {
        current: null
    }
        , $ = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };
    function O(j, K, ce) {
        var de, be = {}, Te = null, Z = null;
        if (K != null)
            for (de in K.ref !== void 0 && (Z = K.ref),
            K.key !== void 0 && (Te = "" + K.key),
                K)
                D.call(K, de) && !$.hasOwnProperty(de) && (be[de] = K[de]);
        var ye = arguments.length - 2;
        if (ye === 1)
            be.children = ce;
        else if (1 < ye) {
            for (var Ce = Array(ye), Pe = 0; Pe < ye; Pe++)
                Ce[Pe] = arguments[Pe + 2];
            be.children = Ce
        }
        if (j && j.defaultProps)
            for (de in ye = j.defaultProps,
                ye)
                be[de] === void 0 && (be[de] = ye[de]);
        return {
            $$typeof: e,
            type: j,
            key: Te,
            ref: Z,
            props: be,
            _owner: H.current
        }
    }
    function W(j, K) {
        return {
            $$typeof: e,
            type: j.type,
            key: K,
            ref: j.ref,
            props: j.props,
            _owner: j._owner
        }
    }
    function q(j) {
        return typeof j == "object" && j !== null && j.$$typeof === e
    }
    function X(j) {
        var K = {
            "=": "=0",
            ":": "=2"
        };
        return "$" + j.replace(/[=:]/g, function(ce) {
            return K[ce]
        })
    }
    var z = /\/+/g;
    function J(j, K) {
        return typeof j == "object" && j !== null && j.key != null ? X("" + j.key) : K.toString(36)
    }
    function ae(j, K, ce, de, be) {
        var Te = typeof j;
        (Te === "undefined" || Te === "boolean") && (j = null);
        var Z = !1;
        if (j === null)
            Z = !0;
        else
            switch (Te) {
                case "string":
                case "number":
                    Z = !0;
                    break;
                case "object":
                    switch (j.$$typeof) {
                        case e:
                        case t:
                            Z = !0
                    }
            }
        if (Z)
            return Z = j,
                be = be(Z),
                j = de === "" ? "." + J(Z, 0) : de,
                _(be) ? (ce = "",
                j != null && (ce = j.replace(z, "$&/") + "/"),
                    ae(be, K, ce, "", function(Pe) {
                        return Pe
                    })) : be != null && (q(be) && (be = W(be, ce + (!be.key || Z && Z.key === be.key ? "" : ("" + be.key).replace(z, "$&/") + "/") + j)),
                    K.push(be)),
                1;
        if (Z = 0,
            de = de === "" ? "." : de + ":",
            _(j))
            for (var ye = 0; ye < j.length; ye++) {
                Te = j[ye];
                var Ce = de + J(Te, ye);
                Z += ae(Te, K, ce, Ce, be)
            }
        else if (Ce = v(j),
        typeof Ce == "function")
            for (j = Ce.call(j),
                     ye = 0; !(Te = j.next()).done; )
                Te = Te.value,
                    Ce = de + J(Te, ye++),
                    Z += ae(Te, K, ce, Ce, be);
        else if (Te === "object")
            throw K = String(j),
                Error("Objects are not valid as a React child (found: " + (K === "[object Object]" ? "object with keys {" + Object.keys(j).join(", ") + "}" : K) + "). If you meant to render a collection of children, use an array instead.");
        return Z
    }
    function ie(j, K, ce) {
        if (j == null)
            return j;
        var de = []
            , be = 0;
        return ae(j, de, "", "", function(Te) {
            return K.call(ce, Te, be++)
        }),
            de
    }
    function ne(j) {
        if (j._status === -1) {
            var K = j._result;
            K = K(),
                K.then(function(ce) {
                    (j._status === 0 || j._status === -1) && (j._status = 1,
                        j._result = ce)
                }, function(ce) {
                    (j._status === 0 || j._status === -1) && (j._status = 2,
                        j._result = ce)
                }),
            j._status === -1 && (j._status = 0,
                j._result = K)
        }
        if (j._status === 1)
            return j._result.default;
        throw j._result
    }
    var re = {
        current: null
    }
        , I = {
        transition: null
    }
        , se = {
        ReactCurrentDispatcher: re,
        ReactCurrentBatchConfig: I,
        ReactCurrentOwner: H
    };
    function ee() {
        throw Error("act(...) is not supported in production builds of React.")
    }
    return Ae.Children = {
        map: ie,
        forEach: function(j, K, ce) {
            ie(j, function() {
                K.apply(this, arguments)
            }, ce)
        },
        count: function(j) {
            var K = 0;
            return ie(j, function() {
                K++
            }),
                K
        },
        toArray: function(j) {
            return ie(j, function(K) {
                return K
            }) || []
        },
        only: function(j) {
            if (!q(j))
                throw Error("React.Children.only expected to receive a single React element child.");
            return j
        }
    },
        Ae.Component = x,
        Ae.Fragment = n,
        Ae.Profiler = o,
        Ae.PureComponent = k,
        Ae.StrictMode = s,
        Ae.Suspense = f,
        Ae.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = se,
        Ae.act = ee,
        Ae.cloneElement = function(j, K, ce) {
            if (j == null)
                throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + j + ".");
            var de = E({}, j.props)
                , be = j.key
                , Te = j.ref
                , Z = j._owner;
            if (K != null) {
                if (K.ref !== void 0 && (Te = K.ref,
                    Z = H.current),
                K.key !== void 0 && (be = "" + K.key),
                j.type && j.type.defaultProps)
                    var ye = j.type.defaultProps;
                for (Ce in K)
                    D.call(K, Ce) && !$.hasOwnProperty(Ce) && (de[Ce] = K[Ce] === void 0 && ye !== void 0 ? ye[Ce] : K[Ce])
            }
            var Ce = arguments.length - 2;
            if (Ce === 1)
                de.children = ce;
            else if (1 < Ce) {
                ye = Array(Ce);
                for (var Pe = 0; Pe < Ce; Pe++)
                    ye[Pe] = arguments[Pe + 2];
                de.children = ye
            }
            return {
                $$typeof: e,
                type: j.type,
                key: be,
                ref: Te,
                props: de,
                _owner: Z
            }
        }
        ,
        Ae.createContext = function(j) {
            return j = {
                $$typeof: l,
                _currentValue: j,
                _currentValue2: j,
                _threadCount: 0,
                Provider: null,
                Consumer: null,
                _defaultValue: null,
                _globalName: null
            },
                j.Provider = {
                    $$typeof: u,
                    _context: j
                },
                j.Consumer = j
        }
        ,
        Ae.createElement = O,
        Ae.createFactory = function(j) {
            var K = O.bind(null, j);
            return K.type = j,
                K
        }
        ,
        Ae.createRef = function() {
            return {
                current: null
            }
        }
        ,
        Ae.forwardRef = function(j) {
            return {
                $$typeof: d,
                render: j
            }
        }
        ,
        Ae.isValidElement = q,
        Ae.lazy = function(j) {
            return {
                $$typeof: m,
                _payload: {
                    _status: -1,
                    _result: j
                },
                _init: ne
            }
        }
        ,
        Ae.memo = function(j, K) {
            return {
                $$typeof: p,
                type: j,
                compare: K === void 0 ? null : K
            }
        }
        ,
        Ae.startTransition = function(j) {
            var K = I.transition;
            I.transition = {};
            try {
                j()
            } finally {
                I.transition = K
            }
        }
        ,
        Ae.unstable_act = ee,
        Ae.useCallback = function(j, K) {
            return re.current.useCallback(j, K)
        }
        ,
        Ae.useContext = function(j) {
            return re.current.useContext(j)
        }
        ,
        Ae.useDebugValue = function() {}
        ,
        Ae.useDeferredValue = function(j) {
            return re.current.useDeferredValue(j)
        }
        ,
        Ae.useEffect = function(j, K) {
            return re.current.useEffect(j, K)
        }
        ,
        Ae.useId = function() {
            return re.current.useId()
        }
        ,
        Ae.useImperativeHandle = function(j, K, ce) {
            return re.current.useImperativeHandle(j, K, ce)
        }
        ,
        Ae.useInsertionEffect = function(j, K) {
            return re.current.useInsertionEffect(j, K)
        }
        ,
        Ae.useLayoutEffect = function(j, K) {
            return re.current.useLayoutEffect(j, K)
        }
        ,
        Ae.useMemo = function(j, K) {
            return re.current.useMemo(j, K)
        }
        ,
        Ae.useReducer = function(j, K, ce) {
            return re.current.useReducer(j, K, ce)
        }
        ,
        Ae.useRef = function(j) {
            return re.current.useRef(j)
        }
        ,
        Ae.useState = function(j) {
            return re.current.useState(j)
        }
        ,
        Ae.useSyncExternalStore = function(j, K, ce) {
            return re.current.useSyncExternalStore(j, K, ce)
        }
        ,
        Ae.useTransition = function() {
            return re.current.useTransition()
        }
        ,
        Ae.version = "18.3.1",
        Ae
}
var ev;
function Yh() {
    return ev || (ev = 1,
        of.exports = IP()),
        of.exports
}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var tv;
function FP() {
    if (tv)
        return Wo;
    tv = 1;
    var e = Yh()
        , t = Symbol.for("react.element")
        , n = Symbol.for("react.fragment")
        , s = Object.prototype.hasOwnProperty
        , o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
        , u = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };
    function l(d, f, p) {
        var m, y = {}, v = null, S = null;
        p !== void 0 && (v = "" + p),
        f.key !== void 0 && (v = "" + f.key),
        f.ref !== void 0 && (S = f.ref);
        for (m in f)
            s.call(f, m) && !u.hasOwnProperty(m) && (y[m] = f[m]);
        if (d && d.defaultProps)
            for (m in f = d.defaultProps,
                f)
                y[m] === void 0 && (y[m] = f[m]);
        return {
            $$typeof: t,
            type: d,
            key: v,
            ref: S,
            props: y,
            _owner: o.current
        }
    }
    return Wo.Fragment = n,
        Wo.jsx = l,
        Wo.jsxs = l,
        Wo
}
var nv;
function BP() {
    return nv || (nv = 1,
        sf.exports = FP()),
        sf.exports
}
var b = BP()
    , P = Yh();
const Lr = Xh(P)
    , Jh = DP({
    __proto__: null,
    default: Lr
}, [P]);
var Yl = {}
    , af = {
    exports: {}
}
    , It = {}
    , lf = {
    exports: {}
}
    , uf = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var rv;
function VP() {
    return rv || (rv = 1,
        (function(e) {
                function t(I, se) {
                    var ee = I.length;
                    I.push(se);
                    e: for (; 0 < ee; ) {
                        var j = ee - 1 >>> 1
                            , K = I[j];
                        if (0 < o(K, se))
                            I[j] = se,
                                I[ee] = K,
                                ee = j;
                        else
                            break e
                    }
                }
                function n(I) {
                    return I.length === 0 ? null : I[0]
                }
                function s(I) {
                    if (I.length === 0)
                        return null;
                    var se = I[0]
                        , ee = I.pop();
                    if (ee !== se) {
                        I[0] = ee;
                        e: for (var j = 0, K = I.length, ce = K >>> 1; j < ce; ) {
                            var de = 2 * (j + 1) - 1
                                , be = I[de]
                                , Te = de + 1
                                , Z = I[Te];
                            if (0 > o(be, ee))
                                Te < K && 0 > o(Z, be) ? (I[j] = Z,
                                    I[Te] = ee,
                                    j = Te) : (I[j] = be,
                                    I[de] = ee,
                                    j = de);
                            else if (Te < K && 0 > o(Z, ee))
                                I[j] = Z,
                                    I[Te] = ee,
                                    j = Te;
                            else
                                break e
                        }
                    }
                    return se
                }
                function o(I, se) {
                    var ee = I.sortIndex - se.sortIndex;
                    return ee !== 0 ? ee : I.id - se.id
                }
                if (typeof performance == "object" && typeof performance.now == "function") {
                    var u = performance;
                    e.unstable_now = function() {
                        return u.now()
                    }
                } else {
                    var l = Date
                        , d = l.now();
                    e.unstable_now = function() {
                        return l.now() - d
                    }
                }
                var f = []
                    , p = []
                    , m = 1
                    , y = null
                    , v = 3
                    , S = !1
                    , E = !1
                    , w = !1
                    , x = typeof setTimeout == "function" ? setTimeout : null
                    , T = typeof clearTimeout == "function" ? clearTimeout : null
                    , k = typeof setImmediate < "u" ? setImmediate : null;
                typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
                function R(I) {
                    for (var se = n(p); se !== null; ) {
                        if (se.callback === null)
                            s(p);
                        else if (se.startTime <= I)
                            s(p),
                                se.sortIndex = se.expirationTime,
                                t(f, se);
                        else
                            break;
                        se = n(p)
                    }
                }
                function _(I) {
                    if (w = !1,
                        R(I),
                        !E)
                        if (n(f) !== null)
                            E = !0,
                                ne(D);
                        else {
                            var se = n(p);
                            se !== null && re(_, se.startTime - I)
                        }
                }
                function D(I, se) {
                    E = !1,
                    w && (w = !1,
                        T(O),
                        O = -1),
                        S = !0;
                    var ee = v;
                    try {
                        for (R(se),
                                 y = n(f); y !== null && (!(y.expirationTime > se) || I && !X()); ) {
                            var j = y.callback;
                            if (typeof j == "function") {
                                y.callback = null,
                                    v = y.priorityLevel;
                                var K = j(y.expirationTime <= se);
                                se = e.unstable_now(),
                                    typeof K == "function" ? y.callback = K : y === n(f) && s(f),
                                    R(se)
                            } else
                                s(f);
                            y = n(f)
                        }
                        if (y !== null)
                            var ce = !0;
                        else {
                            var de = n(p);
                            de !== null && re(_, de.startTime - se),
                                ce = !1
                        }
                        return ce
                    } finally {
                        y = null,
                            v = ee,
                            S = !1
                    }
                }
                var H = !1
                    , $ = null
                    , O = -1
                    , W = 5
                    , q = -1;
                function X() {
                    return !(e.unstable_now() - q < W)
                }
                function z() {
                    if ($ !== null) {
                        var I = e.unstable_now();
                        q = I;
                        var se = !0;
                        try {
                            se = $(!0, I)
                        } finally {
                            se ? J() : (H = !1,
                                $ = null)
                        }
                    } else
                        H = !1
                }
                var J;
                if (typeof k == "function")
                    J = function() {
                        k(z)
                    }
                    ;
                else if (typeof MessageChannel < "u") {
                    var ae = new MessageChannel
                        , ie = ae.port2;
                    ae.port1.onmessage = z,
                        J = function() {
                            ie.postMessage(null)
                        }
                } else
                    J = function() {
                        x(z, 0)
                    }
                    ;
                function ne(I) {
                    $ = I,
                    H || (H = !0,
                        J())
                }
                function re(I, se) {
                    O = x(function() {
                        I(e.unstable_now())
                    }, se)
                }
                e.unstable_IdlePriority = 5,
                    e.unstable_ImmediatePriority = 1,
                    e.unstable_LowPriority = 4,
                    e.unstable_NormalPriority = 3,
                    e.unstable_Profiling = null,
                    e.unstable_UserBlockingPriority = 2,
                    e.unstable_cancelCallback = function(I) {
                        I.callback = null
                    }
                    ,
                    e.unstable_continueExecution = function() {
                        E || S || (E = !0,
                            ne(D))
                    }
                    ,
                    e.unstable_forceFrameRate = function(I) {
                        0 > I || 125 < I ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : W = 0 < I ? Math.floor(1e3 / I) : 5
                    }
                    ,
                    e.unstable_getCurrentPriorityLevel = function() {
                        return v
                    }
                    ,
                    e.unstable_getFirstCallbackNode = function() {
                        return n(f)
                    }
                    ,
                    e.unstable_next = function(I) {
                        switch (v) {
                            case 1:
                            case 2:
                            case 3:
                                var se = 3;
                                break;
                            default:
                                se = v
                        }
                        var ee = v;
                        v = se;
                        try {
                            return I()
                        } finally {
                            v = ee
                        }
                    }
                    ,
                    e.unstable_pauseExecution = function() {}
                    ,
                    e.unstable_requestPaint = function() {}
                    ,
                    e.unstable_runWithPriority = function(I, se) {
                        switch (I) {
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                                break;
                            default:
                                I = 3
                        }
                        var ee = v;
                        v = I;
                        try {
                            return se()
                        } finally {
                            v = ee
                        }
                    }
                    ,
                    e.unstable_scheduleCallback = function(I, se, ee) {
                        var j = e.unstable_now();
                        switch (typeof ee == "object" && ee !== null ? (ee = ee.delay,
                            ee = typeof ee == "number" && 0 < ee ? j + ee : j) : ee = j,
                            I) {
                            case 1:
                                var K = -1;
                                break;
                            case 2:
                                K = 250;
                                break;
                            case 5:
                                K = 1073741823;
                                break;
                            case 4:
                                K = 1e4;
                                break;
                            default:
                                K = 5e3
                        }
                        return K = ee + K,
                            I = {
                                id: m++,
                                callback: se,
                                priorityLevel: I,
                                startTime: ee,
                                expirationTime: K,
                                sortIndex: -1
                            },
                            ee > j ? (I.sortIndex = ee,
                                t(p, I),
                            n(f) === null && I === n(p) && (w ? (T(O),
                                O = -1) : w = !0,
                                re(_, ee - j))) : (I.sortIndex = K,
                                t(f, I),
                            E || S || (E = !0,
                                ne(D))),
                            I
                    }
                    ,
                    e.unstable_shouldYield = X,
                    e.unstable_wrapCallback = function(I) {
                        var se = v;
                        return function() {
                            var ee = v;
                            v = se;
                            try {
                                return I.apply(this, arguments)
                            } finally {
                                v = ee
                            }
                        }
                    }
            }
        )(uf)),
        uf
}
var sv;
function UP() {
    return sv || (sv = 1,
        lf.exports = VP()),
        lf.exports
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var iv;
function zP() {
    if (iv)
        return It;
    iv = 1;
    var e = Yh()
        , t = UP();
    function n(r) {
        for (var i = "https://reactjs.org/docs/error-decoder.html?invariant=" + r, a = 1; a < arguments.length; a++)
            i += "&args[]=" + encodeURIComponent(arguments[a]);
        return "Minified React error #" + r + "; visit " + i + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }
    var s = new Set
        , o = {};
    function u(r, i) {
        l(r, i),
            l(r + "Capture", i)
    }
    function l(r, i) {
        for (o[r] = i,
                 r = 0; r < i.length; r++)
            s.add(i[r])
    }
    var d = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
        , f = Object.prototype.hasOwnProperty
        , p = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
        , m = {}
        , y = {};
    function v(r) {
        return f.call(y, r) ? !0 : f.call(m, r) ? !1 : p.test(r) ? y[r] = !0 : (m[r] = !0,
            !1)
    }
    function S(r, i, a, c) {
        if (a !== null && a.type === 0)
            return !1;
        switch (typeof i) {
            case "function":
            case "symbol":
                return !0;
            case "boolean":
                return c ? !1 : a !== null ? !a.acceptsBooleans : (r = r.toLowerCase().slice(0, 5),
                r !== "data-" && r !== "aria-");
            default:
                return !1
        }
    }
    function E(r, i, a, c) {
        if (i === null || typeof i > "u" || S(r, i, a, c))
            return !0;
        if (c)
            return !1;
        if (a !== null)
            switch (a.type) {
                case 3:
                    return !i;
                case 4:
                    return i === !1;
                case 5:
                    return isNaN(i);
                case 6:
                    return isNaN(i) || 1 > i
            }
        return !1
    }
    function w(r, i, a, c, h, g, C) {
        this.acceptsBooleans = i === 2 || i === 3 || i === 4,
            this.attributeName = c,
            this.attributeNamespace = h,
            this.mustUseProperty = a,
            this.propertyName = r,
            this.type = i,
            this.sanitizeURL = g,
            this.removeEmptyString = C
    }
    var x = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(r) {
        x[r] = new w(r,0,!1,r,null,!1,!1)
    }),
        [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(r) {
            var i = r[0];
            x[i] = new w(i,1,!1,r[1],null,!1,!1)
        }),
        ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(r) {
            x[r] = new w(r,2,!1,r.toLowerCase(),null,!1,!1)
        }),
        ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(r) {
            x[r] = new w(r,2,!1,r,null,!1,!1)
        }),
        "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(r) {
            x[r] = new w(r,3,!1,r.toLowerCase(),null,!1,!1)
        }),
        ["checked", "multiple", "muted", "selected"].forEach(function(r) {
            x[r] = new w(r,3,!0,r,null,!1,!1)
        }),
        ["capture", "download"].forEach(function(r) {
            x[r] = new w(r,4,!1,r,null,!1,!1)
        }),
        ["cols", "rows", "size", "span"].forEach(function(r) {
            x[r] = new w(r,6,!1,r,null,!1,!1)
        }),
        ["rowSpan", "start"].forEach(function(r) {
            x[r] = new w(r,5,!1,r.toLowerCase(),null,!1,!1)
        });
    var T = /[\-:]([a-z])/g;
    function k(r) {
        return r[1].toUpperCase()
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(r) {
        var i = r.replace(T, k);
        x[i] = new w(i,1,!1,r,null,!1,!1)
    }),
        "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(r) {
            var i = r.replace(T, k);
            x[i] = new w(i,1,!1,r,"http://www.w3.org/1999/xlink",!1,!1)
        }),
        ["xml:base", "xml:lang", "xml:space"].forEach(function(r) {
            var i = r.replace(T, k);
            x[i] = new w(i,1,!1,r,"http://www.w3.org/XML/1998/namespace",!1,!1)
        }),
        ["tabIndex", "crossOrigin"].forEach(function(r) {
            x[r] = new w(r,1,!1,r.toLowerCase(),null,!1,!1)
        }),
        x.xlinkHref = new w("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),
        ["src", "href", "action", "formAction"].forEach(function(r) {
            x[r] = new w(r,1,!1,r.toLowerCase(),null,!0,!0)
        });
    function R(r, i, a, c) {
        var h = x.hasOwnProperty(i) ? x[i] : null;
        (h !== null ? h.type !== 0 : c || !(2 < i.length) || i[0] !== "o" && i[0] !== "O" || i[1] !== "n" && i[1] !== "N") && (E(i, a, h, c) && (a = null),
            c || h === null ? v(i) && (a === null ? r.removeAttribute(i) : r.setAttribute(i, "" + a)) : h.mustUseProperty ? r[h.propertyName] = a === null ? h.type === 3 ? !1 : "" : a : (i = h.attributeName,
                c = h.attributeNamespace,
                a === null ? r.removeAttribute(i) : (h = h.type,
                    a = h === 3 || h === 4 && a === !0 ? "" : "" + a,
                    c ? r.setAttributeNS(c, i, a) : r.setAttribute(i, a))))
    }
    var _ = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
        , D = Symbol.for("react.element")
        , H = Symbol.for("react.portal")
        , $ = Symbol.for("react.fragment")
        , O = Symbol.for("react.strict_mode")
        , W = Symbol.for("react.profiler")
        , q = Symbol.for("react.provider")
        , X = Symbol.for("react.context")
        , z = Symbol.for("react.forward_ref")
        , J = Symbol.for("react.suspense")
        , ae = Symbol.for("react.suspense_list")
        , ie = Symbol.for("react.memo")
        , ne = Symbol.for("react.lazy")
        , re = Symbol.for("react.offscreen")
        , I = Symbol.iterator;
    function se(r) {
        return r === null || typeof r != "object" ? null : (r = I && r[I] || r["@@iterator"],
            typeof r == "function" ? r : null)
    }
    var ee = Object.assign, j;
    function K(r) {
        if (j === void 0)
            try {
                throw Error()
            } catch (a) {
                var i = a.stack.trim().match(/\n( *(at )?)/);
                j = i && i[1] || ""
            }
        return `
` + j + r
    }
    var ce = !1;
    function de(r, i) {
        if (!r || ce)
            return "";
        ce = !0;
        var a = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
            if (i)
                if (i = function() {
                    throw Error()
                }
                    ,
                    Object.defineProperty(i.prototype, "props", {
                        set: function() {
                            throw Error()
                        }
                    }),
                typeof Reflect == "object" && Reflect.construct) {
                    try {
                        Reflect.construct(i, [])
                    } catch (V) {
                        var c = V
                    }
                    Reflect.construct(r, [], i)
                } else {
                    try {
                        i.call()
                    } catch (V) {
                        c = V
                    }
                    r.call(i.prototype)
                }
            else {
                try {
                    throw Error()
                } catch (V) {
                    c = V
                }
                r()
            }
        } catch (V) {
            if (V && c && typeof V.stack == "string") {
                for (var h = V.stack.split(`
`), g = c.stack.split(`
`), C = h.length - 1, A = g.length - 1; 1 <= C && 0 <= A && h[C] !== g[A]; )
                    A--;
                for (; 1 <= C && 0 <= A; C--,
                    A--)
                    if (h[C] !== g[A]) {
                        if (C !== 1 || A !== 1)
                            do
                                if (C--,
                                    A--,
                                0 > A || h[C] !== g[A]) {
                                    var N = `
` + h[C].replace(" at new ", " at ");
                                    return r.displayName && N.includes("<anonymous>") && (N = N.replace("<anonymous>", r.displayName)),
                                        N
                                }
                            while (1 <= C && 0 <= A);
                        break
                    }
            }
        } finally {
            ce = !1,
                Error.prepareStackTrace = a
        }
        return (r = r ? r.displayName || r.name : "") ? K(r) : ""
    }
    function be(r) {
        switch (r.tag) {
            case 5:
                return K(r.type);
            case 16:
                return K("Lazy");
            case 13:
                return K("Suspense");
            case 19:
                return K("SuspenseList");
            case 0:
            case 2:
            case 15:
                return r = de(r.type, !1),
                    r;
            case 11:
                return r = de(r.type.render, !1),
                    r;
            case 1:
                return r = de(r.type, !0),
                    r;
            default:
                return ""
        }
    }
    function Te(r) {
        if (r == null)
            return null;
        if (typeof r == "function")
            return r.displayName || r.name || null;
        if (typeof r == "string")
            return r;
        switch (r) {
            case $:
                return "Fragment";
            case H:
                return "Portal";
            case W:
                return "Profiler";
            case O:
                return "StrictMode";
            case J:
                return "Suspense";
            case ae:
                return "SuspenseList"
        }
        if (typeof r == "object")
            switch (r.$$typeof) {
                case X:
                    return (r.displayName || "Context") + ".Consumer";
                case q:
                    return (r._context.displayName || "Context") + ".Provider";
                case z:
                    var i = r.render;
                    return r = r.displayName,
                    r || (r = i.displayName || i.name || "",
                        r = r !== "" ? "ForwardRef(" + r + ")" : "ForwardRef"),
                        r;
                case ie:
                    return i = r.displayName || null,
                        i !== null ? i : Te(r.type) || "Memo";
                case ne:
                    i = r._payload,
                        r = r._init;
                    try {
                        return Te(r(i))
                    } catch {}
            }
        return null
    }
    function Z(r) {
        var i = r.type;
        switch (r.tag) {
            case 24:
                return "Cache";
            case 9:
                return (i.displayName || "Context") + ".Consumer";
            case 10:
                return (i._context.displayName || "Context") + ".Provider";
            case 18:
                return "DehydratedFragment";
            case 11:
                return r = i.render,
                    r = r.displayName || r.name || "",
                i.displayName || (r !== "" ? "ForwardRef(" + r + ")" : "ForwardRef");
            case 7:
                return "Fragment";
            case 5:
                return i;
            case 4:
                return "Portal";
            case 3:
                return "Root";
            case 6:
                return "Text";
            case 16:
                return Te(i);
            case 8:
                return i === O ? "StrictMode" : "Mode";
            case 22:
                return "Offscreen";
            case 12:
                return "Profiler";
            case 21:
                return "Scope";
            case 13:
                return "Suspense";
            case 19:
                return "SuspenseList";
            case 25:
                return "TracingMarker";
            case 1:
            case 0:
            case 17:
            case 2:
            case 14:
            case 15:
                if (typeof i == "function")
                    return i.displayName || i.name || null;
                if (typeof i == "string")
                    return i
        }
        return null
    }
    function ye(r) {
        switch (typeof r) {
            case "boolean":
            case "number":
            case "string":
            case "undefined":
                return r;
            case "object":
                return r;
            default:
                return ""
        }
    }
    function Ce(r) {
        var i = r.type;
        return (r = r.nodeName) && r.toLowerCase() === "input" && (i === "checkbox" || i === "radio")
    }
    function Pe(r) {
        var i = Ce(r) ? "checked" : "value"
            , a = Object.getOwnPropertyDescriptor(r.constructor.prototype, i)
            , c = "" + r[i];
        if (!r.hasOwnProperty(i) && typeof a < "u" && typeof a.get == "function" && typeof a.set == "function") {
            var h = a.get
                , g = a.set;
            return Object.defineProperty(r, i, {
                configurable: !0,
                get: function() {
                    return h.call(this)
                },
                set: function(C) {
                    c = "" + C,
                        g.call(this, C)
                }
            }),
                Object.defineProperty(r, i, {
                    enumerable: a.enumerable
                }),
                {
                    getValue: function() {
                        return c
                    },
                    setValue: function(C) {
                        c = "" + C
                    },
                    stopTracking: function() {
                        r._valueTracker = null,
                            delete r[i]
                    }
                }
        }
    }
    function _e(r) {
        r._valueTracker || (r._valueTracker = Pe(r))
    }
    function Ne(r) {
        if (!r)
            return !1;
        var i = r._valueTracker;
        if (!i)
            return !0;
        var a = i.getValue()
            , c = "";
        return r && (c = Ce(r) ? r.checked ? "true" : "false" : r.value),
            r = c,
            r !== a ? (i.setValue(r),
                !0) : !1
    }
    function ut(r) {
        if (r = r || (typeof document < "u" ? document : void 0),
        typeof r > "u")
            return null;
        try {
            return r.activeElement || r.body
        } catch {
            return r.body
        }
    }
    function Nt(r, i) {
        var a = i.checked;
        return ee({}, i, {
            defaultChecked: void 0,
            defaultValue: void 0,
            value: void 0,
            checked: a ?? r._wrapperState.initialChecked
        })
    }
    function cr(r, i) {
        var a = i.defaultValue == null ? "" : i.defaultValue
            , c = i.checked != null ? i.checked : i.defaultChecked;
        a = ye(i.value != null ? i.value : a),
            r._wrapperState = {
                initialChecked: c,
                initialValue: a,
                controlled: i.type === "checkbox" || i.type === "radio" ? i.checked != null : i.value != null
            }
    }
    function dr(r, i) {
        i = i.checked,
        i != null && R(r, "checked", i, !1)
    }
    function Hn(r, i) {
        dr(r, i);
        var a = ye(i.value)
            , c = i.type;
        if (a != null)
            c === "number" ? (a === 0 && r.value === "" || r.value != a) && (r.value = "" + a) : r.value !== "" + a && (r.value = "" + a);
        else if (c === "submit" || c === "reset") {
            r.removeAttribute("value");
            return
        }
        i.hasOwnProperty("value") ? fr(r, i.type, a) : i.hasOwnProperty("defaultValue") && fr(r, i.type, ye(i.defaultValue)),
        i.checked == null && i.defaultChecked != null && (r.defaultChecked = !!i.defaultChecked)
    }
    function Ua(r, i, a) {
        if (i.hasOwnProperty("value") || i.hasOwnProperty("defaultValue")) {
            var c = i.type;
            if (!(c !== "submit" && c !== "reset" || i.value !== void 0 && i.value !== null))
                return;
            i = "" + r._wrapperState.initialValue,
            a || i === r.value || (r.value = i),
                r.defaultValue = i
        }
        a = r.name,
        a !== "" && (r.name = ""),
            r.defaultChecked = !!r._wrapperState.initialChecked,
        a !== "" && (r.name = a)
    }
    function fr(r, i, a) {
        (i !== "number" || ut(r.ownerDocument) !== r) && (a == null ? r.defaultValue = "" + r._wrapperState.initialValue : r.defaultValue !== "" + a && (r.defaultValue = "" + a))
    }
    var so = Array.isArray;
    function Ws(r, i, a, c) {
        if (r = r.options,
            i) {
            i = {};
            for (var h = 0; h < a.length; h++)
                i["$" + a[h]] = !0;
            for (a = 0; a < r.length; a++)
                h = i.hasOwnProperty("$" + r[a].value),
                r[a].selected !== h && (r[a].selected = h),
                h && c && (r[a].defaultSelected = !0)
        } else {
            for (a = "" + ye(a),
                     i = null,
                     h = 0; h < r.length; h++) {
                if (r[h].value === a) {
                    r[h].selected = !0,
                    c && (r[h].defaultSelected = !0);
                    return
                }
                i !== null || r[h].disabled || (i = r[h])
            }
            i !== null && (i.selected = !0)
        }
    }
    function hc(r, i) {
        if (i.dangerouslySetInnerHTML != null)
            throw Error(n(91));
        return ee({}, i, {
            value: void 0,
            defaultValue: void 0,
            children: "" + r._wrapperState.initialValue
        })
    }
    function lm(r, i) {
        var a = i.value;
        if (a == null) {
            if (a = i.children,
                i = i.defaultValue,
            a != null) {
                if (i != null)
                    throw Error(n(92));
                if (so(a)) {
                    if (1 < a.length)
                        throw Error(n(93));
                    a = a[0]
                }
                i = a
            }
            i == null && (i = ""),
                a = i
        }
        r._wrapperState = {
            initialValue: ye(a)
        }
    }
    function um(r, i) {
        var a = ye(i.value)
            , c = ye(i.defaultValue);
        a != null && (a = "" + a,
        a !== r.value && (r.value = a),
        i.defaultValue == null && r.defaultValue !== a && (r.defaultValue = a)),
        c != null && (r.defaultValue = "" + c)
    }
    function cm(r) {
        var i = r.textContent;
        i === r._wrapperState.initialValue && i !== "" && i !== null && (r.value = i)
    }
    function dm(r) {
        switch (r) {
            case "svg":
                return "http://www.w3.org/2000/svg";
            case "math":
                return "http://www.w3.org/1998/Math/MathML";
            default:
                return "http://www.w3.org/1999/xhtml"
        }
    }
    function pc(r, i) {
        return r == null || r === "http://www.w3.org/1999/xhtml" ? dm(i) : r === "http://www.w3.org/2000/svg" && i === "foreignObject" ? "http://www.w3.org/1999/xhtml" : r
    }
    var za, fm = (function(r) {
            return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(i, a, c, h) {
                    MSApp.execUnsafeLocalFunction(function() {
                        return r(i, a, c, h)
                    })
                }
                : r
        }
    )(function(r, i) {
        if (r.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML"in r)
            r.innerHTML = i;
        else {
            for (za = za || document.createElement("div"),
                     za.innerHTML = "<svg>" + i.valueOf().toString() + "</svg>",
                     i = za.firstChild; r.firstChild; )
                r.removeChild(r.firstChild);
            for (; i.firstChild; )
                r.appendChild(i.firstChild)
        }
    });
    function io(r, i) {
        if (i) {
            var a = r.firstChild;
            if (a && a === r.lastChild && a.nodeType === 3) {
                a.nodeValue = i;
                return
            }
        }
        r.textContent = i
    }
    var oo = {
        animationIterationCount: !0,
        aspectRatio: !0,
        borderImageOutset: !0,
        borderImageSlice: !0,
        borderImageWidth: !0,
        boxFlex: !0,
        boxFlexGroup: !0,
        boxOrdinalGroup: !0,
        columnCount: !0,
        columns: !0,
        flex: !0,
        flexGrow: !0,
        flexPositive: !0,
        flexShrink: !0,
        flexNegative: !0,
        flexOrder: !0,
        gridArea: !0,
        gridRow: !0,
        gridRowEnd: !0,
        gridRowSpan: !0,
        gridRowStart: !0,
        gridColumn: !0,
        gridColumnEnd: !0,
        gridColumnSpan: !0,
        gridColumnStart: !0,
        fontWeight: !0,
        lineClamp: !0,
        lineHeight: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        tabSize: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
        fillOpacity: !0,
        floodOpacity: !0,
        stopOpacity: !0,
        strokeDasharray: !0,
        strokeDashoffset: !0,
        strokeMiterlimit: !0,
        strokeOpacity: !0,
        strokeWidth: !0
    }
        , VE = ["Webkit", "ms", "Moz", "O"];
    Object.keys(oo).forEach(function(r) {
        VE.forEach(function(i) {
            i = i + r.charAt(0).toUpperCase() + r.substring(1),
                oo[i] = oo[r]
        })
    });
    function hm(r, i, a) {
        return i == null || typeof i == "boolean" || i === "" ? "" : a || typeof i != "number" || i === 0 || oo.hasOwnProperty(r) && oo[r] ? ("" + i).trim() : i + "px"
    }
    function pm(r, i) {
        r = r.style;
        for (var a in i)
            if (i.hasOwnProperty(a)) {
                var c = a.indexOf("--") === 0
                    , h = hm(a, i[a], c);
                a === "float" && (a = "cssFloat"),
                    c ? r.setProperty(a, h) : r[a] = h
            }
    }
    var UE = ee({
        menuitem: !0
    }, {
        area: !0,
        base: !0,
        br: !0,
        col: !0,
        embed: !0,
        hr: !0,
        img: !0,
        input: !0,
        keygen: !0,
        link: !0,
        meta: !0,
        param: !0,
        source: !0,
        track: !0,
        wbr: !0
    });
    function mc(r, i) {
        if (i) {
            if (UE[r] && (i.children != null || i.dangerouslySetInnerHTML != null))
                throw Error(n(137, r));
            if (i.dangerouslySetInnerHTML != null) {
                if (i.children != null)
                    throw Error(n(60));
                if (typeof i.dangerouslySetInnerHTML != "object" || !("__html"in i.dangerouslySetInnerHTML))
                    throw Error(n(61))
            }
            if (i.style != null && typeof i.style != "object")
                throw Error(n(62))
        }
    }
    function gc(r, i) {
        if (r.indexOf("-") === -1)
            return typeof i.is == "string";
        switch (r) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
                return !1;
            default:
                return !0
        }
    }
    var yc = null;
    function vc(r) {
        return r = r.target || r.srcElement || window,
        r.correspondingUseElement && (r = r.correspondingUseElement),
            r.nodeType === 3 ? r.parentNode : r
    }
    var wc = null
        , Hs = null
        , qs = null;
    function mm(r) {
        if (r = Ao(r)) {
            if (typeof wc != "function")
                throw Error(n(280));
            var i = r.stateNode;
            i && (i = dl(i),
                wc(r.stateNode, r.type, i))
        }
    }
    function gm(r) {
        Hs ? qs ? qs.push(r) : qs = [r] : Hs = r
    }
    function ym() {
        if (Hs) {
            var r = Hs
                , i = qs;
            if (qs = Hs = null,
                mm(r),
                i)
                for (r = 0; r < i.length; r++)
                    mm(i[r])
        }
    }
    function vm(r, i) {
        return r(i)
    }
    function wm() {}
    var xc = !1;
    function xm(r, i, a) {
        if (xc)
            return r(i, a);
        xc = !0;
        try {
            return vm(r, i, a)
        } finally {
            xc = !1,
            (Hs !== null || qs !== null) && (wm(),
                ym())
        }
    }
    function ao(r, i) {
        var a = r.stateNode;
        if (a === null)
            return null;
        var c = dl(a);
        if (c === null)
            return null;
        a = c[i];
        e: switch (i) {
            case "onClick":
            case "onClickCapture":
            case "onDoubleClick":
            case "onDoubleClickCapture":
            case "onMouseDown":
            case "onMouseDownCapture":
            case "onMouseMove":
            case "onMouseMoveCapture":
            case "onMouseUp":
            case "onMouseUpCapture":
            case "onMouseEnter":
                (c = !c.disabled) || (r = r.type,
                    c = !(r === "button" || r === "input" || r === "select" || r === "textarea")),
                    r = !c;
                break e;
            default:
                r = !1
        }
        if (r)
            return null;
        if (a && typeof a != "function")
            throw Error(n(231, i, typeof a));
        return a
    }
    var Sc = !1;
    if (d)
        try {
            var lo = {};
            Object.defineProperty(lo, "passive", {
                get: function() {
                    Sc = !0
                }
            }),
                window.addEventListener("test", lo, lo),
                window.removeEventListener("test", lo, lo)
        } catch {
            Sc = !1
        }
    function zE(r, i, a, c, h, g, C, A, N) {
        var V = Array.prototype.slice.call(arguments, 3);
        try {
            i.apply(a, V)
        } catch (G) {
            this.onError(G)
        }
    }
    var uo = !1
        , $a = null
        , Wa = !1
        , bc = null
        , $E = {
        onError: function(r) {
            uo = !0,
                $a = r
        }
    };
    function WE(r, i, a, c, h, g, C, A, N) {
        uo = !1,
            $a = null,
            zE.apply($E, arguments)
    }
    function HE(r, i, a, c, h, g, C, A, N) {
        if (WE.apply(this, arguments),
            uo) {
            if (uo) {
                var V = $a;
                uo = !1,
                    $a = null
            } else
                throw Error(n(198));
            Wa || (Wa = !0,
                bc = V)
        }
    }
    function ss(r) {
        var i = r
            , a = r;
        if (r.alternate)
            for (; i.return; )
                i = i.return;
        else {
            r = i;
            do
                i = r,
                (i.flags & 4098) !== 0 && (a = i.return),
                    r = i.return;
            while (r)
        }
        return i.tag === 3 ? a : null
    }
    function Sm(r) {
        if (r.tag === 13) {
            var i = r.memoizedState;
            if (i === null && (r = r.alternate,
            r !== null && (i = r.memoizedState)),
            i !== null)
                return i.dehydrated
        }
        return null
    }
    function bm(r) {
        if (ss(r) !== r)
            throw Error(n(188))
    }
    function qE(r) {
        var i = r.alternate;
        if (!i) {
            if (i = ss(r),
            i === null)
                throw Error(n(188));
            return i !== r ? null : r
        }
        for (var a = r, c = i; ; ) {
            var h = a.return;
            if (h === null)
                break;
            var g = h.alternate;
            if (g === null) {
                if (c = h.return,
                c !== null) {
                    a = c;
                    continue
                }
                break
            }
            if (h.child === g.child) {
                for (g = h.child; g; ) {
                    if (g === a)
                        return bm(h),
                            r;
                    if (g === c)
                        return bm(h),
                            i;
                    g = g.sibling
                }
                throw Error(n(188))
            }
            if (a.return !== c.return)
                a = h,
                    c = g;
            else {
                for (var C = !1, A = h.child; A; ) {
                    if (A === a) {
                        C = !0,
                            a = h,
                            c = g;
                        break
                    }
                    if (A === c) {
                        C = !0,
                            c = h,
                            a = g;
                        break
                    }
                    A = A.sibling
                }
                if (!C) {
                    for (A = g.child; A; ) {
                        if (A === a) {
                            C = !0,
                                a = g,
                                c = h;
                            break
                        }
                        if (A === c) {
                            C = !0,
                                c = g,
                                a = h;
                            break
                        }
                        A = A.sibling
                    }
                    if (!C)
                        throw Error(n(189))
                }
            }
            if (a.alternate !== c)
                throw Error(n(190))
        }
        if (a.tag !== 3)
            throw Error(n(188));
        return a.stateNode.current === a ? r : i
    }
    function Em(r) {
        return r = qE(r),
            r !== null ? Cm(r) : null
    }
    function Cm(r) {
        if (r.tag === 5 || r.tag === 6)
            return r;
        for (r = r.child; r !== null; ) {
            var i = Cm(r);
            if (i !== null)
                return i;
            r = r.sibling
        }
        return null
    }
    var Pm = t.unstable_scheduleCallback
        , Tm = t.unstable_cancelCallback
        , KE = t.unstable_shouldYield
        , QE = t.unstable_requestPaint
        , Xe = t.unstable_now
        , GE = t.unstable_getCurrentPriorityLevel
        , Ec = t.unstable_ImmediatePriority
        , km = t.unstable_UserBlockingPriority
        , Ha = t.unstable_NormalPriority
        , XE = t.unstable_LowPriority
        , Rm = t.unstable_IdlePriority
        , qa = null
        , Tn = null;
    function YE(r) {
        if (Tn && typeof Tn.onCommitFiberRoot == "function")
            try {
                Tn.onCommitFiberRoot(qa, r, void 0, (r.current.flags & 128) === 128)
            } catch {}
    }
    var cn = Math.clz32 ? Math.clz32 : eC
        , JE = Math.log
        , ZE = Math.LN2;
    function eC(r) {
        return r >>>= 0,
            r === 0 ? 32 : 31 - (JE(r) / ZE | 0) | 0
    }
    var Ka = 64
        , Qa = 4194304;
    function co(r) {
        switch (r & -r) {
            case 1:
                return 1;
            case 2:
                return 2;
            case 4:
                return 4;
            case 8:
                return 8;
            case 16:
                return 16;
            case 32:
                return 32;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
                return r & 4194240;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                return r & 130023424;
            case 134217728:
                return 134217728;
            case 268435456:
                return 268435456;
            case 536870912:
                return 536870912;
            case 1073741824:
                return 1073741824;
            default:
                return r
        }
    }
    function Ga(r, i) {
        var a = r.pendingLanes;
        if (a === 0)
            return 0;
        var c = 0
            , h = r.suspendedLanes
            , g = r.pingedLanes
            , C = a & 268435455;
        if (C !== 0) {
            var A = C & ~h;
            A !== 0 ? c = co(A) : (g &= C,
            g !== 0 && (c = co(g)))
        } else
            C = a & ~h,
                C !== 0 ? c = co(C) : g !== 0 && (c = co(g));
        if (c === 0)
            return 0;
        if (i !== 0 && i !== c && (i & h) === 0 && (h = c & -c,
            g = i & -i,
        h >= g || h === 16 && (g & 4194240) !== 0))
            return i;
        if ((c & 4) !== 0 && (c |= a & 16),
            i = r.entangledLanes,
        i !== 0)
            for (r = r.entanglements,
                     i &= c; 0 < i; )
                a = 31 - cn(i),
                    h = 1 << a,
                    c |= r[a],
                    i &= ~h;
        return c
    }
    function tC(r, i) {
        switch (r) {
            case 1:
            case 2:
            case 4:
                return i + 250;
            case 8:
            case 16:
            case 32:
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
                return i + 5e3;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                return -1;
            case 134217728:
            case 268435456:
            case 536870912:
            case 1073741824:
                return -1;
            default:
                return -1
        }
    }
    function nC(r, i) {
        for (var a = r.suspendedLanes, c = r.pingedLanes, h = r.expirationTimes, g = r.pendingLanes; 0 < g; ) {
            var C = 31 - cn(g)
                , A = 1 << C
                , N = h[C];
            N === -1 ? ((A & a) === 0 || (A & c) !== 0) && (h[C] = tC(A, i)) : N <= i && (r.expiredLanes |= A),
                g &= ~A
        }
    }
    function Cc(r) {
        return r = r.pendingLanes & -1073741825,
            r !== 0 ? r : r & 1073741824 ? 1073741824 : 0
    }
    function Am() {
        var r = Ka;
        return Ka <<= 1,
        (Ka & 4194240) === 0 && (Ka = 64),
            r
    }
    function Pc(r) {
        for (var i = [], a = 0; 31 > a; a++)
            i.push(r);
        return i
    }
    function fo(r, i, a) {
        r.pendingLanes |= i,
        i !== 536870912 && (r.suspendedLanes = 0,
            r.pingedLanes = 0),
            r = r.eventTimes,
            i = 31 - cn(i),
            r[i] = a
    }
    function rC(r, i) {
        var a = r.pendingLanes & ~i;
        r.pendingLanes = i,
            r.suspendedLanes = 0,
            r.pingedLanes = 0,
            r.expiredLanes &= i,
            r.mutableReadLanes &= i,
            r.entangledLanes &= i,
            i = r.entanglements;
        var c = r.eventTimes;
        for (r = r.expirationTimes; 0 < a; ) {
            var h = 31 - cn(a)
                , g = 1 << h;
            i[h] = 0,
                c[h] = -1,
                r[h] = -1,
                a &= ~g
        }
    }
    function Tc(r, i) {
        var a = r.entangledLanes |= i;
        for (r = r.entanglements; a; ) {
            var c = 31 - cn(a)
                , h = 1 << c;
            h & i | r[c] & i && (r[c] |= i),
                a &= ~h
        }
    }
    var Fe = 0;
    function _m(r) {
        return r &= -r,
            1 < r ? 4 < r ? (r & 268435455) !== 0 ? 16 : 536870912 : 4 : 1
    }
    var Nm, kc, Om, Lm, Mm, Rc = !1, Xa = [], hr = null, pr = null, mr = null, ho = new Map, po = new Map, gr = [], sC = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
    function jm(r, i) {
        switch (r) {
            case "focusin":
            case "focusout":
                hr = null;
                break;
            case "dragenter":
            case "dragleave":
                pr = null;
                break;
            case "mouseover":
            case "mouseout":
                mr = null;
                break;
            case "pointerover":
            case "pointerout":
                ho.delete(i.pointerId);
                break;
            case "gotpointercapture":
            case "lostpointercapture":
                po.delete(i.pointerId)
        }
    }
    function mo(r, i, a, c, h, g) {
        return r === null || r.nativeEvent !== g ? (r = {
            blockedOn: i,
            domEventName: a,
            eventSystemFlags: c,
            nativeEvent: g,
            targetContainers: [h]
        },
        i !== null && (i = Ao(i),
        i !== null && kc(i)),
            r) : (r.eventSystemFlags |= c,
            i = r.targetContainers,
        h !== null && i.indexOf(h) === -1 && i.push(h),
            r)
    }
    function iC(r, i, a, c, h) {
        switch (i) {
            case "focusin":
                return hr = mo(hr, r, i, a, c, h),
                    !0;
            case "dragenter":
                return pr = mo(pr, r, i, a, c, h),
                    !0;
            case "mouseover":
                return mr = mo(mr, r, i, a, c, h),
                    !0;
            case "pointerover":
                var g = h.pointerId;
                return ho.set(g, mo(ho.get(g) || null, r, i, a, c, h)),
                    !0;
            case "gotpointercapture":
                return g = h.pointerId,
                    po.set(g, mo(po.get(g) || null, r, i, a, c, h)),
                    !0
        }
        return !1
    }
    function Dm(r) {
        var i = is(r.target);
        if (i !== null) {
            var a = ss(i);
            if (a !== null) {
                if (i = a.tag,
                i === 13) {
                    if (i = Sm(a),
                    i !== null) {
                        r.blockedOn = i,
                            Mm(r.priority, function() {
                                Om(a)
                            });
                        return
                    }
                } else if (i === 3 && a.stateNode.current.memoizedState.isDehydrated) {
                    r.blockedOn = a.tag === 3 ? a.stateNode.containerInfo : null;
                    return
                }
            }
        }
        r.blockedOn = null
    }
    function Ya(r) {
        if (r.blockedOn !== null)
            return !1;
        for (var i = r.targetContainers; 0 < i.length; ) {
            var a = _c(r.domEventName, r.eventSystemFlags, i[0], r.nativeEvent);
            if (a === null) {
                a = r.nativeEvent;
                var c = new a.constructor(a.type,a);
                yc = c,
                    a.target.dispatchEvent(c),
                    yc = null
            } else
                return i = Ao(a),
                i !== null && kc(i),
                    r.blockedOn = a,
                    !1;
            i.shift()
        }
        return !0
    }
    function Im(r, i, a) {
        Ya(r) && a.delete(i)
    }
    function oC() {
        Rc = !1,
        hr !== null && Ya(hr) && (hr = null),
        pr !== null && Ya(pr) && (pr = null),
        mr !== null && Ya(mr) && (mr = null),
            ho.forEach(Im),
            po.forEach(Im)
    }
    function go(r, i) {
        r.blockedOn === i && (r.blockedOn = null,
        Rc || (Rc = !0,
            t.unstable_scheduleCallback(t.unstable_NormalPriority, oC)))
    }
    function yo(r) {
        function i(h) {
            return go(h, r)
        }
        if (0 < Xa.length) {
            go(Xa[0], r);
            for (var a = 1; a < Xa.length; a++) {
                var c = Xa[a];
                c.blockedOn === r && (c.blockedOn = null)
            }
        }
        for (hr !== null && go(hr, r),
             pr !== null && go(pr, r),
             mr !== null && go(mr, r),
                 ho.forEach(i),
                 po.forEach(i),
                 a = 0; a < gr.length; a++)
            c = gr[a],
            c.blockedOn === r && (c.blockedOn = null);
        for (; 0 < gr.length && (a = gr[0],
        a.blockedOn === null); )
            Dm(a),
            a.blockedOn === null && gr.shift()
    }
    var Ks = _.ReactCurrentBatchConfig
        , Ja = !0;
    function aC(r, i, a, c) {
        var h = Fe
            , g = Ks.transition;
        Ks.transition = null;
        try {
            Fe = 1,
                Ac(r, i, a, c)
        } finally {
            Fe = h,
                Ks.transition = g
        }
    }
    function lC(r, i, a, c) {
        var h = Fe
            , g = Ks.transition;
        Ks.transition = null;
        try {
            Fe = 4,
                Ac(r, i, a, c)
        } finally {
            Fe = h,
                Ks.transition = g
        }
    }
    function Ac(r, i, a, c) {
        if (Ja) {
            var h = _c(r, i, a, c);
            if (h === null)
                Kc(r, i, c, Za, a),
                    jm(r, c);
            else if (iC(h, r, i, a, c))
                c.stopPropagation();
            else if (jm(r, c),
            i & 4 && -1 < sC.indexOf(r)) {
                for (; h !== null; ) {
                    var g = Ao(h);
                    if (g !== null && Nm(g),
                        g = _c(r, i, a, c),
                    g === null && Kc(r, i, c, Za, a),
                    g === h)
                        break;
                    h = g
                }
                h !== null && c.stopPropagation()
            } else
                Kc(r, i, c, null, a)
        }
    }
    var Za = null;
    function _c(r, i, a, c) {
        if (Za = null,
            r = vc(c),
            r = is(r),
        r !== null)
            if (i = ss(r),
            i === null)
                r = null;
            else if (a = i.tag,
            a === 13) {
                if (r = Sm(i),
                r !== null)
                    return r;
                r = null
            } else if (a === 3) {
                if (i.stateNode.current.memoizedState.isDehydrated)
                    return i.tag === 3 ? i.stateNode.containerInfo : null;
                r = null
            } else
                i !== r && (r = null);
        return Za = r,
            null
    }
    function Fm(r) {
        switch (r) {
            case "cancel":
            case "click":
            case "close":
            case "contextmenu":
            case "copy":
            case "cut":
            case "auxclick":
            case "dblclick":
            case "dragend":
            case "dragstart":
            case "drop":
            case "focusin":
            case "focusout":
            case "input":
            case "invalid":
            case "keydown":
            case "keypress":
            case "keyup":
            case "mousedown":
            case "mouseup":
            case "paste":
            case "pause":
            case "play":
            case "pointercancel":
            case "pointerdown":
            case "pointerup":
            case "ratechange":
            case "reset":
            case "resize":
            case "seeked":
            case "submit":
            case "touchcancel":
            case "touchend":
            case "touchstart":
            case "volumechange":
            case "change":
            case "selectionchange":
            case "textInput":
            case "compositionstart":
            case "compositionend":
            case "compositionupdate":
            case "beforeblur":
            case "afterblur":
            case "beforeinput":
            case "blur":
            case "fullscreenchange":
            case "focus":
            case "hashchange":
            case "popstate":
            case "select":
            case "selectstart":
                return 1;
            case "drag":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "mousemove":
            case "mouseout":
            case "mouseover":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "scroll":
            case "toggle":
            case "touchmove":
            case "wheel":
            case "mouseenter":
            case "mouseleave":
            case "pointerenter":
            case "pointerleave":
                return 4;
            case "message":
                switch (GE()) {
                    case Ec:
                        return 1;
                    case km:
                        return 4;
                    case Ha:
                    case XE:
                        return 16;
                    case Rm:
                        return 536870912;
                    default:
                        return 16
                }
            default:
                return 16
        }
    }
    var yr = null
        , Nc = null
        , el = null;
    function Bm() {
        if (el)
            return el;
        var r, i = Nc, a = i.length, c, h = "value"in yr ? yr.value : yr.textContent, g = h.length;
        for (r = 0; r < a && i[r] === h[r]; r++)
            ;
        var C = a - r;
        for (c = 1; c <= C && i[a - c] === h[g - c]; c++)
            ;
        return el = h.slice(r, 1 < c ? 1 - c : void 0)
    }
    function tl(r) {
        var i = r.keyCode;
        return "charCode"in r ? (r = r.charCode,
        r === 0 && i === 13 && (r = 13)) : r = i,
        r === 10 && (r = 13),
            32 <= r || r === 13 ? r : 0
    }
    function nl() {
        return !0
    }
    function Vm() {
        return !1
    }
    function $t(r) {
        function i(a, c, h, g, C) {
            this._reactName = a,
                this._targetInst = h,
                this.type = c,
                this.nativeEvent = g,
                this.target = C,
                this.currentTarget = null;
            for (var A in r)
                r.hasOwnProperty(A) && (a = r[A],
                    this[A] = a ? a(g) : g[A]);
            return this.isDefaultPrevented = (g.defaultPrevented != null ? g.defaultPrevented : g.returnValue === !1) ? nl : Vm,
                this.isPropagationStopped = Vm,
                this
        }
        return ee(i.prototype, {
            preventDefault: function() {
                this.defaultPrevented = !0;
                var a = this.nativeEvent;
                a && (a.preventDefault ? a.preventDefault() : typeof a.returnValue != "unknown" && (a.returnValue = !1),
                    this.isDefaultPrevented = nl)
            },
            stopPropagation: function() {
                var a = this.nativeEvent;
                a && (a.stopPropagation ? a.stopPropagation() : typeof a.cancelBubble != "unknown" && (a.cancelBubble = !0),
                    this.isPropagationStopped = nl)
            },
            persist: function() {},
            isPersistent: nl
        }),
            i
    }
    var Qs = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(r) {
            return r.timeStamp || Date.now()
        },
        defaultPrevented: 0,
        isTrusted: 0
    }, Oc = $t(Qs), vo = ee({}, Qs, {
        view: 0,
        detail: 0
    }), uC = $t(vo), Lc, Mc, wo, rl = ee({}, vo, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: Dc,
        button: 0,
        buttons: 0,
        relatedTarget: function(r) {
            return r.relatedTarget === void 0 ? r.fromElement === r.srcElement ? r.toElement : r.fromElement : r.relatedTarget
        },
        movementX: function(r) {
            return "movementX"in r ? r.movementX : (r !== wo && (wo && r.type === "mousemove" ? (Lc = r.screenX - wo.screenX,
                Mc = r.screenY - wo.screenY) : Mc = Lc = 0,
                wo = r),
                Lc)
        },
        movementY: function(r) {
            return "movementY"in r ? r.movementY : Mc
        }
    }), Um = $t(rl), cC = ee({}, rl, {
        dataTransfer: 0
    }), dC = $t(cC), fC = ee({}, vo, {
        relatedTarget: 0
    }), jc = $t(fC), hC = ee({}, Qs, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }), pC = $t(hC), mC = ee({}, Qs, {
        clipboardData: function(r) {
            return "clipboardData"in r ? r.clipboardData : window.clipboardData
        }
    }), gC = $t(mC), yC = ee({}, Qs, {
        data: 0
    }), zm = $t(yC), vC = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
    }, wC = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
    }, xC = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
    };
    function SC(r) {
        var i = this.nativeEvent;
        return i.getModifierState ? i.getModifierState(r) : (r = xC[r]) ? !!i[r] : !1
    }
    function Dc() {
        return SC
    }
    var bC = ee({}, vo, {
        key: function(r) {
            if (r.key) {
                var i = vC[r.key] || r.key;
                if (i !== "Unidentified")
                    return i
            }
            return r.type === "keypress" ? (r = tl(r),
                r === 13 ? "Enter" : String.fromCharCode(r)) : r.type === "keydown" || r.type === "keyup" ? wC[r.keyCode] || "Unidentified" : ""
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: Dc,
        charCode: function(r) {
            return r.type === "keypress" ? tl(r) : 0
        },
        keyCode: function(r) {
            return r.type === "keydown" || r.type === "keyup" ? r.keyCode : 0
        },
        which: function(r) {
            return r.type === "keypress" ? tl(r) : r.type === "keydown" || r.type === "keyup" ? r.keyCode : 0
        }
    })
        , EC = $t(bC)
        , CC = ee({}, rl, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
    })
        , $m = $t(CC)
        , PC = ee({}, vo, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: Dc
    })
        , TC = $t(PC)
        , kC = ee({}, Qs, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    })
        , RC = $t(kC)
        , AC = ee({}, rl, {
        deltaX: function(r) {
            return "deltaX"in r ? r.deltaX : "wheelDeltaX"in r ? -r.wheelDeltaX : 0
        },
        deltaY: function(r) {
            return "deltaY"in r ? r.deltaY : "wheelDeltaY"in r ? -r.wheelDeltaY : "wheelDelta"in r ? -r.wheelDelta : 0
        },
        deltaZ: 0,
        deltaMode: 0
    })
        , _C = $t(AC)
        , NC = [9, 13, 27, 32]
        , Ic = d && "CompositionEvent"in window
        , xo = null;
    d && "documentMode"in document && (xo = document.documentMode);
    var OC = d && "TextEvent"in window && !xo
        , Wm = d && (!Ic || xo && 8 < xo && 11 >= xo)
        , Hm = " "
        , qm = !1;
    function Km(r, i) {
        switch (r) {
            case "keyup":
                return NC.indexOf(i.keyCode) !== -1;
            case "keydown":
                return i.keyCode !== 229;
            case "keypress":
            case "mousedown":
            case "focusout":
                return !0;
            default:
                return !1
        }
    }
    function Qm(r) {
        return r = r.detail,
            typeof r == "object" && "data"in r ? r.data : null
    }
    var Gs = !1;
    function LC(r, i) {
        switch (r) {
            case "compositionend":
                return Qm(i);
            case "keypress":
                return i.which !== 32 ? null : (qm = !0,
                    Hm);
            case "textInput":
                return r = i.data,
                    r === Hm && qm ? null : r;
            default:
                return null
        }
    }
    function MC(r, i) {
        if (Gs)
            return r === "compositionend" || !Ic && Km(r, i) ? (r = Bm(),
                el = Nc = yr = null,
                Gs = !1,
                r) : null;
        switch (r) {
            case "paste":
                return null;
            case "keypress":
                if (!(i.ctrlKey || i.altKey || i.metaKey) || i.ctrlKey && i.altKey) {
                    if (i.char && 1 < i.char.length)
                        return i.char;
                    if (i.which)
                        return String.fromCharCode(i.which)
                }
                return null;
            case "compositionend":
                return Wm && i.locale !== "ko" ? null : i.data;
            default:
                return null
        }
    }
    var jC = {
        color: !0,
        date: !0,
        datetime: !0,
        "datetime-local": !0,
        email: !0,
        month: !0,
        number: !0,
        password: !0,
        range: !0,
        search: !0,
        tel: !0,
        text: !0,
        time: !0,
        url: !0,
        week: !0
    };
    function Gm(r) {
        var i = r && r.nodeName && r.nodeName.toLowerCase();
        return i === "input" ? !!jC[r.type] : i === "textarea"
    }
    function Xm(r, i, a, c) {
        gm(c),
            i = ll(i, "onChange"),
        0 < i.length && (a = new Oc("onChange","change",null,a,c),
            r.push({
                event: a,
                listeners: i
            }))
    }
    var So = null
        , bo = null;
    function DC(r) {
        pg(r, 0)
    }
    function sl(r) {
        var i = ei(r);
        if (Ne(i))
            return r
    }
    function IC(r, i) {
        if (r === "change")
            return i
    }
    var Ym = !1;
    if (d) {
        var Fc;
        if (d) {
            var Bc = "oninput"in document;
            if (!Bc) {
                var Jm = document.createElement("div");
                Jm.setAttribute("oninput", "return;"),
                    Bc = typeof Jm.oninput == "function"
            }
            Fc = Bc
        } else
            Fc = !1;
        Ym = Fc && (!document.documentMode || 9 < document.documentMode)
    }
    function Zm() {
        So && (So.detachEvent("onpropertychange", eg),
            bo = So = null)
    }
    function eg(r) {
        if (r.propertyName === "value" && sl(bo)) {
            var i = [];
            Xm(i, bo, r, vc(r)),
                xm(DC, i)
        }
    }
    function FC(r, i, a) {
        r === "focusin" ? (Zm(),
            So = i,
            bo = a,
            So.attachEvent("onpropertychange", eg)) : r === "focusout" && Zm()
    }
    function BC(r) {
        if (r === "selectionchange" || r === "keyup" || r === "keydown")
            return sl(bo)
    }
    function VC(r, i) {
        if (r === "click")
            return sl(i)
    }
    function UC(r, i) {
        if (r === "input" || r === "change")
            return sl(i)
    }
    function zC(r, i) {
        return r === i && (r !== 0 || 1 / r === 1 / i) || r !== r && i !== i
    }
    var dn = typeof Object.is == "function" ? Object.is : zC;
    function Eo(r, i) {
        if (dn(r, i))
            return !0;
        if (typeof r != "object" || r === null || typeof i != "object" || i === null)
            return !1;
        var a = Object.keys(r)
            , c = Object.keys(i);
        if (a.length !== c.length)
            return !1;
        for (c = 0; c < a.length; c++) {
            var h = a[c];
            if (!f.call(i, h) || !dn(r[h], i[h]))
                return !1
        }
        return !0
    }
    function tg(r) {
        for (; r && r.firstChild; )
            r = r.firstChild;
        return r
    }
    function ng(r, i) {
        var a = tg(r);
        r = 0;
        for (var c; a; ) {
            if (a.nodeType === 3) {
                if (c = r + a.textContent.length,
                r <= i && c >= i)
                    return {
                        node: a,
                        offset: i - r
                    };
                r = c
            }
            e: {
                for (; a; ) {
                    if (a.nextSibling) {
                        a = a.nextSibling;
                        break e
                    }
                    a = a.parentNode
                }
                a = void 0
            }
            a = tg(a)
        }
    }
    function rg(r, i) {
        return r && i ? r === i ? !0 : r && r.nodeType === 3 ? !1 : i && i.nodeType === 3 ? rg(r, i.parentNode) : "contains"in r ? r.contains(i) : r.compareDocumentPosition ? !!(r.compareDocumentPosition(i) & 16) : !1 : !1
    }
    function sg() {
        for (var r = window, i = ut(); i instanceof r.HTMLIFrameElement; ) {
            try {
                var a = typeof i.contentWindow.location.href == "string"
            } catch {
                a = !1
            }
            if (a)
                r = i.contentWindow;
            else
                break;
            i = ut(r.document)
        }
        return i
    }
    function Vc(r) {
        var i = r && r.nodeName && r.nodeName.toLowerCase();
        return i && (i === "input" && (r.type === "text" || r.type === "search" || r.type === "tel" || r.type === "url" || r.type === "password") || i === "textarea" || r.contentEditable === "true")
    }
    function $C(r) {
        var i = sg()
            , a = r.focusedElem
            , c = r.selectionRange;
        if (i !== a && a && a.ownerDocument && rg(a.ownerDocument.documentElement, a)) {
            if (c !== null && Vc(a)) {
                if (i = c.start,
                    r = c.end,
                r === void 0 && (r = i),
                "selectionStart"in a)
                    a.selectionStart = i,
                        a.selectionEnd = Math.min(r, a.value.length);
                else if (r = (i = a.ownerDocument || document) && i.defaultView || window,
                    r.getSelection) {
                    r = r.getSelection();
                    var h = a.textContent.length
                        , g = Math.min(c.start, h);
                    c = c.end === void 0 ? g : Math.min(c.end, h),
                    !r.extend && g > c && (h = c,
                        c = g,
                        g = h),
                        h = ng(a, g);
                    var C = ng(a, c);
                    h && C && (r.rangeCount !== 1 || r.anchorNode !== h.node || r.anchorOffset !== h.offset || r.focusNode !== C.node || r.focusOffset !== C.offset) && (i = i.createRange(),
                        i.setStart(h.node, h.offset),
                        r.removeAllRanges(),
                        g > c ? (r.addRange(i),
                            r.extend(C.node, C.offset)) : (i.setEnd(C.node, C.offset),
                            r.addRange(i)))
                }
            }
            for (i = [],
                     r = a; r = r.parentNode; )
                r.nodeType === 1 && i.push({
                    element: r,
                    left: r.scrollLeft,
                    top: r.scrollTop
                });
            for (typeof a.focus == "function" && a.focus(),
                     a = 0; a < i.length; a++)
                r = i[a],
                    r.element.scrollLeft = r.left,
                    r.element.scrollTop = r.top
        }
    }
    var WC = d && "documentMode"in document && 11 >= document.documentMode
        , Xs = null
        , Uc = null
        , Co = null
        , zc = !1;
    function ig(r, i, a) {
        var c = a.window === a ? a.document : a.nodeType === 9 ? a : a.ownerDocument;
        zc || Xs == null || Xs !== ut(c) || (c = Xs,
            "selectionStart"in c && Vc(c) ? c = {
                start: c.selectionStart,
                end: c.selectionEnd
            } : (c = (c.ownerDocument && c.ownerDocument.defaultView || window).getSelection(),
                c = {
                    anchorNode: c.anchorNode,
                    anchorOffset: c.anchorOffset,
                    focusNode: c.focusNode,
                    focusOffset: c.focusOffset
                }),
        Co && Eo(Co, c) || (Co = c,
            c = ll(Uc, "onSelect"),
        0 < c.length && (i = new Oc("onSelect","select",null,i,a),
            r.push({
                event: i,
                listeners: c
            }),
            i.target = Xs)))
    }
    function il(r, i) {
        var a = {};
        return a[r.toLowerCase()] = i.toLowerCase(),
            a["Webkit" + r] = "webkit" + i,
            a["Moz" + r] = "moz" + i,
            a
    }
    var Ys = {
        animationend: il("Animation", "AnimationEnd"),
        animationiteration: il("Animation", "AnimationIteration"),
        animationstart: il("Animation", "AnimationStart"),
        transitionend: il("Transition", "TransitionEnd")
    }
        , $c = {}
        , og = {};
    d && (og = document.createElement("div").style,
    "AnimationEvent"in window || (delete Ys.animationend.animation,
        delete Ys.animationiteration.animation,
        delete Ys.animationstart.animation),
    "TransitionEvent"in window || delete Ys.transitionend.transition);
    function ol(r) {
        if ($c[r])
            return $c[r];
        if (!Ys[r])
            return r;
        var i = Ys[r], a;
        for (a in i)
            if (i.hasOwnProperty(a) && a in og)
                return $c[r] = i[a];
        return r
    }
    var ag = ol("animationend")
        , lg = ol("animationiteration")
        , ug = ol("animationstart")
        , cg = ol("transitionend")
        , dg = new Map
        , fg = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    function vr(r, i) {
        dg.set(r, i),
            u(i, [r])
    }
    for (var Wc = 0; Wc < fg.length; Wc++) {
        var Hc = fg[Wc]
            , HC = Hc.toLowerCase()
            , qC = Hc[0].toUpperCase() + Hc.slice(1);
        vr(HC, "on" + qC)
    }
    vr(ag, "onAnimationEnd"),
        vr(lg, "onAnimationIteration"),
        vr(ug, "onAnimationStart"),
        vr("dblclick", "onDoubleClick"),
        vr("focusin", "onFocus"),
        vr("focusout", "onBlur"),
        vr(cg, "onTransitionEnd"),
        l("onMouseEnter", ["mouseout", "mouseover"]),
        l("onMouseLeave", ["mouseout", "mouseover"]),
        l("onPointerEnter", ["pointerout", "pointerover"]),
        l("onPointerLeave", ["pointerout", "pointerover"]),
        u("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")),
        u("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),
        u("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
        u("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")),
        u("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")),
        u("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var Po = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
        , KC = new Set("cancel close invalid load scroll toggle".split(" ").concat(Po));
    function hg(r, i, a) {
        var c = r.type || "unknown-event";
        r.currentTarget = a,
            HE(c, i, void 0, r),
            r.currentTarget = null
    }
    function pg(r, i) {
        i = (i & 4) !== 0;
        for (var a = 0; a < r.length; a++) {
            var c = r[a]
                , h = c.event;
            c = c.listeners;
            e: {
                var g = void 0;
                if (i)
                    for (var C = c.length - 1; 0 <= C; C--) {
                        var A = c[C]
                            , N = A.instance
                            , V = A.currentTarget;
                        if (A = A.listener,
                        N !== g && h.isPropagationStopped())
                            break e;
                        hg(h, A, V),
                            g = N
                    }
                else
                    for (C = 0; C < c.length; C++) {
                        if (A = c[C],
                            N = A.instance,
                            V = A.currentTarget,
                            A = A.listener,
                        N !== g && h.isPropagationStopped())
                            break e;
                        hg(h, A, V),
                            g = N
                    }
            }
        }
        if (Wa)
            throw r = bc,
                Wa = !1,
                bc = null,
                r
    }
    function Ve(r, i) {
        var a = i[Zc];
        a === void 0 && (a = i[Zc] = new Set);
        var c = r + "__bubble";
        a.has(c) || (mg(i, r, 2, !1),
            a.add(c))
    }
    function qc(r, i, a) {
        var c = 0;
        i && (c |= 4),
            mg(a, r, c, i)
    }
    var al = "_reactListening" + Math.random().toString(36).slice(2);
    function To(r) {
        if (!r[al]) {
            r[al] = !0,
                s.forEach(function(a) {
                    a !== "selectionchange" && (KC.has(a) || qc(a, !1, r),
                        qc(a, !0, r))
                });
            var i = r.nodeType === 9 ? r : r.ownerDocument;
            i === null || i[al] || (i[al] = !0,
                qc("selectionchange", !1, i))
        }
    }
    function mg(r, i, a, c) {
        switch (Fm(i)) {
            case 1:
                var h = aC;
                break;
            case 4:
                h = lC;
                break;
            default:
                h = Ac
        }
        a = h.bind(null, i, a, r),
            h = void 0,
        !Sc || i !== "touchstart" && i !== "touchmove" && i !== "wheel" || (h = !0),
            c ? h !== void 0 ? r.addEventListener(i, a, {
                capture: !0,
                passive: h
            }) : r.addEventListener(i, a, !0) : h !== void 0 ? r.addEventListener(i, a, {
                passive: h
            }) : r.addEventListener(i, a, !1)
    }
    function Kc(r, i, a, c, h) {
        var g = c;
        if ((i & 1) === 0 && (i & 2) === 0 && c !== null)
            e: for (; ; ) {
                if (c === null)
                    return;
                var C = c.tag;
                if (C === 3 || C === 4) {
                    var A = c.stateNode.containerInfo;
                    if (A === h || A.nodeType === 8 && A.parentNode === h)
                        break;
                    if (C === 4)
                        for (C = c.return; C !== null; ) {
                            var N = C.tag;
                            if ((N === 3 || N === 4) && (N = C.stateNode.containerInfo,
                            N === h || N.nodeType === 8 && N.parentNode === h))
                                return;
                            C = C.return
                        }
                    for (; A !== null; ) {
                        if (C = is(A),
                        C === null)
                            return;
                        if (N = C.tag,
                        N === 5 || N === 6) {
                            c = g = C;
                            continue e
                        }
                        A = A.parentNode
                    }
                }
                c = c.return
            }
        xm(function() {
            var V = g
                , G = vc(a)
                , Y = [];
            e: {
                var Q = dg.get(r);
                if (Q !== void 0) {
                    var oe = Oc
                        , fe = r;
                    switch (r) {
                        case "keypress":
                            if (tl(a) === 0)
                                break e;
                        case "keydown":
                        case "keyup":
                            oe = EC;
                            break;
                        case "focusin":
                            fe = "focus",
                                oe = jc;
                            break;
                        case "focusout":
                            fe = "blur",
                                oe = jc;
                            break;
                        case "beforeblur":
                        case "afterblur":
                            oe = jc;
                            break;
                        case "click":
                            if (a.button === 2)
                                break e;
                        case "auxclick":
                        case "dblclick":
                        case "mousedown":
                        case "mousemove":
                        case "mouseup":
                        case "mouseout":
                        case "mouseover":
                        case "contextmenu":
                            oe = Um;
                            break;
                        case "drag":
                        case "dragend":
                        case "dragenter":
                        case "dragexit":
                        case "dragleave":
                        case "dragover":
                        case "dragstart":
                        case "drop":
                            oe = dC;
                            break;
                        case "touchcancel":
                        case "touchend":
                        case "touchmove":
                        case "touchstart":
                            oe = TC;
                            break;
                        case ag:
                        case lg:
                        case ug:
                            oe = pC;
                            break;
                        case cg:
                            oe = RC;
                            break;
                        case "scroll":
                            oe = uC;
                            break;
                        case "wheel":
                            oe = _C;
                            break;
                        case "copy":
                        case "cut":
                        case "paste":
                            oe = gC;
                            break;
                        case "gotpointercapture":
                        case "lostpointercapture":
                        case "pointercancel":
                        case "pointerdown":
                        case "pointermove":
                        case "pointerout":
                        case "pointerover":
                        case "pointerup":
                            oe = $m
                    }
                    var me = (i & 4) !== 0
                        , Ye = !me && r === "scroll"
                        , F = me ? Q !== null ? Q + "Capture" : null : Q;
                    me = [];
                    for (var M = V, B; M !== null; ) {
                        B = M;
                        var te = B.stateNode;
                        if (B.tag === 5 && te !== null && (B = te,
                        F !== null && (te = ao(M, F),
                        te != null && me.push(ko(M, te, B)))),
                            Ye)
                            break;
                        M = M.return
                    }
                    0 < me.length && (Q = new oe(Q,fe,null,a,G),
                        Y.push({
                            event: Q,
                            listeners: me
                        }))
                }
            }
            if ((i & 7) === 0) {
                e: {
                    if (Q = r === "mouseover" || r === "pointerover",
                        oe = r === "mouseout" || r === "pointerout",
                    Q && a !== yc && (fe = a.relatedTarget || a.fromElement) && (is(fe) || fe[qn]))
                        break e;
                    if ((oe || Q) && (Q = G.window === G ? G : (Q = G.ownerDocument) ? Q.defaultView || Q.parentWindow : window,
                        oe ? (fe = a.relatedTarget || a.toElement,
                            oe = V,
                            fe = fe ? is(fe) : null,
                        fe !== null && (Ye = ss(fe),
                        fe !== Ye || fe.tag !== 5 && fe.tag !== 6) && (fe = null)) : (oe = null,
                            fe = V),
                    oe !== fe)) {
                        if (me = Um,
                            te = "onMouseLeave",
                            F = "onMouseEnter",
                            M = "mouse",
                        (r === "pointerout" || r === "pointerover") && (me = $m,
                            te = "onPointerLeave",
                            F = "onPointerEnter",
                            M = "pointer"),
                            Ye = oe == null ? Q : ei(oe),
                            B = fe == null ? Q : ei(fe),
                            Q = new me(te,M + "leave",oe,a,G),
                            Q.target = Ye,
                            Q.relatedTarget = B,
                            te = null,
                        is(G) === V && (me = new me(F,M + "enter",fe,a,G),
                            me.target = B,
                            me.relatedTarget = Ye,
                            te = me),
                            Ye = te,
                        oe && fe)
                            t: {
                                for (me = oe,
                                         F = fe,
                                         M = 0,
                                         B = me; B; B = Js(B))
                                    M++;
                                for (B = 0,
                                         te = F; te; te = Js(te))
                                    B++;
                                for (; 0 < M - B; )
                                    me = Js(me),
                                        M--;
                                for (; 0 < B - M; )
                                    F = Js(F),
                                        B--;
                                for (; M--; ) {
                                    if (me === F || F !== null && me === F.alternate)
                                        break t;
                                    me = Js(me),
                                        F = Js(F)
                                }
                                me = null
                            }
                        else
                            me = null;
                        oe !== null && gg(Y, Q, oe, me, !1),
                        fe !== null && Ye !== null && gg(Y, Ye, fe, me, !0)
                    }
                }
                e: {
                    if (Q = V ? ei(V) : window,
                        oe = Q.nodeName && Q.nodeName.toLowerCase(),
                    oe === "select" || oe === "input" && Q.type === "file")
                        var ge = IC;
                    else if (Gm(Q))
                        if (Ym)
                            ge = UC;
                        else {
                            ge = BC;
                            var ve = FC
                        }
                    else
                        (oe = Q.nodeName) && oe.toLowerCase() === "input" && (Q.type === "checkbox" || Q.type === "radio") && (ge = VC);
                    if (ge && (ge = ge(r, V))) {
                        Xm(Y, ge, a, G);
                        break e
                    }
                    ve && ve(r, Q, V),
                    r === "focusout" && (ve = Q._wrapperState) && ve.controlled && Q.type === "number" && fr(Q, "number", Q.value)
                }
                switch (ve = V ? ei(V) : window,
                    r) {
                    case "focusin":
                        (Gm(ve) || ve.contentEditable === "true") && (Xs = ve,
                            Uc = V,
                            Co = null);
                        break;
                    case "focusout":
                        Co = Uc = Xs = null;
                        break;
                    case "mousedown":
                        zc = !0;
                        break;
                    case "contextmenu":
                    case "mouseup":
                    case "dragend":
                        zc = !1,
                            ig(Y, a, G);
                        break;
                    case "selectionchange":
                        if (WC)
                            break;
                    case "keydown":
                    case "keyup":
                        ig(Y, a, G)
                }
                var we;
                if (Ic)
                    e: {
                        switch (r) {
                            case "compositionstart":
                                var Ee = "onCompositionStart";
                                break e;
                            case "compositionend":
                                Ee = "onCompositionEnd";
                                break e;
                            case "compositionupdate":
                                Ee = "onCompositionUpdate";
                                break e
                        }
                        Ee = void 0
                    }
                else
                    Gs ? Km(r, a) && (Ee = "onCompositionEnd") : r === "keydown" && a.keyCode === 229 && (Ee = "onCompositionStart");
                Ee && (Wm && a.locale !== "ko" && (Gs || Ee !== "onCompositionStart" ? Ee === "onCompositionEnd" && Gs && (we = Bm()) : (yr = G,
                    Nc = "value"in yr ? yr.value : yr.textContent,
                    Gs = !0)),
                    ve = ll(V, Ee),
                0 < ve.length && (Ee = new zm(Ee,r,null,a,G),
                    Y.push({
                        event: Ee,
                        listeners: ve
                    }),
                    we ? Ee.data = we : (we = Qm(a),
                    we !== null && (Ee.data = we)))),
                (we = OC ? LC(r, a) : MC(r, a)) && (V = ll(V, "onBeforeInput"),
                0 < V.length && (G = new zm("onBeforeInput","beforeinput",null,a,G),
                    Y.push({
                        event: G,
                        listeners: V
                    }),
                    G.data = we))
            }
            pg(Y, i)
        })
    }
    function ko(r, i, a) {
        return {
            instance: r,
            listener: i,
            currentTarget: a
        }
    }
    function ll(r, i) {
        for (var a = i + "Capture", c = []; r !== null; ) {
            var h = r
                , g = h.stateNode;
            h.tag === 5 && g !== null && (h = g,
                g = ao(r, a),
            g != null && c.unshift(ko(r, g, h)),
                g = ao(r, i),
            g != null && c.push(ko(r, g, h))),
                r = r.return
        }
        return c
    }
    function Js(r) {
        if (r === null)
            return null;
        do
            r = r.return;
        while (r && r.tag !== 5);
        return r || null
    }
    function gg(r, i, a, c, h) {
        for (var g = i._reactName, C = []; a !== null && a !== c; ) {
            var A = a
                , N = A.alternate
                , V = A.stateNode;
            if (N !== null && N === c)
                break;
            A.tag === 5 && V !== null && (A = V,
                h ? (N = ao(a, g),
                N != null && C.unshift(ko(a, N, A))) : h || (N = ao(a, g),
                N != null && C.push(ko(a, N, A)))),
                a = a.return
        }
        C.length !== 0 && r.push({
            event: i,
            listeners: C
        })
    }
    var QC = /\r\n?/g
        , GC = /\u0000|\uFFFD/g;
    function yg(r) {
        return (typeof r == "string" ? r : "" + r).replace(QC, `
`).replace(GC, "")
    }
    function ul(r, i, a) {
        if (i = yg(i),
        yg(r) !== i && a)
            throw Error(n(425))
    }
    function cl() {}
    var Qc = null
        , Gc = null;
    function Xc(r, i) {
        return r === "textarea" || r === "noscript" || typeof i.children == "string" || typeof i.children == "number" || typeof i.dangerouslySetInnerHTML == "object" && i.dangerouslySetInnerHTML !== null && i.dangerouslySetInnerHTML.__html != null
    }
    var Yc = typeof setTimeout == "function" ? setTimeout : void 0
        , XC = typeof clearTimeout == "function" ? clearTimeout : void 0
        , vg = typeof Promise == "function" ? Promise : void 0
        , YC = typeof queueMicrotask == "function" ? queueMicrotask : typeof vg < "u" ? function(r) {
            return vg.resolve(null).then(r).catch(JC)
        }
        : Yc;
    function JC(r) {
        setTimeout(function() {
            throw r
        })
    }
    function Jc(r, i) {
        var a = i
            , c = 0;
        do {
            var h = a.nextSibling;
            if (r.removeChild(a),
            h && h.nodeType === 8)
                if (a = h.data,
                a === "/$") {
                    if (c === 0) {
                        r.removeChild(h),
                            yo(i);
                        return
                    }
                    c--
                } else
                    a !== "$" && a !== "$?" && a !== "$!" || c++;
            a = h
        } while (a);
        yo(i)
    }
    function wr(r) {
        for (; r != null; r = r.nextSibling) {
            var i = r.nodeType;
            if (i === 1 || i === 3)
                break;
            if (i === 8) {
                if (i = r.data,
                i === "$" || i === "$!" || i === "$?")
                    break;
                if (i === "/$")
                    return null
            }
        }
        return r
    }
    function wg(r) {
        r = r.previousSibling;
        for (var i = 0; r; ) {
            if (r.nodeType === 8) {
                var a = r.data;
                if (a === "$" || a === "$!" || a === "$?") {
                    if (i === 0)
                        return r;
                    i--
                } else
                    a === "/$" && i++
            }
            r = r.previousSibling
        }
        return null
    }
    var Zs = Math.random().toString(36).slice(2)
        , kn = "__reactFiber$" + Zs
        , Ro = "__reactProps$" + Zs
        , qn = "__reactContainer$" + Zs
        , Zc = "__reactEvents$" + Zs
        , ZC = "__reactListeners$" + Zs
        , eP = "__reactHandles$" + Zs;
    function is(r) {
        var i = r[kn];
        if (i)
            return i;
        for (var a = r.parentNode; a; ) {
            if (i = a[qn] || a[kn]) {
                if (a = i.alternate,
                i.child !== null || a !== null && a.child !== null)
                    for (r = wg(r); r !== null; ) {
                        if (a = r[kn])
                            return a;
                        r = wg(r)
                    }
                return i
            }
            r = a,
                a = r.parentNode
        }
        return null
    }
    function Ao(r) {
        return r = r[kn] || r[qn],
            !r || r.tag !== 5 && r.tag !== 6 && r.tag !== 13 && r.tag !== 3 ? null : r
    }
    function ei(r) {
        if (r.tag === 5 || r.tag === 6)
            return r.stateNode;
        throw Error(n(33))
    }
    function dl(r) {
        return r[Ro] || null
    }
    var ed = []
        , ti = -1;
    function xr(r) {
        return {
            current: r
        }
    }
    function Ue(r) {
        0 > ti || (r.current = ed[ti],
            ed[ti] = null,
            ti--)
    }
    function Be(r, i) {
        ti++,
            ed[ti] = r.current,
            r.current = i
    }
    var Sr = {}
        , xt = xr(Sr)
        , Ot = xr(!1)
        , os = Sr;
    function ni(r, i) {
        var a = r.type.contextTypes;
        if (!a)
            return Sr;
        var c = r.stateNode;
        if (c && c.__reactInternalMemoizedUnmaskedChildContext === i)
            return c.__reactInternalMemoizedMaskedChildContext;
        var h = {}, g;
        for (g in a)
            h[g] = i[g];
        return c && (r = r.stateNode,
            r.__reactInternalMemoizedUnmaskedChildContext = i,
            r.__reactInternalMemoizedMaskedChildContext = h),
            h
    }
    function Lt(r) {
        return r = r.childContextTypes,
        r != null
    }
    function fl() {
        Ue(Ot),
            Ue(xt)
    }
    function xg(r, i, a) {
        if (xt.current !== Sr)
            throw Error(n(168));
        Be(xt, i),
            Be(Ot, a)
    }
    function Sg(r, i, a) {
        var c = r.stateNode;
        if (i = i.childContextTypes,
        typeof c.getChildContext != "function")
            return a;
        c = c.getChildContext();
        for (var h in c)
            if (!(h in i))
                throw Error(n(108, Z(r) || "Unknown", h));
        return ee({}, a, c)
    }
    function hl(r) {
        return r = (r = r.stateNode) && r.__reactInternalMemoizedMergedChildContext || Sr,
            os = xt.current,
            Be(xt, r),
            Be(Ot, Ot.current),
            !0
    }
    function bg(r, i, a) {
        var c = r.stateNode;
        if (!c)
            throw Error(n(169));
        a ? (r = Sg(r, i, os),
            c.__reactInternalMemoizedMergedChildContext = r,
            Ue(Ot),
            Ue(xt),
            Be(xt, r)) : Ue(Ot),
            Be(Ot, a)
    }
    var Kn = null
        , pl = !1
        , td = !1;
    function Eg(r) {
        Kn === null ? Kn = [r] : Kn.push(r)
    }
    function tP(r) {
        pl = !0,
            Eg(r)
    }
    function br() {
        if (!td && Kn !== null) {
            td = !0;
            var r = 0
                , i = Fe;
            try {
                var a = Kn;
                for (Fe = 1; r < a.length; r++) {
                    var c = a[r];
                    do
                        c = c(!0);
                    while (c !== null)
                }
                Kn = null,
                    pl = !1
            } catch (h) {
                throw Kn !== null && (Kn = Kn.slice(r + 1)),
                    Pm(Ec, br),
                    h
            } finally {
                Fe = i,
                    td = !1
            }
        }
        return null
    }
    var ri = []
        , si = 0
        , ml = null
        , gl = 0
        , Jt = []
        , Zt = 0
        , as = null
        , Qn = 1
        , Gn = "";
    function ls(r, i) {
        ri[si++] = gl,
            ri[si++] = ml,
            ml = r,
            gl = i
    }
    function Cg(r, i, a) {
        Jt[Zt++] = Qn,
            Jt[Zt++] = Gn,
            Jt[Zt++] = as,
            as = r;
        var c = Qn;
        r = Gn;
        var h = 32 - cn(c) - 1;
        c &= ~(1 << h),
            a += 1;
        var g = 32 - cn(i) + h;
        if (30 < g) {
            var C = h - h % 5;
            g = (c & (1 << C) - 1).toString(32),
                c >>= C,
                h -= C,
                Qn = 1 << 32 - cn(i) + h | a << h | c,
                Gn = g + r
        } else
            Qn = 1 << g | a << h | c,
                Gn = r
    }
    function nd(r) {
        r.return !== null && (ls(r, 1),
            Cg(r, 1, 0))
    }
    function rd(r) {
        for (; r === ml; )
            ml = ri[--si],
                ri[si] = null,
                gl = ri[--si],
                ri[si] = null;
        for (; r === as; )
            as = Jt[--Zt],
                Jt[Zt] = null,
                Gn = Jt[--Zt],
                Jt[Zt] = null,
                Qn = Jt[--Zt],
                Jt[Zt] = null
    }
    var Wt = null
        , Ht = null
        , $e = !1
        , fn = null;
    function Pg(r, i) {
        var a = rn(5, null, null, 0);
        a.elementType = "DELETED",
            a.stateNode = i,
            a.return = r,
            i = r.deletions,
            i === null ? (r.deletions = [a],
                r.flags |= 16) : i.push(a)
    }
    function Tg(r, i) {
        switch (r.tag) {
            case 5:
                var a = r.type;
                return i = i.nodeType !== 1 || a.toLowerCase() !== i.nodeName.toLowerCase() ? null : i,
                    i !== null ? (r.stateNode = i,
                        Wt = r,
                        Ht = wr(i.firstChild),
                        !0) : !1;
            case 6:
                return i = r.pendingProps === "" || i.nodeType !== 3 ? null : i,
                    i !== null ? (r.stateNode = i,
                        Wt = r,
                        Ht = null,
                        !0) : !1;
            case 13:
                return i = i.nodeType !== 8 ? null : i,
                    i !== null ? (a = as !== null ? {
                        id: Qn,
                        overflow: Gn
                    } : null,
                        r.memoizedState = {
                            dehydrated: i,
                            treeContext: a,
                            retryLane: 1073741824
                        },
                        a = rn(18, null, null, 0),
                        a.stateNode = i,
                        a.return = r,
                        r.child = a,
                        Wt = r,
                        Ht = null,
                        !0) : !1;
            default:
                return !1
        }
    }
    function sd(r) {
        return (r.mode & 1) !== 0 && (r.flags & 128) === 0
    }
    function id(r) {
        if ($e) {
            var i = Ht;
            if (i) {
                var a = i;
                if (!Tg(r, i)) {
                    if (sd(r))
                        throw Error(n(418));
                    i = wr(a.nextSibling);
                    var c = Wt;
                    i && Tg(r, i) ? Pg(c, a) : (r.flags = r.flags & -4097 | 2,
                        $e = !1,
                        Wt = r)
                }
            } else {
                if (sd(r))
                    throw Error(n(418));
                r.flags = r.flags & -4097 | 2,
                    $e = !1,
                    Wt = r
            }
        }
    }
    function kg(r) {
        for (r = r.return; r !== null && r.tag !== 5 && r.tag !== 3 && r.tag !== 13; )
            r = r.return;
        Wt = r
    }
    function yl(r) {
        if (r !== Wt)
            return !1;
        if (!$e)
            return kg(r),
                $e = !0,
                !1;
        var i;
        if ((i = r.tag !== 3) && !(i = r.tag !== 5) && (i = r.type,
            i = i !== "head" && i !== "body" && !Xc(r.type, r.memoizedProps)),
        i && (i = Ht)) {
            if (sd(r))
                throw Rg(),
                    Error(n(418));
            for (; i; )
                Pg(r, i),
                    i = wr(i.nextSibling)
        }
        if (kg(r),
        r.tag === 13) {
            if (r = r.memoizedState,
                r = r !== null ? r.dehydrated : null,
                !r)
                throw Error(n(317));
            e: {
                for (r = r.nextSibling,
                         i = 0; r; ) {
                    if (r.nodeType === 8) {
                        var a = r.data;
                        if (a === "/$") {
                            if (i === 0) {
                                Ht = wr(r.nextSibling);
                                break e
                            }
                            i--
                        } else
                            a !== "$" && a !== "$!" && a !== "$?" || i++
                    }
                    r = r.nextSibling
                }
                Ht = null
            }
        } else
            Ht = Wt ? wr(r.stateNode.nextSibling) : null;
        return !0
    }
    function Rg() {
        for (var r = Ht; r; )
            r = wr(r.nextSibling)
    }
    function ii() {
        Ht = Wt = null,
            $e = !1
    }
    function od(r) {
        fn === null ? fn = [r] : fn.push(r)
    }
    var nP = _.ReactCurrentBatchConfig;
    function _o(r, i, a) {
        if (r = a.ref,
        r !== null && typeof r != "function" && typeof r != "object") {
            if (a._owner) {
                if (a = a._owner,
                    a) {
                    if (a.tag !== 1)
                        throw Error(n(309));
                    var c = a.stateNode
                }
                if (!c)
                    throw Error(n(147, r));
                var h = c
                    , g = "" + r;
                return i !== null && i.ref !== null && typeof i.ref == "function" && i.ref._stringRef === g ? i.ref : (i = function(C) {
                    var A = h.refs;
                    C === null ? delete A[g] : A[g] = C
                }
                    ,
                    i._stringRef = g,
                    i)
            }
            if (typeof r != "string")
                throw Error(n(284));
            if (!a._owner)
                throw Error(n(290, r))
        }
        return r
    }
    function vl(r, i) {
        throw r = Object.prototype.toString.call(i),
            Error(n(31, r === "[object Object]" ? "object with keys {" + Object.keys(i).join(", ") + "}" : r))
    }
    function Ag(r) {
        var i = r._init;
        return i(r._payload)
    }
    function _g(r) {
        function i(F, M) {
            if (r) {
                var B = F.deletions;
                B === null ? (F.deletions = [M],
                    F.flags |= 16) : B.push(M)
            }
        }
        function a(F, M) {
            if (!r)
                return null;
            for (; M !== null; )
                i(F, M),
                    M = M.sibling;
            return null
        }
        function c(F, M) {
            for (F = new Map; M !== null; )
                M.key !== null ? F.set(M.key, M) : F.set(M.index, M),
                    M = M.sibling;
            return F
        }
        function h(F, M) {
            return F = _r(F, M),
                F.index = 0,
                F.sibling = null,
                F
        }
        function g(F, M, B) {
            return F.index = B,
                r ? (B = F.alternate,
                    B !== null ? (B = B.index,
                        B < M ? (F.flags |= 2,
                            M) : B) : (F.flags |= 2,
                        M)) : (F.flags |= 1048576,
                    M)
        }
        function C(F) {
            return r && F.alternate === null && (F.flags |= 2),
                F
        }
        function A(F, M, B, te) {
            return M === null || M.tag !== 6 ? (M = Yd(B, F.mode, te),
                M.return = F,
                M) : (M = h(M, B),
                M.return = F,
                M)
        }
        function N(F, M, B, te) {
            var ge = B.type;
            return ge === $ ? G(F, M, B.props.children, te, B.key) : M !== null && (M.elementType === ge || typeof ge == "object" && ge !== null && ge.$$typeof === ne && Ag(ge) === M.type) ? (te = h(M, B.props),
                te.ref = _o(F, M, B),
                te.return = F,
                te) : (te = zl(B.type, B.key, B.props, null, F.mode, te),
                te.ref = _o(F, M, B),
                te.return = F,
                te)
        }
        function V(F, M, B, te) {
            return M === null || M.tag !== 4 || M.stateNode.containerInfo !== B.containerInfo || M.stateNode.implementation !== B.implementation ? (M = Jd(B, F.mode, te),
                M.return = F,
                M) : (M = h(M, B.children || []),
                M.return = F,
                M)
        }
        function G(F, M, B, te, ge) {
            return M === null || M.tag !== 7 ? (M = gs(B, F.mode, te, ge),
                M.return = F,
                M) : (M = h(M, B),
                M.return = F,
                M)
        }
        function Y(F, M, B) {
            if (typeof M == "string" && M !== "" || typeof M == "number")
                return M = Yd("" + M, F.mode, B),
                    M.return = F,
                    M;
            if (typeof M == "object" && M !== null) {
                switch (M.$$typeof) {
                    case D:
                        return B = zl(M.type, M.key, M.props, null, F.mode, B),
                            B.ref = _o(F, null, M),
                            B.return = F,
                            B;
                    case H:
                        return M = Jd(M, F.mode, B),
                            M.return = F,
                            M;
                    case ne:
                        var te = M._init;
                        return Y(F, te(M._payload), B)
                }
                if (so(M) || se(M))
                    return M = gs(M, F.mode, B, null),
                        M.return = F,
                        M;
                vl(F, M)
            }
            return null
        }
        function Q(F, M, B, te) {
            var ge = M !== null ? M.key : null;
            if (typeof B == "string" && B !== "" || typeof B == "number")
                return ge !== null ? null : A(F, M, "" + B, te);
            if (typeof B == "object" && B !== null) {
                switch (B.$$typeof) {
                    case D:
                        return B.key === ge ? N(F, M, B, te) : null;
                    case H:
                        return B.key === ge ? V(F, M, B, te) : null;
                    case ne:
                        return ge = B._init,
                            Q(F, M, ge(B._payload), te)
                }
                if (so(B) || se(B))
                    return ge !== null ? null : G(F, M, B, te, null);
                vl(F, B)
            }
            return null
        }
        function oe(F, M, B, te, ge) {
            if (typeof te == "string" && te !== "" || typeof te == "number")
                return F = F.get(B) || null,
                    A(M, F, "" + te, ge);
            if (typeof te == "object" && te !== null) {
                switch (te.$$typeof) {
                    case D:
                        return F = F.get(te.key === null ? B : te.key) || null,
                            N(M, F, te, ge);
                    case H:
                        return F = F.get(te.key === null ? B : te.key) || null,
                            V(M, F, te, ge);
                    case ne:
                        var ve = te._init;
                        return oe(F, M, B, ve(te._payload), ge)
                }
                if (so(te) || se(te))
                    return F = F.get(B) || null,
                        G(M, F, te, ge, null);
                vl(M, te)
            }
            return null
        }
        function fe(F, M, B, te) {
            for (var ge = null, ve = null, we = M, Ee = M = 0, ft = null; we !== null && Ee < B.length; Ee++) {
                we.index > Ee ? (ft = we,
                    we = null) : ft = we.sibling;
                var De = Q(F, we, B[Ee], te);
                if (De === null) {
                    we === null && (we = ft);
                    break
                }
                r && we && De.alternate === null && i(F, we),
                    M = g(De, M, Ee),
                    ve === null ? ge = De : ve.sibling = De,
                    ve = De,
                    we = ft
            }
            if (Ee === B.length)
                return a(F, we),
                $e && ls(F, Ee),
                    ge;
            if (we === null) {
                for (; Ee < B.length; Ee++)
                    we = Y(F, B[Ee], te),
                    we !== null && (M = g(we, M, Ee),
                        ve === null ? ge = we : ve.sibling = we,
                        ve = we);
                return $e && ls(F, Ee),
                    ge
            }
            for (we = c(F, we); Ee < B.length; Ee++)
                ft = oe(we, F, Ee, B[Ee], te),
                ft !== null && (r && ft.alternate !== null && we.delete(ft.key === null ? Ee : ft.key),
                    M = g(ft, M, Ee),
                    ve === null ? ge = ft : ve.sibling = ft,
                    ve = ft);
            return r && we.forEach(function(Nr) {
                return i(F, Nr)
            }),
            $e && ls(F, Ee),
                ge
        }
        function me(F, M, B, te) {
            var ge = se(B);
            if (typeof ge != "function")
                throw Error(n(150));
            if (B = ge.call(B),
            B == null)
                throw Error(n(151));
            for (var ve = ge = null, we = M, Ee = M = 0, ft = null, De = B.next(); we !== null && !De.done; Ee++,
                De = B.next()) {
                we.index > Ee ? (ft = we,
                    we = null) : ft = we.sibling;
                var Nr = Q(F, we, De.value, te);
                if (Nr === null) {
                    we === null && (we = ft);
                    break
                }
                r && we && Nr.alternate === null && i(F, we),
                    M = g(Nr, M, Ee),
                    ve === null ? ge = Nr : ve.sibling = Nr,
                    ve = Nr,
                    we = ft
            }
            if (De.done)
                return a(F, we),
                $e && ls(F, Ee),
                    ge;
            if (we === null) {
                for (; !De.done; Ee++,
                    De = B.next())
                    De = Y(F, De.value, te),
                    De !== null && (M = g(De, M, Ee),
                        ve === null ? ge = De : ve.sibling = De,
                        ve = De);
                return $e && ls(F, Ee),
                    ge
            }
            for (we = c(F, we); !De.done; Ee++,
                De = B.next())
                De = oe(we, F, Ee, De.value, te),
                De !== null && (r && De.alternate !== null && we.delete(De.key === null ? Ee : De.key),
                    M = g(De, M, Ee),
                    ve === null ? ge = De : ve.sibling = De,
                    ve = De);
            return r && we.forEach(function(jP) {
                return i(F, jP)
            }),
            $e && ls(F, Ee),
                ge
        }
        function Ye(F, M, B, te) {
            if (typeof B == "object" && B !== null && B.type === $ && B.key === null && (B = B.props.children),
            typeof B == "object" && B !== null) {
                switch (B.$$typeof) {
                    case D:
                        e: {
                            for (var ge = B.key, ve = M; ve !== null; ) {
                                if (ve.key === ge) {
                                    if (ge = B.type,
                                    ge === $) {
                                        if (ve.tag === 7) {
                                            a(F, ve.sibling),
                                                M = h(ve, B.props.children),
                                                M.return = F,
                                                F = M;
                                            break e
                                        }
                                    } else if (ve.elementType === ge || typeof ge == "object" && ge !== null && ge.$$typeof === ne && Ag(ge) === ve.type) {
                                        a(F, ve.sibling),
                                            M = h(ve, B.props),
                                            M.ref = _o(F, ve, B),
                                            M.return = F,
                                            F = M;
                                        break e
                                    }
                                    a(F, ve);
                                    break
                                } else
                                    i(F, ve);
                                ve = ve.sibling
                            }
                            B.type === $ ? (M = gs(B.props.children, F.mode, te, B.key),
                                M.return = F,
                                F = M) : (te = zl(B.type, B.key, B.props, null, F.mode, te),
                                te.ref = _o(F, M, B),
                                te.return = F,
                                F = te)
                        }
                        return C(F);
                    case H:
                        e: {
                            for (ve = B.key; M !== null; ) {
                                if (M.key === ve)
                                    if (M.tag === 4 && M.stateNode.containerInfo === B.containerInfo && M.stateNode.implementation === B.implementation) {
                                        a(F, M.sibling),
                                            M = h(M, B.children || []),
                                            M.return = F,
                                            F = M;
                                        break e
                                    } else {
                                        a(F, M);
                                        break
                                    }
                                else
                                    i(F, M);
                                M = M.sibling
                            }
                            M = Jd(B, F.mode, te),
                                M.return = F,
                                F = M
                        }
                        return C(F);
                    case ne:
                        return ve = B._init,
                            Ye(F, M, ve(B._payload), te)
                }
                if (so(B))
                    return fe(F, M, B, te);
                if (se(B))
                    return me(F, M, B, te);
                vl(F, B)
            }
            return typeof B == "string" && B !== "" || typeof B == "number" ? (B = "" + B,
                M !== null && M.tag === 6 ? (a(F, M.sibling),
                    M = h(M, B),
                    M.return = F,
                    F = M) : (a(F, M),
                    M = Yd(B, F.mode, te),
                    M.return = F,
                    F = M),
                C(F)) : a(F, M)
        }
        return Ye
    }
    var oi = _g(!0)
        , Ng = _g(!1)
        , wl = xr(null)
        , xl = null
        , ai = null
        , ad = null;
    function ld() {
        ad = ai = xl = null
    }
    function ud(r) {
        var i = wl.current;
        Ue(wl),
            r._currentValue = i
    }
    function cd(r, i, a) {
        for (; r !== null; ) {
            var c = r.alternate;
            if ((r.childLanes & i) !== i ? (r.childLanes |= i,
            c !== null && (c.childLanes |= i)) : c !== null && (c.childLanes & i) !== i && (c.childLanes |= i),
            r === a)
                break;
            r = r.return
        }
    }
    function li(r, i) {
        xl = r,
            ad = ai = null,
            r = r.dependencies,
        r !== null && r.firstContext !== null && ((r.lanes & i) !== 0 && (Mt = !0),
            r.firstContext = null)
    }
    function en(r) {
        var i = r._currentValue;
        if (ad !== r)
            if (r = {
                context: r,
                memoizedValue: i,
                next: null
            },
            ai === null) {
                if (xl === null)
                    throw Error(n(308));
                ai = r,
                    xl.dependencies = {
                        lanes: 0,
                        firstContext: r
                    }
            } else
                ai = ai.next = r;
        return i
    }
    var us = null;
    function dd(r) {
        us === null ? us = [r] : us.push(r)
    }
    function Og(r, i, a, c) {
        var h = i.interleaved;
        return h === null ? (a.next = a,
            dd(i)) : (a.next = h.next,
            h.next = a),
            i.interleaved = a,
            Xn(r, c)
    }
    function Xn(r, i) {
        r.lanes |= i;
        var a = r.alternate;
        for (a !== null && (a.lanes |= i),
                 a = r,
                 r = r.return; r !== null; )
            r.childLanes |= i,
                a = r.alternate,
            a !== null && (a.childLanes |= i),
                a = r,
                r = r.return;
        return a.tag === 3 ? a.stateNode : null
    }
    var Er = !1;
    function fd(r) {
        r.updateQueue = {
            baseState: r.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
                pending: null,
                interleaved: null,
                lanes: 0
            },
            effects: null
        }
    }
    function Lg(r, i) {
        r = r.updateQueue,
        i.updateQueue === r && (i.updateQueue = {
            baseState: r.baseState,
            firstBaseUpdate: r.firstBaseUpdate,
            lastBaseUpdate: r.lastBaseUpdate,
            shared: r.shared,
            effects: r.effects
        })
    }
    function Yn(r, i) {
        return {
            eventTime: r,
            lane: i,
            tag: 0,
            payload: null,
            callback: null,
            next: null
        }
    }
    function Cr(r, i, a) {
        var c = r.updateQueue;
        if (c === null)
            return null;
        if (c = c.shared,
        (je & 2) !== 0) {
            var h = c.pending;
            return h === null ? i.next = i : (i.next = h.next,
                h.next = i),
                c.pending = i,
                Xn(r, a)
        }
        return h = c.interleaved,
            h === null ? (i.next = i,
                dd(c)) : (i.next = h.next,
                h.next = i),
            c.interleaved = i,
            Xn(r, a)
    }
    function Sl(r, i, a) {
        if (i = i.updateQueue,
        i !== null && (i = i.shared,
        (a & 4194240) !== 0)) {
            var c = i.lanes;
            c &= r.pendingLanes,
                a |= c,
                i.lanes = a,
                Tc(r, a)
        }
    }
    function Mg(r, i) {
        var a = r.updateQueue
            , c = r.alternate;
        if (c !== null && (c = c.updateQueue,
        a === c)) {
            var h = null
                , g = null;
            if (a = a.firstBaseUpdate,
            a !== null) {
                do {
                    var C = {
                        eventTime: a.eventTime,
                        lane: a.lane,
                        tag: a.tag,
                        payload: a.payload,
                        callback: a.callback,
                        next: null
                    };
                    g === null ? h = g = C : g = g.next = C,
                        a = a.next
                } while (a !== null);
                g === null ? h = g = i : g = g.next = i
            } else
                h = g = i;
            a = {
                baseState: c.baseState,
                firstBaseUpdate: h,
                lastBaseUpdate: g,
                shared: c.shared,
                effects: c.effects
            },
                r.updateQueue = a;
            return
        }
        r = a.lastBaseUpdate,
            r === null ? a.firstBaseUpdate = i : r.next = i,
            a.lastBaseUpdate = i
    }
    function bl(r, i, a, c) {
        var h = r.updateQueue;
        Er = !1;
        var g = h.firstBaseUpdate
            , C = h.lastBaseUpdate
            , A = h.shared.pending;
        if (A !== null) {
            h.shared.pending = null;
            var N = A
                , V = N.next;
            N.next = null,
                C === null ? g = V : C.next = V,
                C = N;
            var G = r.alternate;
            G !== null && (G = G.updateQueue,
                A = G.lastBaseUpdate,
            A !== C && (A === null ? G.firstBaseUpdate = V : A.next = V,
                G.lastBaseUpdate = N))
        }
        if (g !== null) {
            var Y = h.baseState;
            C = 0,
                G = V = N = null,
                A = g;
            do {
                var Q = A.lane
                    , oe = A.eventTime;
                if ((c & Q) === Q) {
                    G !== null && (G = G.next = {
                        eventTime: oe,
                        lane: 0,
                        tag: A.tag,
                        payload: A.payload,
                        callback: A.callback,
                        next: null
                    });
                    e: {
                        var fe = r
                            , me = A;
                        switch (Q = i,
                            oe = a,
                            me.tag) {
                            case 1:
                                if (fe = me.payload,
                                typeof fe == "function") {
                                    Y = fe.call(oe, Y, Q);
                                    break e
                                }
                                Y = fe;
                                break e;
                            case 3:
                                fe.flags = fe.flags & -65537 | 128;
                            case 0:
                                if (fe = me.payload,
                                    Q = typeof fe == "function" ? fe.call(oe, Y, Q) : fe,
                                Q == null)
                                    break e;
                                Y = ee({}, Y, Q);
                                break e;
                            case 2:
                                Er = !0
                        }
                    }
                    A.callback !== null && A.lane !== 0 && (r.flags |= 64,
                        Q = h.effects,
                        Q === null ? h.effects = [A] : Q.push(A))
                } else
                    oe = {
                        eventTime: oe,
                        lane: Q,
                        tag: A.tag,
                        payload: A.payload,
                        callback: A.callback,
                        next: null
                    },
                        G === null ? (V = G = oe,
                            N = Y) : G = G.next = oe,
                        C |= Q;
                if (A = A.next,
                A === null) {
                    if (A = h.shared.pending,
                    A === null)
                        break;
                    Q = A,
                        A = Q.next,
                        Q.next = null,
                        h.lastBaseUpdate = Q,
                        h.shared.pending = null
                }
            } while (!0);
            if (G === null && (N = Y),
                h.baseState = N,
                h.firstBaseUpdate = V,
                h.lastBaseUpdate = G,
                i = h.shared.interleaved,
            i !== null) {
                h = i;
                do
                    C |= h.lane,
                        h = h.next;
                while (h !== i)
            } else
                g === null && (h.shared.lanes = 0);
            fs |= C,
                r.lanes = C,
                r.memoizedState = Y
        }
    }
    function jg(r, i, a) {
        if (r = i.effects,
            i.effects = null,
        r !== null)
            for (i = 0; i < r.length; i++) {
                var c = r[i]
                    , h = c.callback;
                if (h !== null) {
                    if (c.callback = null,
                        c = a,
                    typeof h != "function")
                        throw Error(n(191, h));
                    h.call(c)
                }
            }
    }
    var No = {}
        , Rn = xr(No)
        , Oo = xr(No)
        , Lo = xr(No);
    function cs(r) {
        if (r === No)
            throw Error(n(174));
        return r
    }
    function hd(r, i) {
        switch (Be(Lo, i),
            Be(Oo, r),
            Be(Rn, No),
            r = i.nodeType,
            r) {
            case 9:
            case 11:
                i = (i = i.documentElement) ? i.namespaceURI : pc(null, "");
                break;
            default:
                r = r === 8 ? i.parentNode : i,
                    i = r.namespaceURI || null,
                    r = r.tagName,
                    i = pc(i, r)
        }
        Ue(Rn),
            Be(Rn, i)
    }
    function ui() {
        Ue(Rn),
            Ue(Oo),
            Ue(Lo)
    }
    function Dg(r) {
        cs(Lo.current);
        var i = cs(Rn.current)
            , a = pc(i, r.type);
        i !== a && (Be(Oo, r),
            Be(Rn, a))
    }
    function pd(r) {
        Oo.current === r && (Ue(Rn),
            Ue(Oo))
    }
    var We = xr(0);
    function El(r) {
        for (var i = r; i !== null; ) {
            if (i.tag === 13) {
                var a = i.memoizedState;
                if (a !== null && (a = a.dehydrated,
                a === null || a.data === "$?" || a.data === "$!"))
                    return i
            } else if (i.tag === 19 && i.memoizedProps.revealOrder !== void 0) {
                if ((i.flags & 128) !== 0)
                    return i
            } else if (i.child !== null) {
                i.child.return = i,
                    i = i.child;
                continue
            }
            if (i === r)
                break;
            for (; i.sibling === null; ) {
                if (i.return === null || i.return === r)
                    return null;
                i = i.return
            }
            i.sibling.return = i.return,
                i = i.sibling
        }
        return null
    }
    var md = [];
    function gd() {
        for (var r = 0; r < md.length; r++)
            md[r]._workInProgressVersionPrimary = null;
        md.length = 0
    }
    var Cl = _.ReactCurrentDispatcher
        , yd = _.ReactCurrentBatchConfig
        , ds = 0
        , He = null
        , ot = null
        , ct = null
        , Pl = !1
        , Mo = !1
        , jo = 0
        , rP = 0;
    function St() {
        throw Error(n(321))
    }
    function vd(r, i) {
        if (i === null)
            return !1;
        for (var a = 0; a < i.length && a < r.length; a++)
            if (!dn(r[a], i[a]))
                return !1;
        return !0
    }
    function wd(r, i, a, c, h, g) {
        if (ds = g,
            He = i,
            i.memoizedState = null,
            i.updateQueue = null,
            i.lanes = 0,
            Cl.current = r === null || r.memoizedState === null ? aP : lP,
            r = a(c, h),
            Mo) {
            g = 0;
            do {
                if (Mo = !1,
                    jo = 0,
                25 <= g)
                    throw Error(n(301));
                g += 1,
                    ct = ot = null,
                    i.updateQueue = null,
                    Cl.current = uP,
                    r = a(c, h)
            } while (Mo)
        }
        if (Cl.current = Rl,
            i = ot !== null && ot.next !== null,
            ds = 0,
            ct = ot = He = null,
            Pl = !1,
            i)
            throw Error(n(300));
        return r
    }
    function xd() {
        var r = jo !== 0;
        return jo = 0,
            r
    }
    function An() {
        var r = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
        };
        return ct === null ? He.memoizedState = ct = r : ct = ct.next = r,
            ct
    }
    function tn() {
        if (ot === null) {
            var r = He.alternate;
            r = r !== null ? r.memoizedState : null
        } else
            r = ot.next;
        var i = ct === null ? He.memoizedState : ct.next;
        if (i !== null)
            ct = i,
                ot = r;
        else {
            if (r === null)
                throw Error(n(310));
            ot = r,
                r = {
                    memoizedState: ot.memoizedState,
                    baseState: ot.baseState,
                    baseQueue: ot.baseQueue,
                    queue: ot.queue,
                    next: null
                },
                ct === null ? He.memoizedState = ct = r : ct = ct.next = r
        }
        return ct
    }
    function Do(r, i) {
        return typeof i == "function" ? i(r) : i
    }
    function Sd(r) {
        var i = tn()
            , a = i.queue;
        if (a === null)
            throw Error(n(311));
        a.lastRenderedReducer = r;
        var c = ot
            , h = c.baseQueue
            , g = a.pending;
        if (g !== null) {
            if (h !== null) {
                var C = h.next;
                h.next = g.next,
                    g.next = C
            }
            c.baseQueue = h = g,
                a.pending = null
        }
        if (h !== null) {
            g = h.next,
                c = c.baseState;
            var A = C = null
                , N = null
                , V = g;
            do {
                var G = V.lane;
                if ((ds & G) === G)
                    N !== null && (N = N.next = {
                        lane: 0,
                        action: V.action,
                        hasEagerState: V.hasEagerState,
                        eagerState: V.eagerState,
                        next: null
                    }),
                        c = V.hasEagerState ? V.eagerState : r(c, V.action);
                else {
                    var Y = {
                        lane: G,
                        action: V.action,
                        hasEagerState: V.hasEagerState,
                        eagerState: V.eagerState,
                        next: null
                    };
                    N === null ? (A = N = Y,
                        C = c) : N = N.next = Y,
                        He.lanes |= G,
                        fs |= G
                }
                V = V.next
            } while (V !== null && V !== g);
            N === null ? C = c : N.next = A,
            dn(c, i.memoizedState) || (Mt = !0),
                i.memoizedState = c,
                i.baseState = C,
                i.baseQueue = N,
                a.lastRenderedState = c
        }
        if (r = a.interleaved,
        r !== null) {
            h = r;
            do
                g = h.lane,
                    He.lanes |= g,
                    fs |= g,
                    h = h.next;
            while (h !== r)
        } else
            h === null && (a.lanes = 0);
        return [i.memoizedState, a.dispatch]
    }
    function bd(r) {
        var i = tn()
            , a = i.queue;
        if (a === null)
            throw Error(n(311));
        a.lastRenderedReducer = r;
        var c = a.dispatch
            , h = a.pending
            , g = i.memoizedState;
        if (h !== null) {
            a.pending = null;
            var C = h = h.next;
            do
                g = r(g, C.action),
                    C = C.next;
            while (C !== h);
            dn(g, i.memoizedState) || (Mt = !0),
                i.memoizedState = g,
            i.baseQueue === null && (i.baseState = g),
                a.lastRenderedState = g
        }
        return [g, c]
    }
    function Ig() {}
    function Fg(r, i) {
        var a = He
            , c = tn()
            , h = i()
            , g = !dn(c.memoizedState, h);
        if (g && (c.memoizedState = h,
            Mt = !0),
            c = c.queue,
            Ed(Ug.bind(null, a, c, r), [r]),
        c.getSnapshot !== i || g || ct !== null && ct.memoizedState.tag & 1) {
            if (a.flags |= 2048,
                Io(9, Vg.bind(null, a, c, h, i), void 0, null),
            dt === null)
                throw Error(n(349));
            (ds & 30) !== 0 || Bg(a, i, h)
        }
        return h
    }
    function Bg(r, i, a) {
        r.flags |= 16384,
            r = {
                getSnapshot: i,
                value: a
            },
            i = He.updateQueue,
            i === null ? (i = {
                lastEffect: null,
                stores: null
            },
                He.updateQueue = i,
                i.stores = [r]) : (a = i.stores,
                a === null ? i.stores = [r] : a.push(r))
    }
    function Vg(r, i, a, c) {
        i.value = a,
            i.getSnapshot = c,
        zg(i) && $g(r)
    }
    function Ug(r, i, a) {
        return a(function() {
            zg(i) && $g(r)
        })
    }
    function zg(r) {
        var i = r.getSnapshot;
        r = r.value;
        try {
            var a = i();
            return !dn(r, a)
        } catch {
            return !0
        }
    }
    function $g(r) {
        var i = Xn(r, 1);
        i !== null && gn(i, r, 1, -1)
    }
    function Wg(r) {
        var i = An();
        return typeof r == "function" && (r = r()),
            i.memoizedState = i.baseState = r,
            r = {
                pending: null,
                interleaved: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: Do,
                lastRenderedState: r
            },
            i.queue = r,
            r = r.dispatch = oP.bind(null, He, r),
            [i.memoizedState, r]
    }
    function Io(r, i, a, c) {
        return r = {
            tag: r,
            create: i,
            destroy: a,
            deps: c,
            next: null
        },
            i = He.updateQueue,
            i === null ? (i = {
                lastEffect: null,
                stores: null
            },
                He.updateQueue = i,
                i.lastEffect = r.next = r) : (a = i.lastEffect,
                a === null ? i.lastEffect = r.next = r : (c = a.next,
                    a.next = r,
                    r.next = c,
                    i.lastEffect = r)),
            r
    }
    function Hg() {
        return tn().memoizedState
    }
    function Tl(r, i, a, c) {
        var h = An();
        He.flags |= r,
            h.memoizedState = Io(1 | i, a, void 0, c === void 0 ? null : c)
    }
    function kl(r, i, a, c) {
        var h = tn();
        c = c === void 0 ? null : c;
        var g = void 0;
        if (ot !== null) {
            var C = ot.memoizedState;
            if (g = C.destroy,
            c !== null && vd(c, C.deps)) {
                h.memoizedState = Io(i, a, g, c);
                return
            }
        }
        He.flags |= r,
            h.memoizedState = Io(1 | i, a, g, c)
    }
    function qg(r, i) {
        return Tl(8390656, 8, r, i)
    }
    function Ed(r, i) {
        return kl(2048, 8, r, i)
    }
    function Kg(r, i) {
        return kl(4, 2, r, i)
    }
    function Qg(r, i) {
        return kl(4, 4, r, i)
    }
    function Gg(r, i) {
        if (typeof i == "function")
            return r = r(),
                i(r),
                function() {
                    i(null)
                }
                ;
        if (i != null)
            return r = r(),
                i.current = r,
                function() {
                    i.current = null
                }
    }
    function Xg(r, i, a) {
        return a = a != null ? a.concat([r]) : null,
            kl(4, 4, Gg.bind(null, i, r), a)
    }
    function Cd() {}
    function Yg(r, i) {
        var a = tn();
        i = i === void 0 ? null : i;
        var c = a.memoizedState;
        return c !== null && i !== null && vd(i, c[1]) ? c[0] : (a.memoizedState = [r, i],
            r)
    }
    function Jg(r, i) {
        var a = tn();
        i = i === void 0 ? null : i;
        var c = a.memoizedState;
        return c !== null && i !== null && vd(i, c[1]) ? c[0] : (r = r(),
            a.memoizedState = [r, i],
            r)
    }
    function Zg(r, i, a) {
        return (ds & 21) === 0 ? (r.baseState && (r.baseState = !1,
            Mt = !0),
            r.memoizedState = a) : (dn(a, i) || (a = Am(),
            He.lanes |= a,
            fs |= a,
            r.baseState = !0),
            i)
    }
    function sP(r, i) {
        var a = Fe;
        Fe = a !== 0 && 4 > a ? a : 4,
            r(!0);
        var c = yd.transition;
        yd.transition = {};
        try {
            r(!1),
                i()
        } finally {
            Fe = a,
                yd.transition = c
        }
    }
    function ey() {
        return tn().memoizedState
    }
    function iP(r, i, a) {
        var c = Rr(r);
        if (a = {
            lane: c,
            action: a,
            hasEagerState: !1,
            eagerState: null,
            next: null
        },
            ty(r))
            ny(i, a);
        else if (a = Og(r, i, a, c),
        a !== null) {
            var h = Rt();
            gn(a, r, c, h),
                ry(a, i, c)
        }
    }
    function oP(r, i, a) {
        var c = Rr(r)
            , h = {
            lane: c,
            action: a,
            hasEagerState: !1,
            eagerState: null,
            next: null
        };
        if (ty(r))
            ny(i, h);
        else {
            var g = r.alternate;
            if (r.lanes === 0 && (g === null || g.lanes === 0) && (g = i.lastRenderedReducer,
            g !== null))
                try {
                    var C = i.lastRenderedState
                        , A = g(C, a);
                    if (h.hasEagerState = !0,
                        h.eagerState = A,
                        dn(A, C)) {
                        var N = i.interleaved;
                        N === null ? (h.next = h,
                            dd(i)) : (h.next = N.next,
                            N.next = h),
                            i.interleaved = h;
                        return
                    }
                } catch {} finally {}
            a = Og(r, i, h, c),
            a !== null && (h = Rt(),
                gn(a, r, c, h),
                ry(a, i, c))
        }
    }
    function ty(r) {
        var i = r.alternate;
        return r === He || i !== null && i === He
    }
    function ny(r, i) {
        Mo = Pl = !0;
        var a = r.pending;
        a === null ? i.next = i : (i.next = a.next,
            a.next = i),
            r.pending = i
    }
    function ry(r, i, a) {
        if ((a & 4194240) !== 0) {
            var c = i.lanes;
            c &= r.pendingLanes,
                a |= c,
                i.lanes = a,
                Tc(r, a)
        }
    }
    var Rl = {
        readContext: en,
        useCallback: St,
        useContext: St,
        useEffect: St,
        useImperativeHandle: St,
        useInsertionEffect: St,
        useLayoutEffect: St,
        useMemo: St,
        useReducer: St,
        useRef: St,
        useState: St,
        useDebugValue: St,
        useDeferredValue: St,
        useTransition: St,
        useMutableSource: St,
        useSyncExternalStore: St,
        useId: St,
        unstable_isNewReconciler: !1
    }
        , aP = {
        readContext: en,
        useCallback: function(r, i) {
            return An().memoizedState = [r, i === void 0 ? null : i],
                r
        },
        useContext: en,
        useEffect: qg,
        useImperativeHandle: function(r, i, a) {
            return a = a != null ? a.concat([r]) : null,
                Tl(4194308, 4, Gg.bind(null, i, r), a)
        },
        useLayoutEffect: function(r, i) {
            return Tl(4194308, 4, r, i)
        },
        useInsertionEffect: function(r, i) {
            return Tl(4, 2, r, i)
        },
        useMemo: function(r, i) {
            var a = An();
            return i = i === void 0 ? null : i,
                r = r(),
                a.memoizedState = [r, i],
                r
        },
        useReducer: function(r, i, a) {
            var c = An();
            return i = a !== void 0 ? a(i) : i,
                c.memoizedState = c.baseState = i,
                r = {
                    pending: null,
                    interleaved: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: r,
                    lastRenderedState: i
                },
                c.queue = r,
                r = r.dispatch = iP.bind(null, He, r),
                [c.memoizedState, r]
        },
        useRef: function(r) {
            var i = An();
            return r = {
                current: r
            },
                i.memoizedState = r
        },
        useState: Wg,
        useDebugValue: Cd,
        useDeferredValue: function(r) {
            return An().memoizedState = r
        },
        useTransition: function() {
            var r = Wg(!1)
                , i = r[0];
            return r = sP.bind(null, r[1]),
                An().memoizedState = r,
                [i, r]
        },
        useMutableSource: function() {},
        useSyncExternalStore: function(r, i, a) {
            var c = He
                , h = An();
            if ($e) {
                if (a === void 0)
                    throw Error(n(407));
                a = a()
            } else {
                if (a = i(),
                dt === null)
                    throw Error(n(349));
                (ds & 30) !== 0 || Bg(c, i, a)
            }
            h.memoizedState = a;
            var g = {
                value: a,
                getSnapshot: i
            };
            return h.queue = g,
                qg(Ug.bind(null, c, g, r), [r]),
                c.flags |= 2048,
                Io(9, Vg.bind(null, c, g, a, i), void 0, null),
                a
        },
        useId: function() {
            var r = An()
                , i = dt.identifierPrefix;
            if ($e) {
                var a = Gn
                    , c = Qn;
                a = (c & ~(1 << 32 - cn(c) - 1)).toString(32) + a,
                    i = ":" + i + "R" + a,
                    a = jo++,
                0 < a && (i += "H" + a.toString(32)),
                    i += ":"
            } else
                a = rP++,
                    i = ":" + i + "r" + a.toString(32) + ":";
            return r.memoizedState = i
        },
        unstable_isNewReconciler: !1
    }
        , lP = {
        readContext: en,
        useCallback: Yg,
        useContext: en,
        useEffect: Ed,
        useImperativeHandle: Xg,
        useInsertionEffect: Kg,
        useLayoutEffect: Qg,
        useMemo: Jg,
        useReducer: Sd,
        useRef: Hg,
        useState: function() {
            return Sd(Do)
        },
        useDebugValue: Cd,
        useDeferredValue: function(r) {
            var i = tn();
            return Zg(i, ot.memoizedState, r)
        },
        useTransition: function() {
            var r = Sd(Do)[0]
                , i = tn().memoizedState;
            return [r, i]
        },
        useMutableSource: Ig,
        useSyncExternalStore: Fg,
        useId: ey,
        unstable_isNewReconciler: !1
    }
        , uP = {
        readContext: en,
        useCallback: Yg,
        useContext: en,
        useEffect: Ed,
        useImperativeHandle: Xg,
        useInsertionEffect: Kg,
        useLayoutEffect: Qg,
        useMemo: Jg,
        useReducer: bd,
        useRef: Hg,
        useState: function() {
            return bd(Do)
        },
        useDebugValue: Cd,
        useDeferredValue: function(r) {
            var i = tn();
            return ot === null ? i.memoizedState = r : Zg(i, ot.memoizedState, r)
        },
        useTransition: function() {
            var r = bd(Do)[0]
                , i = tn().memoizedState;
            return [r, i]
        },
        useMutableSource: Ig,
        useSyncExternalStore: Fg,
        useId: ey,
        unstable_isNewReconciler: !1
    };
    function hn(r, i) {
        if (r && r.defaultProps) {
            i = ee({}, i),
                r = r.defaultProps;
            for (var a in r)
                i[a] === void 0 && (i[a] = r[a]);
            return i
        }
        return i
    }
    function Pd(r, i, a, c) {
        i = r.memoizedState,
            a = a(c, i),
            a = a == null ? i : ee({}, i, a),
            r.memoizedState = a,
        r.lanes === 0 && (r.updateQueue.baseState = a)
    }
    var Al = {
        isMounted: function(r) {
            return (r = r._reactInternals) ? ss(r) === r : !1
        },
        enqueueSetState: function(r, i, a) {
            r = r._reactInternals;
            var c = Rt()
                , h = Rr(r)
                , g = Yn(c, h);
            g.payload = i,
            a != null && (g.callback = a),
                i = Cr(r, g, h),
            i !== null && (gn(i, r, h, c),
                Sl(i, r, h))
        },
        enqueueReplaceState: function(r, i, a) {
            r = r._reactInternals;
            var c = Rt()
                , h = Rr(r)
                , g = Yn(c, h);
            g.tag = 1,
                g.payload = i,
            a != null && (g.callback = a),
                i = Cr(r, g, h),
            i !== null && (gn(i, r, h, c),
                Sl(i, r, h))
        },
        enqueueForceUpdate: function(r, i) {
            r = r._reactInternals;
            var a = Rt()
                , c = Rr(r)
                , h = Yn(a, c);
            h.tag = 2,
            i != null && (h.callback = i),
                i = Cr(r, h, c),
            i !== null && (gn(i, r, c, a),
                Sl(i, r, c))
        }
    };
    function sy(r, i, a, c, h, g, C) {
        return r = r.stateNode,
            typeof r.shouldComponentUpdate == "function" ? r.shouldComponentUpdate(c, g, C) : i.prototype && i.prototype.isPureReactComponent ? !Eo(a, c) || !Eo(h, g) : !0
    }
    function iy(r, i, a) {
        var c = !1
            , h = Sr
            , g = i.contextType;
        return typeof g == "object" && g !== null ? g = en(g) : (h = Lt(i) ? os : xt.current,
            c = i.contextTypes,
            g = (c = c != null) ? ni(r, h) : Sr),
            i = new i(a,g),
            r.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null,
            i.updater = Al,
            r.stateNode = i,
            i._reactInternals = r,
        c && (r = r.stateNode,
            r.__reactInternalMemoizedUnmaskedChildContext = h,
            r.__reactInternalMemoizedMaskedChildContext = g),
            i
    }
    function oy(r, i, a, c) {
        r = i.state,
        typeof i.componentWillReceiveProps == "function" && i.componentWillReceiveProps(a, c),
        typeof i.UNSAFE_componentWillReceiveProps == "function" && i.UNSAFE_componentWillReceiveProps(a, c),
        i.state !== r && Al.enqueueReplaceState(i, i.state, null)
    }
    function Td(r, i, a, c) {
        var h = r.stateNode;
        h.props = a,
            h.state = r.memoizedState,
            h.refs = {},
            fd(r);
        var g = i.contextType;
        typeof g == "object" && g !== null ? h.context = en(g) : (g = Lt(i) ? os : xt.current,
            h.context = ni(r, g)),
            h.state = r.memoizedState,
            g = i.getDerivedStateFromProps,
        typeof g == "function" && (Pd(r, i, g, a),
            h.state = r.memoizedState),
        typeof i.getDerivedStateFromProps == "function" || typeof h.getSnapshotBeforeUpdate == "function" || typeof h.UNSAFE_componentWillMount != "function" && typeof h.componentWillMount != "function" || (i = h.state,
        typeof h.componentWillMount == "function" && h.componentWillMount(),
        typeof h.UNSAFE_componentWillMount == "function" && h.UNSAFE_componentWillMount(),
        i !== h.state && Al.enqueueReplaceState(h, h.state, null),
            bl(r, a, h, c),
            h.state = r.memoizedState),
        typeof h.componentDidMount == "function" && (r.flags |= 4194308)
    }
    function ci(r, i) {
        try {
            var a = ""
                , c = i;
            do
                a += be(c),
                    c = c.return;
            while (c);
            var h = a
        } catch (g) {
            h = `
Error generating stack: ` + g.message + `
` + g.stack
        }
        return {
            value: r,
            source: i,
            stack: h,
            digest: null
        }
    }
    function kd(r, i, a) {
        return {
            value: r,
            source: null,
            stack: a ?? null,
            digest: i ?? null
        }
    }
    function Rd(r, i) {
        try {
            console.error(i.value)
        } catch (a) {
            setTimeout(function() {
                throw a
            })
        }
    }
    var cP = typeof WeakMap == "function" ? WeakMap : Map;
    function ay(r, i, a) {
        a = Yn(-1, a),
            a.tag = 3,
            a.payload = {
                element: null
            };
        var c = i.value;
        return a.callback = function() {
            Dl || (Dl = !0,
                $d = c),
                Rd(r, i)
        }
            ,
            a
    }
    function ly(r, i, a) {
        a = Yn(-1, a),
            a.tag = 3;
        var c = r.type.getDerivedStateFromError;
        if (typeof c == "function") {
            var h = i.value;
            a.payload = function() {
                return c(h)
            }
                ,
                a.callback = function() {
                    Rd(r, i)
                }
        }
        var g = r.stateNode;
        return g !== null && typeof g.componentDidCatch == "function" && (a.callback = function() {
                Rd(r, i),
                typeof c != "function" && (Tr === null ? Tr = new Set([this]) : Tr.add(this));
                var C = i.stack;
                this.componentDidCatch(i.value, {
                    componentStack: C !== null ? C : ""
                })
            }
        ),
            a
    }
    function uy(r, i, a) {
        var c = r.pingCache;
        if (c === null) {
            c = r.pingCache = new cP;
            var h = new Set;
            c.set(i, h)
        } else
            h = c.get(i),
            h === void 0 && (h = new Set,
                c.set(i, h));
        h.has(a) || (h.add(a),
            r = CP.bind(null, r, i, a),
            i.then(r, r))
    }
    function cy(r) {
        do {
            var i;
            if ((i = r.tag === 13) && (i = r.memoizedState,
                i = i !== null ? i.dehydrated !== null : !0),
                i)
                return r;
            r = r.return
        } while (r !== null);
        return null
    }
    function dy(r, i, a, c, h) {
        return (r.mode & 1) === 0 ? (r === i ? r.flags |= 65536 : (r.flags |= 128,
            a.flags |= 131072,
            a.flags &= -52805,
        a.tag === 1 && (a.alternate === null ? a.tag = 17 : (i = Yn(-1, 1),
            i.tag = 2,
            Cr(a, i, 1))),
            a.lanes |= 1),
            r) : (r.flags |= 65536,
            r.lanes = h,
            r)
    }
    var dP = _.ReactCurrentOwner
        , Mt = !1;
    function kt(r, i, a, c) {
        i.child = r === null ? Ng(i, null, a, c) : oi(i, r.child, a, c)
    }
    function fy(r, i, a, c, h) {
        a = a.render;
        var g = i.ref;
        return li(i, h),
            c = wd(r, i, a, c, g, h),
            a = xd(),
            r !== null && !Mt ? (i.updateQueue = r.updateQueue,
                i.flags &= -2053,
                r.lanes &= ~h,
                Jn(r, i, h)) : ($e && a && nd(i),
                i.flags |= 1,
                kt(r, i, c, h),
                i.child)
    }
    function hy(r, i, a, c, h) {
        if (r === null) {
            var g = a.type;
            return typeof g == "function" && !Xd(g) && g.defaultProps === void 0 && a.compare === null && a.defaultProps === void 0 ? (i.tag = 15,
                i.type = g,
                py(r, i, g, c, h)) : (r = zl(a.type, null, c, i, i.mode, h),
                r.ref = i.ref,
                r.return = i,
                i.child = r)
        }
        if (g = r.child,
        (r.lanes & h) === 0) {
            var C = g.memoizedProps;
            if (a = a.compare,
                a = a !== null ? a : Eo,
            a(C, c) && r.ref === i.ref)
                return Jn(r, i, h)
        }
        return i.flags |= 1,
            r = _r(g, c),
            r.ref = i.ref,
            r.return = i,
            i.child = r
    }
    function py(r, i, a, c, h) {
        if (r !== null) {
            var g = r.memoizedProps;
            if (Eo(g, c) && r.ref === i.ref)
                if (Mt = !1,
                    i.pendingProps = c = g,
                (r.lanes & h) !== 0)
                    (r.flags & 131072) !== 0 && (Mt = !0);
                else
                    return i.lanes = r.lanes,
                        Jn(r, i, h)
        }
        return Ad(r, i, a, c, h)
    }
    function my(r, i, a) {
        var c = i.pendingProps
            , h = c.children
            , g = r !== null ? r.memoizedState : null;
        if (c.mode === "hidden")
            if ((i.mode & 1) === 0)
                i.memoizedState = {
                    baseLanes: 0,
                    cachePool: null,
                    transitions: null
                },
                    Be(fi, qt),
                    qt |= a;
            else {
                if ((a & 1073741824) === 0)
                    return r = g !== null ? g.baseLanes | a : a,
                        i.lanes = i.childLanes = 1073741824,
                        i.memoizedState = {
                            baseLanes: r,
                            cachePool: null,
                            transitions: null
                        },
                        i.updateQueue = null,
                        Be(fi, qt),
                        qt |= r,
                        null;
                i.memoizedState = {
                    baseLanes: 0,
                    cachePool: null,
                    transitions: null
                },
                    c = g !== null ? g.baseLanes : a,
                    Be(fi, qt),
                    qt |= c
            }
        else
            g !== null ? (c = g.baseLanes | a,
                i.memoizedState = null) : c = a,
                Be(fi, qt),
                qt |= c;
        return kt(r, i, h, a),
            i.child
    }
    function gy(r, i) {
        var a = i.ref;
        (r === null && a !== null || r !== null && r.ref !== a) && (i.flags |= 512,
            i.flags |= 2097152)
    }
    function Ad(r, i, a, c, h) {
        var g = Lt(a) ? os : xt.current;
        return g = ni(i, g),
            li(i, h),
            a = wd(r, i, a, c, g, h),
            c = xd(),
            r !== null && !Mt ? (i.updateQueue = r.updateQueue,
                i.flags &= -2053,
                r.lanes &= ~h,
                Jn(r, i, h)) : ($e && c && nd(i),
                i.flags |= 1,
                kt(r, i, a, h),
                i.child)
    }
    function yy(r, i, a, c, h) {
        if (Lt(a)) {
            var g = !0;
            hl(i)
        } else
            g = !1;
        if (li(i, h),
        i.stateNode === null)
            Nl(r, i),
                iy(i, a, c),
                Td(i, a, c, h),
                c = !0;
        else if (r === null) {
            var C = i.stateNode
                , A = i.memoizedProps;
            C.props = A;
            var N = C.context
                , V = a.contextType;
            typeof V == "object" && V !== null ? V = en(V) : (V = Lt(a) ? os : xt.current,
                V = ni(i, V));
            var G = a.getDerivedStateFromProps
                , Y = typeof G == "function" || typeof C.getSnapshotBeforeUpdate == "function";
            Y || typeof C.UNSAFE_componentWillReceiveProps != "function" && typeof C.componentWillReceiveProps != "function" || (A !== c || N !== V) && oy(i, C, c, V),
                Er = !1;
            var Q = i.memoizedState;
            C.state = Q,
                bl(i, c, C, h),
                N = i.memoizedState,
                A !== c || Q !== N || Ot.current || Er ? (typeof G == "function" && (Pd(i, a, G, c),
                    N = i.memoizedState),
                    (A = Er || sy(i, a, A, c, Q, N, V)) ? (Y || typeof C.UNSAFE_componentWillMount != "function" && typeof C.componentWillMount != "function" || (typeof C.componentWillMount == "function" && C.componentWillMount(),
                    typeof C.UNSAFE_componentWillMount == "function" && C.UNSAFE_componentWillMount()),
                    typeof C.componentDidMount == "function" && (i.flags |= 4194308)) : (typeof C.componentDidMount == "function" && (i.flags |= 4194308),
                        i.memoizedProps = c,
                        i.memoizedState = N),
                    C.props = c,
                    C.state = N,
                    C.context = V,
                    c = A) : (typeof C.componentDidMount == "function" && (i.flags |= 4194308),
                    c = !1)
        } else {
            C = i.stateNode,
                Lg(r, i),
                A = i.memoizedProps,
                V = i.type === i.elementType ? A : hn(i.type, A),
                C.props = V,
                Y = i.pendingProps,
                Q = C.context,
                N = a.contextType,
                typeof N == "object" && N !== null ? N = en(N) : (N = Lt(a) ? os : xt.current,
                    N = ni(i, N));
            var oe = a.getDerivedStateFromProps;
            (G = typeof oe == "function" || typeof C.getSnapshotBeforeUpdate == "function") || typeof C.UNSAFE_componentWillReceiveProps != "function" && typeof C.componentWillReceiveProps != "function" || (A !== Y || Q !== N) && oy(i, C, c, N),
                Er = !1,
                Q = i.memoizedState,
                C.state = Q,
                bl(i, c, C, h);
            var fe = i.memoizedState;
            A !== Y || Q !== fe || Ot.current || Er ? (typeof oe == "function" && (Pd(i, a, oe, c),
                fe = i.memoizedState),
                (V = Er || sy(i, a, V, c, Q, fe, N) || !1) ? (G || typeof C.UNSAFE_componentWillUpdate != "function" && typeof C.componentWillUpdate != "function" || (typeof C.componentWillUpdate == "function" && C.componentWillUpdate(c, fe, N),
                typeof C.UNSAFE_componentWillUpdate == "function" && C.UNSAFE_componentWillUpdate(c, fe, N)),
                typeof C.componentDidUpdate == "function" && (i.flags |= 4),
                typeof C.getSnapshotBeforeUpdate == "function" && (i.flags |= 1024)) : (typeof C.componentDidUpdate != "function" || A === r.memoizedProps && Q === r.memoizedState || (i.flags |= 4),
                typeof C.getSnapshotBeforeUpdate != "function" || A === r.memoizedProps && Q === r.memoizedState || (i.flags |= 1024),
                    i.memoizedProps = c,
                    i.memoizedState = fe),
                C.props = c,
                C.state = fe,
                C.context = N,
                c = V) : (typeof C.componentDidUpdate != "function" || A === r.memoizedProps && Q === r.memoizedState || (i.flags |= 4),
            typeof C.getSnapshotBeforeUpdate != "function" || A === r.memoizedProps && Q === r.memoizedState || (i.flags |= 1024),
                c = !1)
        }
        return _d(r, i, a, c, g, h)
    }
    function _d(r, i, a, c, h, g) {
        gy(r, i);
        var C = (i.flags & 128) !== 0;
        if (!c && !C)
            return h && bg(i, a, !1),
                Jn(r, i, g);
        c = i.stateNode,
            dP.current = i;
        var A = C && typeof a.getDerivedStateFromError != "function" ? null : c.render();
        return i.flags |= 1,
            r !== null && C ? (i.child = oi(i, r.child, null, g),
                i.child = oi(i, null, A, g)) : kt(r, i, A, g),
            i.memoizedState = c.state,
        h && bg(i, a, !0),
            i.child
    }
    function vy(r) {
        var i = r.stateNode;
        i.pendingContext ? xg(r, i.pendingContext, i.pendingContext !== i.context) : i.context && xg(r, i.context, !1),
            hd(r, i.containerInfo)
    }
    function wy(r, i, a, c, h) {
        return ii(),
            od(h),
            i.flags |= 256,
            kt(r, i, a, c),
            i.child
    }
    var Nd = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0
    };
    function Od(r) {
        return {
            baseLanes: r,
            cachePool: null,
            transitions: null
        }
    }
    function xy(r, i, a) {
        var c = i.pendingProps, h = We.current, g = !1, C = (i.flags & 128) !== 0, A;
        if ((A = C) || (A = r !== null && r.memoizedState === null ? !1 : (h & 2) !== 0),
            A ? (g = !0,
                i.flags &= -129) : (r === null || r.memoizedState !== null) && (h |= 1),
            Be(We, h & 1),
        r === null)
            return id(i),
                r = i.memoizedState,
                r !== null && (r = r.dehydrated,
                r !== null) ? ((i.mode & 1) === 0 ? i.lanes = 1 : r.data === "$!" ? i.lanes = 8 : i.lanes = 1073741824,
                    null) : (C = c.children,
                    r = c.fallback,
                    g ? (c = i.mode,
                        g = i.child,
                        C = {
                            mode: "hidden",
                            children: C
                        },
                        (c & 1) === 0 && g !== null ? (g.childLanes = 0,
                            g.pendingProps = C) : g = $l(C, c, 0, null),
                        r = gs(r, c, a, null),
                        g.return = i,
                        r.return = i,
                        g.sibling = r,
                        i.child = g,
                        i.child.memoizedState = Od(a),
                        i.memoizedState = Nd,
                        r) : Ld(i, C));
        if (h = r.memoizedState,
        h !== null && (A = h.dehydrated,
        A !== null))
            return fP(r, i, C, c, A, h, a);
        if (g) {
            g = c.fallback,
                C = i.mode,
                h = r.child,
                A = h.sibling;
            var N = {
                mode: "hidden",
                children: c.children
            };
            return (C & 1) === 0 && i.child !== h ? (c = i.child,
                c.childLanes = 0,
                c.pendingProps = N,
                i.deletions = null) : (c = _r(h, N),
                c.subtreeFlags = h.subtreeFlags & 14680064),
                A !== null ? g = _r(A, g) : (g = gs(g, C, a, null),
                    g.flags |= 2),
                g.return = i,
                c.return = i,
                c.sibling = g,
                i.child = c,
                c = g,
                g = i.child,
                C = r.child.memoizedState,
                C = C === null ? Od(a) : {
                    baseLanes: C.baseLanes | a,
                    cachePool: null,
                    transitions: C.transitions
                },
                g.memoizedState = C,
                g.childLanes = r.childLanes & ~a,
                i.memoizedState = Nd,
                c
        }
        return g = r.child,
            r = g.sibling,
            c = _r(g, {
                mode: "visible",
                children: c.children
            }),
        (i.mode & 1) === 0 && (c.lanes = a),
            c.return = i,
            c.sibling = null,
        r !== null && (a = i.deletions,
            a === null ? (i.deletions = [r],
                i.flags |= 16) : a.push(r)),
            i.child = c,
            i.memoizedState = null,
            c
    }
    function Ld(r, i) {
        return i = $l({
            mode: "visible",
            children: i
        }, r.mode, 0, null),
            i.return = r,
            r.child = i
    }
    function _l(r, i, a, c) {
        return c !== null && od(c),
            oi(i, r.child, null, a),
            r = Ld(i, i.pendingProps.children),
            r.flags |= 2,
            i.memoizedState = null,
            r
    }
    function fP(r, i, a, c, h, g, C) {
        if (a)
            return i.flags & 256 ? (i.flags &= -257,
                c = kd(Error(n(422))),
                _l(r, i, C, c)) : i.memoizedState !== null ? (i.child = r.child,
                i.flags |= 128,
                null) : (g = c.fallback,
                h = i.mode,
                c = $l({
                    mode: "visible",
                    children: c.children
                }, h, 0, null),
                g = gs(g, h, C, null),
                g.flags |= 2,
                c.return = i,
                g.return = i,
                c.sibling = g,
                i.child = c,
            (i.mode & 1) !== 0 && oi(i, r.child, null, C),
                i.child.memoizedState = Od(C),
                i.memoizedState = Nd,
                g);
        if ((i.mode & 1) === 0)
            return _l(r, i, C, null);
        if (h.data === "$!") {
            if (c = h.nextSibling && h.nextSibling.dataset,
                c)
                var A = c.dgst;
            return c = A,
                g = Error(n(419)),
                c = kd(g, c, void 0),
                _l(r, i, C, c)
        }
        if (A = (C & r.childLanes) !== 0,
        Mt || A) {
            if (c = dt,
            c !== null) {
                switch (C & -C) {
                    case 4:
                        h = 2;
                        break;
                    case 16:
                        h = 8;
                        break;
                    case 64:
                    case 128:
                    case 256:
                    case 512:
                    case 1024:
                    case 2048:
                    case 4096:
                    case 8192:
                    case 16384:
                    case 32768:
                    case 65536:
                    case 131072:
                    case 262144:
                    case 524288:
                    case 1048576:
                    case 2097152:
                    case 4194304:
                    case 8388608:
                    case 16777216:
                    case 33554432:
                    case 67108864:
                        h = 32;
                        break;
                    case 536870912:
                        h = 268435456;
                        break;
                    default:
                        h = 0
                }
                h = (h & (c.suspendedLanes | C)) !== 0 ? 0 : h,
                h !== 0 && h !== g.retryLane && (g.retryLane = h,
                    Xn(r, h),
                    gn(c, r, h, -1))
            }
            return Gd(),
                c = kd(Error(n(421))),
                _l(r, i, C, c)
        }
        return h.data === "$?" ? (i.flags |= 128,
            i.child = r.child,
            i = PP.bind(null, r),
            h._reactRetry = i,
            null) : (r = g.treeContext,
            Ht = wr(h.nextSibling),
            Wt = i,
            $e = !0,
            fn = null,
        r !== null && (Jt[Zt++] = Qn,
            Jt[Zt++] = Gn,
            Jt[Zt++] = as,
            Qn = r.id,
            Gn = r.overflow,
            as = i),
            i = Ld(i, c.children),
            i.flags |= 4096,
            i)
    }
    function Sy(r, i, a) {
        r.lanes |= i;
        var c = r.alternate;
        c !== null && (c.lanes |= i),
            cd(r.return, i, a)
    }
    function Md(r, i, a, c, h) {
        var g = r.memoizedState;
        g === null ? r.memoizedState = {
            isBackwards: i,
            rendering: null,
            renderingStartTime: 0,
            last: c,
            tail: a,
            tailMode: h
        } : (g.isBackwards = i,
            g.rendering = null,
            g.renderingStartTime = 0,
            g.last = c,
            g.tail = a,
            g.tailMode = h)
    }
    function by(r, i, a) {
        var c = i.pendingProps
            , h = c.revealOrder
            , g = c.tail;
        if (kt(r, i, c.children, a),
            c = We.current,
        (c & 2) !== 0)
            c = c & 1 | 2,
                i.flags |= 128;
        else {
            if (r !== null && (r.flags & 128) !== 0)
                e: for (r = i.child; r !== null; ) {
                    if (r.tag === 13)
                        r.memoizedState !== null && Sy(r, a, i);
                    else if (r.tag === 19)
                        Sy(r, a, i);
                    else if (r.child !== null) {
                        r.child.return = r,
                            r = r.child;
                        continue
                    }
                    if (r === i)
                        break e;
                    for (; r.sibling === null; ) {
                        if (r.return === null || r.return === i)
                            break e;
                        r = r.return
                    }
                    r.sibling.return = r.return,
                        r = r.sibling
                }
            c &= 1
        }
        if (Be(We, c),
        (i.mode & 1) === 0)
            i.memoizedState = null;
        else
            switch (h) {
                case "forwards":
                    for (a = i.child,
                             h = null; a !== null; )
                        r = a.alternate,
                        r !== null && El(r) === null && (h = a),
                            a = a.sibling;
                    a = h,
                        a === null ? (h = i.child,
                            i.child = null) : (h = a.sibling,
                            a.sibling = null),
                        Md(i, !1, h, a, g);
                    break;
                case "backwards":
                    for (a = null,
                             h = i.child,
                             i.child = null; h !== null; ) {
                        if (r = h.alternate,
                        r !== null && El(r) === null) {
                            i.child = h;
                            break
                        }
                        r = h.sibling,
                            h.sibling = a,
                            a = h,
                            h = r
                    }
                    Md(i, !0, a, null, g);
                    break;
                case "together":
                    Md(i, !1, null, null, void 0);
                    break;
                default:
                    i.memoizedState = null
            }
        return i.child
    }
    function Nl(r, i) {
        (i.mode & 1) === 0 && r !== null && (r.alternate = null,
            i.alternate = null,
            i.flags |= 2)
    }
    function Jn(r, i, a) {
        if (r !== null && (i.dependencies = r.dependencies),
            fs |= i.lanes,
        (a & i.childLanes) === 0)
            return null;
        if (r !== null && i.child !== r.child)
            throw Error(n(153));
        if (i.child !== null) {
            for (r = i.child,
                     a = _r(r, r.pendingProps),
                     i.child = a,
                     a.return = i; r.sibling !== null; )
                r = r.sibling,
                    a = a.sibling = _r(r, r.pendingProps),
                    a.return = i;
            a.sibling = null
        }
        return i.child
    }
    function hP(r, i, a) {
        switch (i.tag) {
            case 3:
                vy(i),
                    ii();
                break;
            case 5:
                Dg(i);
                break;
            case 1:
                Lt(i.type) && hl(i);
                break;
            case 4:
                hd(i, i.stateNode.containerInfo);
                break;
            case 10:
                var c = i.type._context
                    , h = i.memoizedProps.value;
                Be(wl, c._currentValue),
                    c._currentValue = h;
                break;
            case 13:
                if (c = i.memoizedState,
                c !== null)
                    return c.dehydrated !== null ? (Be(We, We.current & 1),
                        i.flags |= 128,
                        null) : (a & i.child.childLanes) !== 0 ? xy(r, i, a) : (Be(We, We.current & 1),
                        r = Jn(r, i, a),
                        r !== null ? r.sibling : null);
                Be(We, We.current & 1);
                break;
            case 19:
                if (c = (a & i.childLanes) !== 0,
                (r.flags & 128) !== 0) {
                    if (c)
                        return by(r, i, a);
                    i.flags |= 128
                }
                if (h = i.memoizedState,
                h !== null && (h.rendering = null,
                    h.tail = null,
                    h.lastEffect = null),
                    Be(We, We.current),
                    c)
                    break;
                return null;
            case 22:
            case 23:
                return i.lanes = 0,
                    my(r, i, a)
        }
        return Jn(r, i, a)
    }
    var Ey, jd, Cy, Py;
    Ey = function(r, i) {
        for (var a = i.child; a !== null; ) {
            if (a.tag === 5 || a.tag === 6)
                r.appendChild(a.stateNode);
            else if (a.tag !== 4 && a.child !== null) {
                a.child.return = a,
                    a = a.child;
                continue
            }
            if (a === i)
                break;
            for (; a.sibling === null; ) {
                if (a.return === null || a.return === i)
                    return;
                a = a.return
            }
            a.sibling.return = a.return,
                a = a.sibling
        }
    }
        ,
        jd = function() {}
        ,
        Cy = function(r, i, a, c) {
            var h = r.memoizedProps;
            if (h !== c) {
                r = i.stateNode,
                    cs(Rn.current);
                var g = null;
                switch (a) {
                    case "input":
                        h = Nt(r, h),
                            c = Nt(r, c),
                            g = [];
                        break;
                    case "select":
                        h = ee({}, h, {
                            value: void 0
                        }),
                            c = ee({}, c, {
                                value: void 0
                            }),
                            g = [];
                        break;
                    case "textarea":
                        h = hc(r, h),
                            c = hc(r, c),
                            g = [];
                        break;
                    default:
                        typeof h.onClick != "function" && typeof c.onClick == "function" && (r.onclick = cl)
                }
                mc(a, c);
                var C;
                a = null;
                for (V in h)
                    if (!c.hasOwnProperty(V) && h.hasOwnProperty(V) && h[V] != null)
                        if (V === "style") {
                            var A = h[V];
                            for (C in A)
                                A.hasOwnProperty(C) && (a || (a = {}),
                                    a[C] = "")
                        } else
                            V !== "dangerouslySetInnerHTML" && V !== "children" && V !== "suppressContentEditableWarning" && V !== "suppressHydrationWarning" && V !== "autoFocus" && (o.hasOwnProperty(V) ? g || (g = []) : (g = g || []).push(V, null));
                for (V in c) {
                    var N = c[V];
                    if (A = h != null ? h[V] : void 0,
                    c.hasOwnProperty(V) && N !== A && (N != null || A != null))
                        if (V === "style")
                            if (A) {
                                for (C in A)
                                    !A.hasOwnProperty(C) || N && N.hasOwnProperty(C) || (a || (a = {}),
                                        a[C] = "");
                                for (C in N)
                                    N.hasOwnProperty(C) && A[C] !== N[C] && (a || (a = {}),
                                        a[C] = N[C])
                            } else
                                a || (g || (g = []),
                                    g.push(V, a)),
                                    a = N;
                        else
                            V === "dangerouslySetInnerHTML" ? (N = N ? N.__html : void 0,
                                A = A ? A.__html : void 0,
                            N != null && A !== N && (g = g || []).push(V, N)) : V === "children" ? typeof N != "string" && typeof N != "number" || (g = g || []).push(V, "" + N) : V !== "suppressContentEditableWarning" && V !== "suppressHydrationWarning" && (o.hasOwnProperty(V) ? (N != null && V === "onScroll" && Ve("scroll", r),
                            g || A === N || (g = [])) : (g = g || []).push(V, N))
                }
                a && (g = g || []).push("style", a);
                var V = g;
                (i.updateQueue = V) && (i.flags |= 4)
            }
        }
        ,
        Py = function(r, i, a, c) {
            a !== c && (i.flags |= 4)
        }
    ;
    function Fo(r, i) {
        if (!$e)
            switch (r.tailMode) {
                case "hidden":
                    i = r.tail;
                    for (var a = null; i !== null; )
                        i.alternate !== null && (a = i),
                            i = i.sibling;
                    a === null ? r.tail = null : a.sibling = null;
                    break;
                case "collapsed":
                    a = r.tail;
                    for (var c = null; a !== null; )
                        a.alternate !== null && (c = a),
                            a = a.sibling;
                    c === null ? i || r.tail === null ? r.tail = null : r.tail.sibling = null : c.sibling = null
            }
    }
    function bt(r) {
        var i = r.alternate !== null && r.alternate.child === r.child
            , a = 0
            , c = 0;
        if (i)
            for (var h = r.child; h !== null; )
                a |= h.lanes | h.childLanes,
                    c |= h.subtreeFlags & 14680064,
                    c |= h.flags & 14680064,
                    h.return = r,
                    h = h.sibling;
        else
            for (h = r.child; h !== null; )
                a |= h.lanes | h.childLanes,
                    c |= h.subtreeFlags,
                    c |= h.flags,
                    h.return = r,
                    h = h.sibling;
        return r.subtreeFlags |= c,
            r.childLanes = a,
            i
    }
    function pP(r, i, a) {
        var c = i.pendingProps;
        switch (rd(i),
            i.tag) {
            case 2:
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
                return bt(i),
                    null;
            case 1:
                return Lt(i.type) && fl(),
                    bt(i),
                    null;
            case 3:
                return c = i.stateNode,
                    ui(),
                    Ue(Ot),
                    Ue(xt),
                    gd(),
                c.pendingContext && (c.context = c.pendingContext,
                    c.pendingContext = null),
                (r === null || r.child === null) && (yl(i) ? i.flags |= 4 : r === null || r.memoizedState.isDehydrated && (i.flags & 256) === 0 || (i.flags |= 1024,
                fn !== null && (qd(fn),
                    fn = null))),
                    jd(r, i),
                    bt(i),
                    null;
            case 5:
                pd(i);
                var h = cs(Lo.current);
                if (a = i.type,
                r !== null && i.stateNode != null)
                    Cy(r, i, a, c, h),
                    r.ref !== i.ref && (i.flags |= 512,
                        i.flags |= 2097152);
                else {
                    if (!c) {
                        if (i.stateNode === null)
                            throw Error(n(166));
                        return bt(i),
                            null
                    }
                    if (r = cs(Rn.current),
                        yl(i)) {
                        c = i.stateNode,
                            a = i.type;
                        var g = i.memoizedProps;
                        switch (c[kn] = i,
                            c[Ro] = g,
                            r = (i.mode & 1) !== 0,
                            a) {
                            case "dialog":
                                Ve("cancel", c),
                                    Ve("close", c);
                                break;
                            case "iframe":
                            case "object":
                            case "embed":
                                Ve("load", c);
                                break;
                            case "video":
                            case "audio":
                                for (h = 0; h < Po.length; h++)
                                    Ve(Po[h], c);
                                break;
                            case "source":
                                Ve("error", c);
                                break;
                            case "img":
                            case "image":
                            case "link":
                                Ve("error", c),
                                    Ve("load", c);
                                break;
                            case "details":
                                Ve("toggle", c);
                                break;
                            case "input":
                                cr(c, g),
                                    Ve("invalid", c);
                                break;
                            case "select":
                                c._wrapperState = {
                                    wasMultiple: !!g.multiple
                                },
                                    Ve("invalid", c);
                                break;
                            case "textarea":
                                lm(c, g),
                                    Ve("invalid", c)
                        }
                        mc(a, g),
                            h = null;
                        for (var C in g)
                            if (g.hasOwnProperty(C)) {
                                var A = g[C];
                                C === "children" ? typeof A == "string" ? c.textContent !== A && (g.suppressHydrationWarning !== !0 && ul(c.textContent, A, r),
                                    h = ["children", A]) : typeof A == "number" && c.textContent !== "" + A && (g.suppressHydrationWarning !== !0 && ul(c.textContent, A, r),
                                    h = ["children", "" + A]) : o.hasOwnProperty(C) && A != null && C === "onScroll" && Ve("scroll", c)
                            }
                        switch (a) {
                            case "input":
                                _e(c),
                                    Ua(c, g, !0);
                                break;
                            case "textarea":
                                _e(c),
                                    cm(c);
                                break;
                            case "select":
                            case "option":
                                break;
                            default:
                                typeof g.onClick == "function" && (c.onclick = cl)
                        }
                        c = h,
                            i.updateQueue = c,
                        c !== null && (i.flags |= 4)
                    } else {
                        C = h.nodeType === 9 ? h : h.ownerDocument,
                        r === "http://www.w3.org/1999/xhtml" && (r = dm(a)),
                            r === "http://www.w3.org/1999/xhtml" ? a === "script" ? (r = C.createElement("div"),
                                r.innerHTML = "<script><\/script>",
                                r = r.removeChild(r.firstChild)) : typeof c.is == "string" ? r = C.createElement(a, {
                                is: c.is
                            }) : (r = C.createElement(a),
                            a === "select" && (C = r,
                                c.multiple ? C.multiple = !0 : c.size && (C.size = c.size))) : r = C.createElementNS(r, a),
                            r[kn] = i,
                            r[Ro] = c,
                            Ey(r, i, !1, !1),
                            i.stateNode = r;
                        e: {
                            switch (C = gc(a, c),
                                a) {
                                case "dialog":
                                    Ve("cancel", r),
                                        Ve("close", r),
                                        h = c;
                                    break;
                                case "iframe":
                                case "object":
                                case "embed":
                                    Ve("load", r),
                                        h = c;
                                    break;
                                case "video":
                                case "audio":
                                    for (h = 0; h < Po.length; h++)
                                        Ve(Po[h], r);
                                    h = c;
                                    break;
                                case "source":
                                    Ve("error", r),
                                        h = c;
                                    break;
                                case "img":
                                case "image":
                                case "link":
                                    Ve("error", r),
                                        Ve("load", r),
                                        h = c;
                                    break;
                                case "details":
                                    Ve("toggle", r),
                                        h = c;
                                    break;
                                case "input":
                                    cr(r, c),
                                        h = Nt(r, c),
                                        Ve("invalid", r);
                                    break;
                                case "option":
                                    h = c;
                                    break;
                                case "select":
                                    r._wrapperState = {
                                        wasMultiple: !!c.multiple
                                    },
                                        h = ee({}, c, {
                                            value: void 0
                                        }),
                                        Ve("invalid", r);
                                    break;
                                case "textarea":
                                    lm(r, c),
                                        h = hc(r, c),
                                        Ve("invalid", r);
                                    break;
                                default:
                                    h = c
                            }
                            mc(a, h),
                                A = h;
                            for (g in A)
                                if (A.hasOwnProperty(g)) {
                                    var N = A[g];
                                    g === "style" ? pm(r, N) : g === "dangerouslySetInnerHTML" ? (N = N ? N.__html : void 0,
                                    N != null && fm(r, N)) : g === "children" ? typeof N == "string" ? (a !== "textarea" || N !== "") && io(r, N) : typeof N == "number" && io(r, "" + N) : g !== "suppressContentEditableWarning" && g !== "suppressHydrationWarning" && g !== "autoFocus" && (o.hasOwnProperty(g) ? N != null && g === "onScroll" && Ve("scroll", r) : N != null && R(r, g, N, C))
                                }
                            switch (a) {
                                case "input":
                                    _e(r),
                                        Ua(r, c, !1);
                                    break;
                                case "textarea":
                                    _e(r),
                                        cm(r);
                                    break;
                                case "option":
                                    c.value != null && r.setAttribute("value", "" + ye(c.value));
                                    break;
                                case "select":
                                    r.multiple = !!c.multiple,
                                        g = c.value,
                                        g != null ? Ws(r, !!c.multiple, g, !1) : c.defaultValue != null && Ws(r, !!c.multiple, c.defaultValue, !0);
                                    break;
                                default:
                                    typeof h.onClick == "function" && (r.onclick = cl)
                            }
                            switch (a) {
                                case "button":
                                case "input":
                                case "select":
                                case "textarea":
                                    c = !!c.autoFocus;
                                    break e;
                                case "img":
                                    c = !0;
                                    break e;
                                default:
                                    c = !1
                            }
                        }
                        c && (i.flags |= 4)
                    }
                    i.ref !== null && (i.flags |= 512,
                        i.flags |= 2097152)
                }
                return bt(i),
                    null;
            case 6:
                if (r && i.stateNode != null)
                    Py(r, i, r.memoizedProps, c);
                else {
                    if (typeof c != "string" && i.stateNode === null)
                        throw Error(n(166));
                    if (a = cs(Lo.current),
                        cs(Rn.current),
                        yl(i)) {
                        if (c = i.stateNode,
                            a = i.memoizedProps,
                            c[kn] = i,
                        (g = c.nodeValue !== a) && (r = Wt,
                        r !== null))
                            switch (r.tag) {
                                case 3:
                                    ul(c.nodeValue, a, (r.mode & 1) !== 0);
                                    break;
                                case 5:
                                    r.memoizedProps.suppressHydrationWarning !== !0 && ul(c.nodeValue, a, (r.mode & 1) !== 0)
                            }
                        g && (i.flags |= 4)
                    } else
                        c = (a.nodeType === 9 ? a : a.ownerDocument).createTextNode(c),
                            c[kn] = i,
                            i.stateNode = c
                }
                return bt(i),
                    null;
            case 13:
                if (Ue(We),
                    c = i.memoizedState,
                r === null || r.memoizedState !== null && r.memoizedState.dehydrated !== null) {
                    if ($e && Ht !== null && (i.mode & 1) !== 0 && (i.flags & 128) === 0)
                        Rg(),
                            ii(),
                            i.flags |= 98560,
                            g = !1;
                    else if (g = yl(i),
                    c !== null && c.dehydrated !== null) {
                        if (r === null) {
                            if (!g)
                                throw Error(n(318));
                            if (g = i.memoizedState,
                                g = g !== null ? g.dehydrated : null,
                                !g)
                                throw Error(n(317));
                            g[kn] = i
                        } else
                            ii(),
                            (i.flags & 128) === 0 && (i.memoizedState = null),
                                i.flags |= 4;
                        bt(i),
                            g = !1
                    } else
                        fn !== null && (qd(fn),
                            fn = null),
                            g = !0;
                    if (!g)
                        return i.flags & 65536 ? i : null
                }
                return (i.flags & 128) !== 0 ? (i.lanes = a,
                    i) : (c = c !== null,
                c !== (r !== null && r.memoizedState !== null) && c && (i.child.flags |= 8192,
                (i.mode & 1) !== 0 && (r === null || (We.current & 1) !== 0 ? at === 0 && (at = 3) : Gd())),
                i.updateQueue !== null && (i.flags |= 4),
                    bt(i),
                    null);
            case 4:
                return ui(),
                    jd(r, i),
                r === null && To(i.stateNode.containerInfo),
                    bt(i),
                    null;
            case 10:
                return ud(i.type._context),
                    bt(i),
                    null;
            case 17:
                return Lt(i.type) && fl(),
                    bt(i),
                    null;
            case 19:
                if (Ue(We),
                    g = i.memoizedState,
                g === null)
                    return bt(i),
                        null;
                if (c = (i.flags & 128) !== 0,
                    C = g.rendering,
                C === null)
                    if (c)
                        Fo(g, !1);
                    else {
                        if (at !== 0 || r !== null && (r.flags & 128) !== 0)
                            for (r = i.child; r !== null; ) {
                                if (C = El(r),
                                C !== null) {
                                    for (i.flags |= 128,
                                             Fo(g, !1),
                                             c = C.updateQueue,
                                         c !== null && (i.updateQueue = c,
                                             i.flags |= 4),
                                             i.subtreeFlags = 0,
                                             c = a,
                                             a = i.child; a !== null; )
                                        g = a,
                                            r = c,
                                            g.flags &= 14680066,
                                            C = g.alternate,
                                            C === null ? (g.childLanes = 0,
                                                g.lanes = r,
                                                g.child = null,
                                                g.subtreeFlags = 0,
                                                g.memoizedProps = null,
                                                g.memoizedState = null,
                                                g.updateQueue = null,
                                                g.dependencies = null,
                                                g.stateNode = null) : (g.childLanes = C.childLanes,
                                                g.lanes = C.lanes,
                                                g.child = C.child,
                                                g.subtreeFlags = 0,
                                                g.deletions = null,
                                                g.memoizedProps = C.memoizedProps,
                                                g.memoizedState = C.memoizedState,
                                                g.updateQueue = C.updateQueue,
                                                g.type = C.type,
                                                r = C.dependencies,
                                                g.dependencies = r === null ? null : {
                                                    lanes: r.lanes,
                                                    firstContext: r.firstContext
                                                }),
                                            a = a.sibling;
                                    return Be(We, We.current & 1 | 2),
                                        i.child
                                }
                                r = r.sibling
                            }
                        g.tail !== null && Xe() > hi && (i.flags |= 128,
                            c = !0,
                            Fo(g, !1),
                            i.lanes = 4194304)
                    }
                else {
                    if (!c)
                        if (r = El(C),
                        r !== null) {
                            if (i.flags |= 128,
                                c = !0,
                                a = r.updateQueue,
                            a !== null && (i.updateQueue = a,
                                i.flags |= 4),
                                Fo(g, !0),
                            g.tail === null && g.tailMode === "hidden" && !C.alternate && !$e)
                                return bt(i),
                                    null
                        } else
                            2 * Xe() - g.renderingStartTime > hi && a !== 1073741824 && (i.flags |= 128,
                                c = !0,
                                Fo(g, !1),
                                i.lanes = 4194304);
                    g.isBackwards ? (C.sibling = i.child,
                        i.child = C) : (a = g.last,
                        a !== null ? a.sibling = C : i.child = C,
                        g.last = C)
                }
                return g.tail !== null ? (i = g.tail,
                    g.rendering = i,
                    g.tail = i.sibling,
                    g.renderingStartTime = Xe(),
                    i.sibling = null,
                    a = We.current,
                    Be(We, c ? a & 1 | 2 : a & 1),
                    i) : (bt(i),
                    null);
            case 22:
            case 23:
                return Qd(),
                    c = i.memoizedState !== null,
                r !== null && r.memoizedState !== null !== c && (i.flags |= 8192),
                    c && (i.mode & 1) !== 0 ? (qt & 1073741824) !== 0 && (bt(i),
                    i.subtreeFlags & 6 && (i.flags |= 8192)) : bt(i),
                    null;
            case 24:
                return null;
            case 25:
                return null
        }
        throw Error(n(156, i.tag))
    }
    function mP(r, i) {
        switch (rd(i),
            i.tag) {
            case 1:
                return Lt(i.type) && fl(),
                    r = i.flags,
                    r & 65536 ? (i.flags = r & -65537 | 128,
                        i) : null;
            case 3:
                return ui(),
                    Ue(Ot),
                    Ue(xt),
                    gd(),
                    r = i.flags,
                    (r & 65536) !== 0 && (r & 128) === 0 ? (i.flags = r & -65537 | 128,
                        i) : null;
            case 5:
                return pd(i),
                    null;
            case 13:
                if (Ue(We),
                    r = i.memoizedState,
                r !== null && r.dehydrated !== null) {
                    if (i.alternate === null)
                        throw Error(n(340));
                    ii()
                }
                return r = i.flags,
                    r & 65536 ? (i.flags = r & -65537 | 128,
                        i) : null;
            case 19:
                return Ue(We),
                    null;
            case 4:
                return ui(),
                    null;
            case 10:
                return ud(i.type._context),
                    null;
            case 22:
            case 23:
                return Qd(),
                    null;
            case 24:
                return null;
            default:
                return null
        }
    }
    var Ol = !1
        , Et = !1
        , gP = typeof WeakSet == "function" ? WeakSet : Set
        , ue = null;
    function di(r, i) {
        var a = r.ref;
        if (a !== null)
            if (typeof a == "function")
                try {
                    a(null)
                } catch (c) {
                    Ke(r, i, c)
                }
            else
                a.current = null
    }
    function Dd(r, i, a) {
        try {
            a()
        } catch (c) {
            Ke(r, i, c)
        }
    }
    var Ty = !1;
    function yP(r, i) {
        if (Qc = Ja,
            r = sg(),
            Vc(r)) {
            if ("selectionStart"in r)
                var a = {
                    start: r.selectionStart,
                    end: r.selectionEnd
                };
            else
                e: {
                    a = (a = r.ownerDocument) && a.defaultView || window;
                    var c = a.getSelection && a.getSelection();
                    if (c && c.rangeCount !== 0) {
                        a = c.anchorNode;
                        var h = c.anchorOffset
                            , g = c.focusNode;
                        c = c.focusOffset;
                        try {
                            a.nodeType,
                                g.nodeType
                        } catch {
                            a = null;
                            break e
                        }
                        var C = 0
                            , A = -1
                            , N = -1
                            , V = 0
                            , G = 0
                            , Y = r
                            , Q = null;
                        t: for (; ; ) {
                            for (var oe; Y !== a || h !== 0 && Y.nodeType !== 3 || (A = C + h),
                            Y !== g || c !== 0 && Y.nodeType !== 3 || (N = C + c),
                            Y.nodeType === 3 && (C += Y.nodeValue.length),
                            (oe = Y.firstChild) !== null; )
                                Q = Y,
                                    Y = oe;
                            for (; ; ) {
                                if (Y === r)
                                    break t;
                                if (Q === a && ++V === h && (A = C),
                                Q === g && ++G === c && (N = C),
                                (oe = Y.nextSibling) !== null)
                                    break;
                                Y = Q,
                                    Q = Y.parentNode
                            }
                            Y = oe
                        }
                        a = A === -1 || N === -1 ? null : {
                            start: A,
                            end: N
                        }
                    } else
                        a = null
                }
            a = a || {
                start: 0,
                end: 0
            }
        } else
            a = null;
        for (Gc = {
            focusedElem: r,
            selectionRange: a
        },
                 Ja = !1,
                 ue = i; ue !== null; )
            if (i = ue,
                r = i.child,
            (i.subtreeFlags & 1028) !== 0 && r !== null)
                r.return = i,
                    ue = r;
            else
                for (; ue !== null; ) {
                    i = ue;
                    try {
                        var fe = i.alternate;
                        if ((i.flags & 1024) !== 0)
                            switch (i.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    break;
                                case 1:
                                    if (fe !== null) {
                                        var me = fe.memoizedProps
                                            , Ye = fe.memoizedState
                                            , F = i.stateNode
                                            , M = F.getSnapshotBeforeUpdate(i.elementType === i.type ? me : hn(i.type, me), Ye);
                                        F.__reactInternalSnapshotBeforeUpdate = M
                                    }
                                    break;
                                case 3:
                                    var B = i.stateNode.containerInfo;
                                    B.nodeType === 1 ? B.textContent = "" : B.nodeType === 9 && B.documentElement && B.removeChild(B.documentElement);
                                    break;
                                case 5:
                                case 6:
                                case 4:
                                case 17:
                                    break;
                                default:
                                    throw Error(n(163))
                            }
                    } catch (te) {
                        Ke(i, i.return, te)
                    }
                    if (r = i.sibling,
                    r !== null) {
                        r.return = i.return,
                            ue = r;
                        break
                    }
                    ue = i.return
                }
        return fe = Ty,
            Ty = !1,
            fe
    }
    function Bo(r, i, a) {
        var c = i.updateQueue;
        if (c = c !== null ? c.lastEffect : null,
        c !== null) {
            var h = c = c.next;
            do {
                if ((h.tag & r) === r) {
                    var g = h.destroy;
                    h.destroy = void 0,
                    g !== void 0 && Dd(i, a, g)
                }
                h = h.next
            } while (h !== c)
        }
    }
    function Ll(r, i) {
        if (i = i.updateQueue,
            i = i !== null ? i.lastEffect : null,
        i !== null) {
            var a = i = i.next;
            do {
                if ((a.tag & r) === r) {
                    var c = a.create;
                    a.destroy = c()
                }
                a = a.next
            } while (a !== i)
        }
    }
    function Id(r) {
        var i = r.ref;
        if (i !== null) {
            var a = r.stateNode;
            switch (r.tag) {
                case 5:
                    r = a;
                    break;
                default:
                    r = a
            }
            typeof i == "function" ? i(r) : i.current = r
        }
    }
    function ky(r) {
        var i = r.alternate;
        i !== null && (r.alternate = null,
            ky(i)),
            r.child = null,
            r.deletions = null,
            r.sibling = null,
        r.tag === 5 && (i = r.stateNode,
        i !== null && (delete i[kn],
            delete i[Ro],
            delete i[Zc],
            delete i[ZC],
            delete i[eP])),
            r.stateNode = null,
            r.return = null,
            r.dependencies = null,
            r.memoizedProps = null,
            r.memoizedState = null,
            r.pendingProps = null,
            r.stateNode = null,
            r.updateQueue = null
    }
    function Ry(r) {
        return r.tag === 5 || r.tag === 3 || r.tag === 4
    }
    function Ay(r) {
        e: for (; ; ) {
            for (; r.sibling === null; ) {
                if (r.return === null || Ry(r.return))
                    return null;
                r = r.return
            }
            for (r.sibling.return = r.return,
                     r = r.sibling; r.tag !== 5 && r.tag !== 6 && r.tag !== 18; ) {
                if (r.flags & 2 || r.child === null || r.tag === 4)
                    continue e;
                r.child.return = r,
                    r = r.child
            }
            if (!(r.flags & 2))
                return r.stateNode
        }
    }
    function Fd(r, i, a) {
        var c = r.tag;
        if (c === 5 || c === 6)
            r = r.stateNode,
                i ? a.nodeType === 8 ? a.parentNode.insertBefore(r, i) : a.insertBefore(r, i) : (a.nodeType === 8 ? (i = a.parentNode,
                    i.insertBefore(r, a)) : (i = a,
                    i.appendChild(r)),
                    a = a._reactRootContainer,
                a != null || i.onclick !== null || (i.onclick = cl));
        else if (c !== 4 && (r = r.child,
        r !== null))
            for (Fd(r, i, a),
                     r = r.sibling; r !== null; )
                Fd(r, i, a),
                    r = r.sibling
    }
    function Bd(r, i, a) {
        var c = r.tag;
        if (c === 5 || c === 6)
            r = r.stateNode,
                i ? a.insertBefore(r, i) : a.appendChild(r);
        else if (c !== 4 && (r = r.child,
        r !== null))
            for (Bd(r, i, a),
                     r = r.sibling; r !== null; )
                Bd(r, i, a),
                    r = r.sibling
    }
    var pt = null
        , pn = !1;
    function Pr(r, i, a) {
        for (a = a.child; a !== null; )
            _y(r, i, a),
                a = a.sibling
    }
    function _y(r, i, a) {
        if (Tn && typeof Tn.onCommitFiberUnmount == "function")
            try {
                Tn.onCommitFiberUnmount(qa, a)
            } catch {}
        switch (a.tag) {
            case 5:
                Et || di(a, i);
            case 6:
                var c = pt
                    , h = pn;
                pt = null,
                    Pr(r, i, a),
                    pt = c,
                    pn = h,
                pt !== null && (pn ? (r = pt,
                    a = a.stateNode,
                    r.nodeType === 8 ? r.parentNode.removeChild(a) : r.removeChild(a)) : pt.removeChild(a.stateNode));
                break;
            case 18:
                pt !== null && (pn ? (r = pt,
                    a = a.stateNode,
                    r.nodeType === 8 ? Jc(r.parentNode, a) : r.nodeType === 1 && Jc(r, a),
                    yo(r)) : Jc(pt, a.stateNode));
                break;
            case 4:
                c = pt,
                    h = pn,
                    pt = a.stateNode.containerInfo,
                    pn = !0,
                    Pr(r, i, a),
                    pt = c,
                    pn = h;
                break;
            case 0:
            case 11:
            case 14:
            case 15:
                if (!Et && (c = a.updateQueue,
                c !== null && (c = c.lastEffect,
                c !== null))) {
                    h = c = c.next;
                    do {
                        var g = h
                            , C = g.destroy;
                        g = g.tag,
                        C !== void 0 && ((g & 2) !== 0 || (g & 4) !== 0) && Dd(a, i, C),
                            h = h.next
                    } while (h !== c)
                }
                Pr(r, i, a);
                break;
            case 1:
                if (!Et && (di(a, i),
                    c = a.stateNode,
                typeof c.componentWillUnmount == "function"))
                    try {
                        c.props = a.memoizedProps,
                            c.state = a.memoizedState,
                            c.componentWillUnmount()
                    } catch (A) {
                        Ke(a, i, A)
                    }
                Pr(r, i, a);
                break;
            case 21:
                Pr(r, i, a);
                break;
            case 22:
                a.mode & 1 ? (Et = (c = Et) || a.memoizedState !== null,
                    Pr(r, i, a),
                    Et = c) : Pr(r, i, a);
                break;
            default:
                Pr(r, i, a)
        }
    }
    function Ny(r) {
        var i = r.updateQueue;
        if (i !== null) {
            r.updateQueue = null;
            var a = r.stateNode;
            a === null && (a = r.stateNode = new gP),
                i.forEach(function(c) {
                    var h = TP.bind(null, r, c);
                    a.has(c) || (a.add(c),
                        c.then(h, h))
                })
        }
    }
    function mn(r, i) {
        var a = i.deletions;
        if (a !== null)
            for (var c = 0; c < a.length; c++) {
                var h = a[c];
                try {
                    var g = r
                        , C = i
                        , A = C;
                    e: for (; A !== null; ) {
                        switch (A.tag) {
                            case 5:
                                pt = A.stateNode,
                                    pn = !1;
                                break e;
                            case 3:
                                pt = A.stateNode.containerInfo,
                                    pn = !0;
                                break e;
                            case 4:
                                pt = A.stateNode.containerInfo,
                                    pn = !0;
                                break e
                        }
                        A = A.return
                    }
                    if (pt === null)
                        throw Error(n(160));
                    _y(g, C, h),
                        pt = null,
                        pn = !1;
                    var N = h.alternate;
                    N !== null && (N.return = null),
                        h.return = null
                } catch (V) {
                    Ke(h, i, V)
                }
            }
        if (i.subtreeFlags & 12854)
            for (i = i.child; i !== null; )
                Oy(i, r),
                    i = i.sibling
    }
    function Oy(r, i) {
        var a = r.alternate
            , c = r.flags;
        switch (r.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
                if (mn(i, r),
                    _n(r),
                c & 4) {
                    try {
                        Bo(3, r, r.return),
                            Ll(3, r)
                    } catch (me) {
                        Ke(r, r.return, me)
                    }
                    try {
                        Bo(5, r, r.return)
                    } catch (me) {
                        Ke(r, r.return, me)
                    }
                }
                break;
            case 1:
                mn(i, r),
                    _n(r),
                c & 512 && a !== null && di(a, a.return);
                break;
            case 5:
                if (mn(i, r),
                    _n(r),
                c & 512 && a !== null && di(a, a.return),
                r.flags & 32) {
                    var h = r.stateNode;
                    try {
                        io(h, "")
                    } catch (me) {
                        Ke(r, r.return, me)
                    }
                }
                if (c & 4 && (h = r.stateNode,
                h != null)) {
                    var g = r.memoizedProps
                        , C = a !== null ? a.memoizedProps : g
                        , A = r.type
                        , N = r.updateQueue;
                    if (r.updateQueue = null,
                    N !== null)
                        try {
                            A === "input" && g.type === "radio" && g.name != null && dr(h, g),
                                gc(A, C);
                            var V = gc(A, g);
                            for (C = 0; C < N.length; C += 2) {
                                var G = N[C]
                                    , Y = N[C + 1];
                                G === "style" ? pm(h, Y) : G === "dangerouslySetInnerHTML" ? fm(h, Y) : G === "children" ? io(h, Y) : R(h, G, Y, V)
                            }
                            switch (A) {
                                case "input":
                                    Hn(h, g);
                                    break;
                                case "textarea":
                                    um(h, g);
                                    break;
                                case "select":
                                    var Q = h._wrapperState.wasMultiple;
                                    h._wrapperState.wasMultiple = !!g.multiple;
                                    var oe = g.value;
                                    oe != null ? Ws(h, !!g.multiple, oe, !1) : Q !== !!g.multiple && (g.defaultValue != null ? Ws(h, !!g.multiple, g.defaultValue, !0) : Ws(h, !!g.multiple, g.multiple ? [] : "", !1))
                            }
                            h[Ro] = g
                        } catch (me) {
                            Ke(r, r.return, me)
                        }
                }
                break;
            case 6:
                if (mn(i, r),
                    _n(r),
                c & 4) {
                    if (r.stateNode === null)
                        throw Error(n(162));
                    h = r.stateNode,
                        g = r.memoizedProps;
                    try {
                        h.nodeValue = g
                    } catch (me) {
                        Ke(r, r.return, me)
                    }
                }
                break;
            case 3:
                if (mn(i, r),
                    _n(r),
                c & 4 && a !== null && a.memoizedState.isDehydrated)
                    try {
                        yo(i.containerInfo)
                    } catch (me) {
                        Ke(r, r.return, me)
                    }
                break;
            case 4:
                mn(i, r),
                    _n(r);
                break;
            case 13:
                mn(i, r),
                    _n(r),
                    h = r.child,
                h.flags & 8192 && (g = h.memoizedState !== null,
                    h.stateNode.isHidden = g,
                !g || h.alternate !== null && h.alternate.memoizedState !== null || (zd = Xe())),
                c & 4 && Ny(r);
                break;
            case 22:
                if (G = a !== null && a.memoizedState !== null,
                    r.mode & 1 ? (Et = (V = Et) || G,
                        mn(i, r),
                        Et = V) : mn(i, r),
                    _n(r),
                c & 8192) {
                    if (V = r.memoizedState !== null,
                    (r.stateNode.isHidden = V) && !G && (r.mode & 1) !== 0)
                        for (ue = r,
                                 G = r.child; G !== null; ) {
                            for (Y = ue = G; ue !== null; ) {
                                switch (Q = ue,
                                    oe = Q.child,
                                    Q.tag) {
                                    case 0:
                                    case 11:
                                    case 14:
                                    case 15:
                                        Bo(4, Q, Q.return);
                                        break;
                                    case 1:
                                        di(Q, Q.return);
                                        var fe = Q.stateNode;
                                        if (typeof fe.componentWillUnmount == "function") {
                                            c = Q,
                                                a = Q.return;
                                            try {
                                                i = c,
                                                    fe.props = i.memoizedProps,
                                                    fe.state = i.memoizedState,
                                                    fe.componentWillUnmount()
                                            } catch (me) {
                                                Ke(c, a, me)
                                            }
                                        }
                                        break;
                                    case 5:
                                        di(Q, Q.return);
                                        break;
                                    case 22:
                                        if (Q.memoizedState !== null) {
                                            jy(Y);
                                            continue
                                        }
                                }
                                oe !== null ? (oe.return = Q,
                                    ue = oe) : jy(Y)
                            }
                            G = G.sibling
                        }
                    e: for (G = null,
                                Y = r; ; ) {
                        if (Y.tag === 5) {
                            if (G === null) {
                                G = Y;
                                try {
                                    h = Y.stateNode,
                                        V ? (g = h.style,
                                            typeof g.setProperty == "function" ? g.setProperty("display", "none", "important") : g.display = "none") : (A = Y.stateNode,
                                            N = Y.memoizedProps.style,
                                            C = N != null && N.hasOwnProperty("display") ? N.display : null,
                                            A.style.display = hm("display", C))
                                } catch (me) {
                                    Ke(r, r.return, me)
                                }
                            }
                        } else if (Y.tag === 6) {
                            if (G === null)
                                try {
                                    Y.stateNode.nodeValue = V ? "" : Y.memoizedProps
                                } catch (me) {
                                    Ke(r, r.return, me)
                                }
                        } else if ((Y.tag !== 22 && Y.tag !== 23 || Y.memoizedState === null || Y === r) && Y.child !== null) {
                            Y.child.return = Y,
                                Y = Y.child;
                            continue
                        }
                        if (Y === r)
                            break e;
                        for (; Y.sibling === null; ) {
                            if (Y.return === null || Y.return === r)
                                break e;
                            G === Y && (G = null),
                                Y = Y.return
                        }
                        G === Y && (G = null),
                            Y.sibling.return = Y.return,
                            Y = Y.sibling
                    }
                }
                break;
            case 19:
                mn(i, r),
                    _n(r),
                c & 4 && Ny(r);
                break;
            case 21:
                break;
            default:
                mn(i, r),
                    _n(r)
        }
    }
    function _n(r) {
        var i = r.flags;
        if (i & 2) {
            try {
                e: {
                    for (var a = r.return; a !== null; ) {
                        if (Ry(a)) {
                            var c = a;
                            break e
                        }
                        a = a.return
                    }
                    throw Error(n(160))
                }
                switch (c.tag) {
                    case 5:
                        var h = c.stateNode;
                        c.flags & 32 && (io(h, ""),
                            c.flags &= -33);
                        var g = Ay(r);
                        Bd(r, g, h);
                        break;
                    case 3:
                    case 4:
                        var C = c.stateNode.containerInfo
                            , A = Ay(r);
                        Fd(r, A, C);
                        break;
                    default:
                        throw Error(n(161))
                }
            } catch (N) {
                Ke(r, r.return, N)
            }
            r.flags &= -3
        }
        i & 4096 && (r.flags &= -4097)
    }
    function vP(r, i, a) {
        ue = r,
            Ly(r)
    }
    function Ly(r, i, a) {
        for (var c = (r.mode & 1) !== 0; ue !== null; ) {
            var h = ue
                , g = h.child;
            if (h.tag === 22 && c) {
                var C = h.memoizedState !== null || Ol;
                if (!C) {
                    var A = h.alternate
                        , N = A !== null && A.memoizedState !== null || Et;
                    A = Ol;
                    var V = Et;
                    if (Ol = C,
                    (Et = N) && !V)
                        for (ue = h; ue !== null; )
                            C = ue,
                                N = C.child,
                                C.tag === 22 && C.memoizedState !== null ? Dy(h) : N !== null ? (N.return = C,
                                    ue = N) : Dy(h);
                    for (; g !== null; )
                        ue = g,
                            Ly(g),
                            g = g.sibling;
                    ue = h,
                        Ol = A,
                        Et = V
                }
                My(r)
            } else
                (h.subtreeFlags & 8772) !== 0 && g !== null ? (g.return = h,
                    ue = g) : My(r)
        }
    }
    function My(r) {
        for (; ue !== null; ) {
            var i = ue;
            if ((i.flags & 8772) !== 0) {
                var a = i.alternate;
                try {
                    if ((i.flags & 8772) !== 0)
                        switch (i.tag) {
                            case 0:
                            case 11:
                            case 15:
                                Et || Ll(5, i);
                                break;
                            case 1:
                                var c = i.stateNode;
                                if (i.flags & 4 && !Et)
                                    if (a === null)
                                        c.componentDidMount();
                                    else {
                                        var h = i.elementType === i.type ? a.memoizedProps : hn(i.type, a.memoizedProps);
                                        c.componentDidUpdate(h, a.memoizedState, c.__reactInternalSnapshotBeforeUpdate)
                                    }
                                var g = i.updateQueue;
                                g !== null && jg(i, g, c);
                                break;
                            case 3:
                                var C = i.updateQueue;
                                if (C !== null) {
                                    if (a = null,
                                    i.child !== null)
                                        switch (i.child.tag) {
                                            case 5:
                                                a = i.child.stateNode;
                                                break;
                                            case 1:
                                                a = i.child.stateNode
                                        }
                                    jg(i, C, a)
                                }
                                break;
                            case 5:
                                var A = i.stateNode;
                                if (a === null && i.flags & 4) {
                                    a = A;
                                    var N = i.memoizedProps;
                                    switch (i.type) {
                                        case "button":
                                        case "input":
                                        case "select":
                                        case "textarea":
                                            N.autoFocus && a.focus();
                                            break;
                                        case "img":
                                            N.src && (a.src = N.src)
                                    }
                                }
                                break;
                            case 6:
                                break;
                            case 4:
                                break;
                            case 12:
                                break;
                            case 13:
                                if (i.memoizedState === null) {
                                    var V = i.alternate;
                                    if (V !== null) {
                                        var G = V.memoizedState;
                                        if (G !== null) {
                                            var Y = G.dehydrated;
                                            Y !== null && yo(Y)
                                        }
                                    }
                                }
                                break;
                            case 19:
                            case 17:
                            case 21:
                            case 22:
                            case 23:
                            case 25:
                                break;
                            default:
                                throw Error(n(163))
                        }
                    Et || i.flags & 512 && Id(i)
                } catch (Q) {
                    Ke(i, i.return, Q)
                }
            }
            if (i === r) {
                ue = null;
                break
            }
            if (a = i.sibling,
            a !== null) {
                a.return = i.return,
                    ue = a;
                break
            }
            ue = i.return
        }
    }
    function jy(r) {
        for (; ue !== null; ) {
            var i = ue;
            if (i === r) {
                ue = null;
                break
            }
            var a = i.sibling;
            if (a !== null) {
                a.return = i.return,
                    ue = a;
                break
            }
            ue = i.return
        }
    }
    function Dy(r) {
        for (; ue !== null; ) {
            var i = ue;
            try {
                switch (i.tag) {
                    case 0:
                    case 11:
                    case 15:
                        var a = i.return;
                        try {
                            Ll(4, i)
                        } catch (N) {
                            Ke(i, a, N)
                        }
                        break;
                    case 1:
                        var c = i.stateNode;
                        if (typeof c.componentDidMount == "function") {
                            var h = i.return;
                            try {
                                c.componentDidMount()
                            } catch (N) {
                                Ke(i, h, N)
                            }
                        }
                        var g = i.return;
                        try {
                            Id(i)
                        } catch (N) {
                            Ke(i, g, N)
                        }
                        break;
                    case 5:
                        var C = i.return;
                        try {
                            Id(i)
                        } catch (N) {
                            Ke(i, C, N)
                        }
                }
            } catch (N) {
                Ke(i, i.return, N)
            }
            if (i === r) {
                ue = null;
                break
            }
            var A = i.sibling;
            if (A !== null) {
                A.return = i.return,
                    ue = A;
                break
            }
            ue = i.return
        }
    }
    var wP = Math.ceil
        , Ml = _.ReactCurrentDispatcher
        , Vd = _.ReactCurrentOwner
        , nn = _.ReactCurrentBatchConfig
        , je = 0
        , dt = null
        , nt = null
        , mt = 0
        , qt = 0
        , fi = xr(0)
        , at = 0
        , Vo = null
        , fs = 0
        , jl = 0
        , Ud = 0
        , Uo = null
        , jt = null
        , zd = 0
        , hi = 1 / 0
        , Zn = null
        , Dl = !1
        , $d = null
        , Tr = null
        , Il = !1
        , kr = null
        , Fl = 0
        , zo = 0
        , Wd = null
        , Bl = -1
        , Vl = 0;
    function Rt() {
        return (je & 6) !== 0 ? Xe() : Bl !== -1 ? Bl : Bl = Xe()
    }
    function Rr(r) {
        return (r.mode & 1) === 0 ? 1 : (je & 2) !== 0 && mt !== 0 ? mt & -mt : nP.transition !== null ? (Vl === 0 && (Vl = Am()),
            Vl) : (r = Fe,
        r !== 0 || (r = window.event,
            r = r === void 0 ? 16 : Fm(r.type)),
            r)
    }
    function gn(r, i, a, c) {
        if (50 < zo)
            throw zo = 0,
                Wd = null,
                Error(n(185));
        fo(r, a, c),
        ((je & 2) === 0 || r !== dt) && (r === dt && ((je & 2) === 0 && (jl |= a),
        at === 4 && Ar(r, mt)),
            Dt(r, c),
        a === 1 && je === 0 && (i.mode & 1) === 0 && (hi = Xe() + 500,
        pl && br()))
    }
    function Dt(r, i) {
        var a = r.callbackNode;
        nC(r, i);
        var c = Ga(r, r === dt ? mt : 0);
        if (c === 0)
            a !== null && Tm(a),
                r.callbackNode = null,
                r.callbackPriority = 0;
        else if (i = c & -c,
        r.callbackPriority !== i) {
            if (a != null && Tm(a),
            i === 1)
                r.tag === 0 ? tP(Fy.bind(null, r)) : Eg(Fy.bind(null, r)),
                    YC(function() {
                        (je & 6) === 0 && br()
                    }),
                    a = null;
            else {
                switch (_m(c)) {
                    case 1:
                        a = Ec;
                        break;
                    case 4:
                        a = km;
                        break;
                    case 16:
                        a = Ha;
                        break;
                    case 536870912:
                        a = Rm;
                        break;
                    default:
                        a = Ha
                }
                a = qy(a, Iy.bind(null, r))
            }
            r.callbackPriority = i,
                r.callbackNode = a
        }
    }
    function Iy(r, i) {
        if (Bl = -1,
            Vl = 0,
        (je & 6) !== 0)
            throw Error(n(327));
        var a = r.callbackNode;
        if (pi() && r.callbackNode !== a)
            return null;
        var c = Ga(r, r === dt ? mt : 0);
        if (c === 0)
            return null;
        if ((c & 30) !== 0 || (c & r.expiredLanes) !== 0 || i)
            i = Ul(r, c);
        else {
            i = c;
            var h = je;
            je |= 2;
            var g = Vy();
            (dt !== r || mt !== i) && (Zn = null,
                hi = Xe() + 500,
                ps(r, i));
            do
                try {
                    bP();
                    break
                } catch (A) {
                    By(r, A)
                }
            while (!0);
            ld(),
                Ml.current = g,
                je = h,
                nt !== null ? i = 0 : (dt = null,
                    mt = 0,
                    i = at)
        }
        if (i !== 0) {
            if (i === 2 && (h = Cc(r),
            h !== 0 && (c = h,
                i = Hd(r, h))),
            i === 1)
                throw a = Vo,
                    ps(r, 0),
                    Ar(r, c),
                    Dt(r, Xe()),
                    a;
            if (i === 6)
                Ar(r, c);
            else {
                if (h = r.current.alternate,
                (c & 30) === 0 && !xP(h) && (i = Ul(r, c),
                i === 2 && (g = Cc(r),
                g !== 0 && (c = g,
                    i = Hd(r, g))),
                i === 1))
                    throw a = Vo,
                        ps(r, 0),
                        Ar(r, c),
                        Dt(r, Xe()),
                        a;
                switch (r.finishedWork = h,
                    r.finishedLanes = c,
                    i) {
                    case 0:
                    case 1:
                        throw Error(n(345));
                    case 2:
                        ms(r, jt, Zn);
                        break;
                    case 3:
                        if (Ar(r, c),
                        (c & 130023424) === c && (i = zd + 500 - Xe(),
                        10 < i)) {
                            if (Ga(r, 0) !== 0)
                                break;
                            if (h = r.suspendedLanes,
                            (h & c) !== c) {
                                Rt(),
                                    r.pingedLanes |= r.suspendedLanes & h;
                                break
                            }
                            r.timeoutHandle = Yc(ms.bind(null, r, jt, Zn), i);
                            break
                        }
                        ms(r, jt, Zn);
                        break;
                    case 4:
                        if (Ar(r, c),
                        (c & 4194240) === c)
                            break;
                        for (i = r.eventTimes,
                                 h = -1; 0 < c; ) {
                            var C = 31 - cn(c);
                            g = 1 << C,
                                C = i[C],
                            C > h && (h = C),
                                c &= ~g
                        }
                        if (c = h,
                            c = Xe() - c,
                            c = (120 > c ? 120 : 480 > c ? 480 : 1080 > c ? 1080 : 1920 > c ? 1920 : 3e3 > c ? 3e3 : 4320 > c ? 4320 : 1960 * wP(c / 1960)) - c,
                        10 < c) {
                            r.timeoutHandle = Yc(ms.bind(null, r, jt, Zn), c);
                            break
                        }
                        ms(r, jt, Zn);
                        break;
                    case 5:
                        ms(r, jt, Zn);
                        break;
                    default:
                        throw Error(n(329))
                }
            }
        }
        return Dt(r, Xe()),
            r.callbackNode === a ? Iy.bind(null, r) : null
    }
    function Hd(r, i) {
        var a = Uo;
        return r.current.memoizedState.isDehydrated && (ps(r, i).flags |= 256),
            r = Ul(r, i),
        r !== 2 && (i = jt,
            jt = a,
        i !== null && qd(i)),
            r
    }
    function qd(r) {
        jt === null ? jt = r : jt.push.apply(jt, r)
    }
    function xP(r) {
        for (var i = r; ; ) {
            if (i.flags & 16384) {
                var a = i.updateQueue;
                if (a !== null && (a = a.stores,
                a !== null))
                    for (var c = 0; c < a.length; c++) {
                        var h = a[c]
                            , g = h.getSnapshot;
                        h = h.value;
                        try {
                            if (!dn(g(), h))
                                return !1
                        } catch {
                            return !1
                        }
                    }
            }
            if (a = i.child,
            i.subtreeFlags & 16384 && a !== null)
                a.return = i,
                    i = a;
            else {
                if (i === r)
                    break;
                for (; i.sibling === null; ) {
                    if (i.return === null || i.return === r)
                        return !0;
                    i = i.return
                }
                i.sibling.return = i.return,
                    i = i.sibling
            }
        }
        return !0
    }
    function Ar(r, i) {
        for (i &= ~Ud,
                 i &= ~jl,
                 r.suspendedLanes |= i,
                 r.pingedLanes &= ~i,
                 r = r.expirationTimes; 0 < i; ) {
            var a = 31 - cn(i)
                , c = 1 << a;
            r[a] = -1,
                i &= ~c
        }
    }
    function Fy(r) {
        if ((je & 6) !== 0)
            throw Error(n(327));
        pi();
        var i = Ga(r, 0);
        if ((i & 1) === 0)
            return Dt(r, Xe()),
                null;
        var a = Ul(r, i);
        if (r.tag !== 0 && a === 2) {
            var c = Cc(r);
            c !== 0 && (i = c,
                a = Hd(r, c))
        }
        if (a === 1)
            throw a = Vo,
                ps(r, 0),
                Ar(r, i),
                Dt(r, Xe()),
                a;
        if (a === 6)
            throw Error(n(345));
        return r.finishedWork = r.current.alternate,
            r.finishedLanes = i,
            ms(r, jt, Zn),
            Dt(r, Xe()),
            null
    }
    function Kd(r, i) {
        var a = je;
        je |= 1;
        try {
            return r(i)
        } finally {
            je = a,
            je === 0 && (hi = Xe() + 500,
            pl && br())
        }
    }
    function hs(r) {
        kr !== null && kr.tag === 0 && (je & 6) === 0 && pi();
        var i = je;
        je |= 1;
        var a = nn.transition
            , c = Fe;
        try {
            if (nn.transition = null,
                Fe = 1,
                r)
                return r()
        } finally {
            Fe = c,
                nn.transition = a,
                je = i,
            (je & 6) === 0 && br()
        }
    }
    function Qd() {
        qt = fi.current,
            Ue(fi)
    }
    function ps(r, i) {
        r.finishedWork = null,
            r.finishedLanes = 0;
        var a = r.timeoutHandle;
        if (a !== -1 && (r.timeoutHandle = -1,
            XC(a)),
        nt !== null)
            for (a = nt.return; a !== null; ) {
                var c = a;
                switch (rd(c),
                    c.tag) {
                    case 1:
                        c = c.type.childContextTypes,
                        c != null && fl();
                        break;
                    case 3:
                        ui(),
                            Ue(Ot),
                            Ue(xt),
                            gd();
                        break;
                    case 5:
                        pd(c);
                        break;
                    case 4:
                        ui();
                        break;
                    case 13:
                        Ue(We);
                        break;
                    case 19:
                        Ue(We);
                        break;
                    case 10:
                        ud(c.type._context);
                        break;
                    case 22:
                    case 23:
                        Qd()
                }
                a = a.return
            }
        if (dt = r,
            nt = r = _r(r.current, null),
            mt = qt = i,
            at = 0,
            Vo = null,
            Ud = jl = fs = 0,
            jt = Uo = null,
        us !== null) {
            for (i = 0; i < us.length; i++)
                if (a = us[i],
                    c = a.interleaved,
                c !== null) {
                    a.interleaved = null;
                    var h = c.next
                        , g = a.pending;
                    if (g !== null) {
                        var C = g.next;
                        g.next = h,
                            c.next = C
                    }
                    a.pending = c
                }
            us = null
        }
        return r
    }
    function By(r, i) {
        do {
            var a = nt;
            try {
                if (ld(),
                    Cl.current = Rl,
                    Pl) {
                    for (var c = He.memoizedState; c !== null; ) {
                        var h = c.queue;
                        h !== null && (h.pending = null),
                            c = c.next
                    }
                    Pl = !1
                }
                if (ds = 0,
                    ct = ot = He = null,
                    Mo = !1,
                    jo = 0,
                    Vd.current = null,
                a === null || a.return === null) {
                    at = 1,
                        Vo = i,
                        nt = null;
                    break
                }
                e: {
                    var g = r
                        , C = a.return
                        , A = a
                        , N = i;
                    if (i = mt,
                        A.flags |= 32768,
                    N !== null && typeof N == "object" && typeof N.then == "function") {
                        var V = N
                            , G = A
                            , Y = G.tag;
                        if ((G.mode & 1) === 0 && (Y === 0 || Y === 11 || Y === 15)) {
                            var Q = G.alternate;
                            Q ? (G.updateQueue = Q.updateQueue,
                                G.memoizedState = Q.memoizedState,
                                G.lanes = Q.lanes) : (G.updateQueue = null,
                                G.memoizedState = null)
                        }
                        var oe = cy(C);
                        if (oe !== null) {
                            oe.flags &= -257,
                                dy(oe, C, A, g, i),
                            oe.mode & 1 && uy(g, V, i),
                                i = oe,
                                N = V;
                            var fe = i.updateQueue;
                            if (fe === null) {
                                var me = new Set;
                                me.add(N),
                                    i.updateQueue = me
                            } else
                                fe.add(N);
                            break e
                        } else {
                            if ((i & 1) === 0) {
                                uy(g, V, i),
                                    Gd();
                                break e
                            }
                            N = Error(n(426))
                        }
                    } else if ($e && A.mode & 1) {
                        var Ye = cy(C);
                        if (Ye !== null) {
                            (Ye.flags & 65536) === 0 && (Ye.flags |= 256),
                                dy(Ye, C, A, g, i),
                                od(ci(N, A));
                            break e
                        }
                    }
                    g = N = ci(N, A),
                    at !== 4 && (at = 2),
                        Uo === null ? Uo = [g] : Uo.push(g),
                        g = C;
                    do {
                        switch (g.tag) {
                            case 3:
                                g.flags |= 65536,
                                    i &= -i,
                                    g.lanes |= i;
                                var F = ay(g, N, i);
                                Mg(g, F);
                                break e;
                            case 1:
                                A = N;
                                var M = g.type
                                    , B = g.stateNode;
                                if ((g.flags & 128) === 0 && (typeof M.getDerivedStateFromError == "function" || B !== null && typeof B.componentDidCatch == "function" && (Tr === null || !Tr.has(B)))) {
                                    g.flags |= 65536,
                                        i &= -i,
                                        g.lanes |= i;
                                    var te = ly(g, A, i);
                                    Mg(g, te);
                                    break e
                                }
                        }
                        g = g.return
                    } while (g !== null)
                }
                zy(a)
            } catch (ge) {
                i = ge,
                nt === a && a !== null && (nt = a = a.return);
                continue
            }
            break
        } while (!0)
    }
    function Vy() {
        var r = Ml.current;
        return Ml.current = Rl,
            r === null ? Rl : r
    }
    function Gd() {
        (at === 0 || at === 3 || at === 2) && (at = 4),
        dt === null || (fs & 268435455) === 0 && (jl & 268435455) === 0 || Ar(dt, mt)
    }
    function Ul(r, i) {
        var a = je;
        je |= 2;
        var c = Vy();
        (dt !== r || mt !== i) && (Zn = null,
            ps(r, i));
        do
            try {
                SP();
                break
            } catch (h) {
                By(r, h)
            }
        while (!0);
        if (ld(),
            je = a,
            Ml.current = c,
        nt !== null)
            throw Error(n(261));
        return dt = null,
            mt = 0,
            at
    }
    function SP() {
        for (; nt !== null; )
            Uy(nt)
    }
    function bP() {
        for (; nt !== null && !KE(); )
            Uy(nt)
    }
    function Uy(r) {
        var i = Hy(r.alternate, r, qt);
        r.memoizedProps = r.pendingProps,
            i === null ? zy(r) : nt = i,
            Vd.current = null
    }
    function zy(r) {
        var i = r;
        do {
            var a = i.alternate;
            if (r = i.return,
            (i.flags & 32768) === 0) {
                if (a = pP(a, i, qt),
                a !== null) {
                    nt = a;
                    return
                }
            } else {
                if (a = mP(a, i),
                a !== null) {
                    a.flags &= 32767,
                        nt = a;
                    return
                }
                if (r !== null)
                    r.flags |= 32768,
                        r.subtreeFlags = 0,
                        r.deletions = null;
                else {
                    at = 6,
                        nt = null;
                    return
                }
            }
            if (i = i.sibling,
            i !== null) {
                nt = i;
                return
            }
            nt = i = r
        } while (i !== null);
        at === 0 && (at = 5)
    }
    function ms(r, i, a) {
        var c = Fe
            , h = nn.transition;
        try {
            nn.transition = null,
                Fe = 1,
                EP(r, i, a, c)
        } finally {
            nn.transition = h,
                Fe = c
        }
        return null
    }
    function EP(r, i, a, c) {
        do
            pi();
        while (kr !== null);
        if ((je & 6) !== 0)
            throw Error(n(327));
        a = r.finishedWork;
        var h = r.finishedLanes;
        if (a === null)
            return null;
        if (r.finishedWork = null,
            r.finishedLanes = 0,
        a === r.current)
            throw Error(n(177));
        r.callbackNode = null,
            r.callbackPriority = 0;
        var g = a.lanes | a.childLanes;
        if (rC(r, g),
        r === dt && (nt = dt = null,
            mt = 0),
        (a.subtreeFlags & 2064) === 0 && (a.flags & 2064) === 0 || Il || (Il = !0,
            qy(Ha, function() {
                return pi(),
                    null
            })),
            g = (a.flags & 15990) !== 0,
        (a.subtreeFlags & 15990) !== 0 || g) {
            g = nn.transition,
                nn.transition = null;
            var C = Fe;
            Fe = 1;
            var A = je;
            je |= 4,
                Vd.current = null,
                yP(r, a),
                Oy(a, r),
                $C(Gc),
                Ja = !!Qc,
                Gc = Qc = null,
                r.current = a,
                vP(a),
                QE(),
                je = A,
                Fe = C,
                nn.transition = g
        } else
            r.current = a;
        if (Il && (Il = !1,
            kr = r,
            Fl = h),
            g = r.pendingLanes,
        g === 0 && (Tr = null),
            YE(a.stateNode),
            Dt(r, Xe()),
        i !== null)
            for (c = r.onRecoverableError,
                     a = 0; a < i.length; a++)
                h = i[a],
                    c(h.value, {
                        componentStack: h.stack,
                        digest: h.digest
                    });
        if (Dl)
            throw Dl = !1,
                r = $d,
                $d = null,
                r;
        return (Fl & 1) !== 0 && r.tag !== 0 && pi(),
            g = r.pendingLanes,
            (g & 1) !== 0 ? r === Wd ? zo++ : (zo = 0,
                Wd = r) : zo = 0,
            br(),
            null
    }
    function pi() {
        if (kr !== null) {
            var r = _m(Fl)
                , i = nn.transition
                , a = Fe;
            try {
                if (nn.transition = null,
                    Fe = 16 > r ? 16 : r,
                kr === null)
                    var c = !1;
                else {
                    if (r = kr,
                        kr = null,
                        Fl = 0,
                    (je & 6) !== 0)
                        throw Error(n(331));
                    var h = je;
                    for (je |= 4,
                             ue = r.current; ue !== null; ) {
                        var g = ue
                            , C = g.child;
                        if ((ue.flags & 16) !== 0) {
                            var A = g.deletions;
                            if (A !== null) {
                                for (var N = 0; N < A.length; N++) {
                                    var V = A[N];
                                    for (ue = V; ue !== null; ) {
                                        var G = ue;
                                        switch (G.tag) {
                                            case 0:
                                            case 11:
                                            case 15:
                                                Bo(8, G, g)
                                        }
                                        var Y = G.child;
                                        if (Y !== null)
                                            Y.return = G,
                                                ue = Y;
                                        else
                                            for (; ue !== null; ) {
                                                G = ue;
                                                var Q = G.sibling
                                                    , oe = G.return;
                                                if (ky(G),
                                                G === V) {
                                                    ue = null;
                                                    break
                                                }
                                                if (Q !== null) {
                                                    Q.return = oe,
                                                        ue = Q;
                                                    break
                                                }
                                                ue = oe
                                            }
                                    }
                                }
                                var fe = g.alternate;
                                if (fe !== null) {
                                    var me = fe.child;
                                    if (me !== null) {
                                        fe.child = null;
                                        do {
                                            var Ye = me.sibling;
                                            me.sibling = null,
                                                me = Ye
                                        } while (me !== null)
                                    }
                                }
                                ue = g
                            }
                        }
                        if ((g.subtreeFlags & 2064) !== 0 && C !== null)
                            C.return = g,
                                ue = C;
                        else
                            e: for (; ue !== null; ) {
                                if (g = ue,
                                (g.flags & 2048) !== 0)
                                    switch (g.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            Bo(9, g, g.return)
                                    }
                                var F = g.sibling;
                                if (F !== null) {
                                    F.return = g.return,
                                        ue = F;
                                    break e
                                }
                                ue = g.return
                            }
                    }
                    var M = r.current;
                    for (ue = M; ue !== null; ) {
                        C = ue;
                        var B = C.child;
                        if ((C.subtreeFlags & 2064) !== 0 && B !== null)
                            B.return = C,
                                ue = B;
                        else
                            e: for (C = M; ue !== null; ) {
                                if (A = ue,
                                (A.flags & 2048) !== 0)
                                    try {
                                        switch (A.tag) {
                                            case 0:
                                            case 11:
                                            case 15:
                                                Ll(9, A)
                                        }
                                    } catch (ge) {
                                        Ke(A, A.return, ge)
                                    }
                                if (A === C) {
                                    ue = null;
                                    break e
                                }
                                var te = A.sibling;
                                if (te !== null) {
                                    te.return = A.return,
                                        ue = te;
                                    break e
                                }
                                ue = A.return
                            }
                    }
                    if (je = h,
                        br(),
                    Tn && typeof Tn.onPostCommitFiberRoot == "function")
                        try {
                            Tn.onPostCommitFiberRoot(qa, r)
                        } catch {}
                    c = !0
                }
                return c
            } finally {
                Fe = a,
                    nn.transition = i
            }
        }
        return !1
    }
    function $y(r, i, a) {
        i = ci(a, i),
            i = ay(r, i, 1),
            r = Cr(r, i, 1),
            i = Rt(),
        r !== null && (fo(r, 1, i),
            Dt(r, i))
    }
    function Ke(r, i, a) {
        if (r.tag === 3)
            $y(r, r, a);
        else
            for (; i !== null; ) {
                if (i.tag === 3) {
                    $y(i, r, a);
                    break
                } else if (i.tag === 1) {
                    var c = i.stateNode;
                    if (typeof i.type.getDerivedStateFromError == "function" || typeof c.componentDidCatch == "function" && (Tr === null || !Tr.has(c))) {
                        r = ci(a, r),
                            r = ly(i, r, 1),
                            i = Cr(i, r, 1),
                            r = Rt(),
                        i !== null && (fo(i, 1, r),
                            Dt(i, r));
                        break
                    }
                }
                i = i.return
            }
    }
    function CP(r, i, a) {
        var c = r.pingCache;
        c !== null && c.delete(i),
            i = Rt(),
            r.pingedLanes |= r.suspendedLanes & a,
        dt === r && (mt & a) === a && (at === 4 || at === 3 && (mt & 130023424) === mt && 500 > Xe() - zd ? ps(r, 0) : Ud |= a),
            Dt(r, i)
    }
    function Wy(r, i) {
        i === 0 && ((r.mode & 1) === 0 ? i = 1 : (i = Qa,
            Qa <<= 1,
        (Qa & 130023424) === 0 && (Qa = 4194304)));
        var a = Rt();
        r = Xn(r, i),
        r !== null && (fo(r, i, a),
            Dt(r, a))
    }
    function PP(r) {
        var i = r.memoizedState
            , a = 0;
        i !== null && (a = i.retryLane),
            Wy(r, a)
    }
    function TP(r, i) {
        var a = 0;
        switch (r.tag) {
            case 13:
                var c = r.stateNode
                    , h = r.memoizedState;
                h !== null && (a = h.retryLane);
                break;
            case 19:
                c = r.stateNode;
                break;
            default:
                throw Error(n(314))
        }
        c !== null && c.delete(i),
            Wy(r, a)
    }
    var Hy;
    Hy = function(r, i, a) {
        if (r !== null)
            if (r.memoizedProps !== i.pendingProps || Ot.current)
                Mt = !0;
            else {
                if ((r.lanes & a) === 0 && (i.flags & 128) === 0)
                    return Mt = !1,
                        hP(r, i, a);
                Mt = (r.flags & 131072) !== 0
            }
        else
            Mt = !1,
            $e && (i.flags & 1048576) !== 0 && Cg(i, gl, i.index);
        switch (i.lanes = 0,
            i.tag) {
            case 2:
                var c = i.type;
                Nl(r, i),
                    r = i.pendingProps;
                var h = ni(i, xt.current);
                li(i, a),
                    h = wd(null, i, c, r, h, a);
                var g = xd();
                return i.flags |= 1,
                    typeof h == "object" && h !== null && typeof h.render == "function" && h.$$typeof === void 0 ? (i.tag = 1,
                        i.memoizedState = null,
                        i.updateQueue = null,
                        Lt(c) ? (g = !0,
                            hl(i)) : g = !1,
                        i.memoizedState = h.state !== null && h.state !== void 0 ? h.state : null,
                        fd(i),
                        h.updater = Al,
                        i.stateNode = h,
                        h._reactInternals = i,
                        Td(i, c, r, a),
                        i = _d(null, i, c, !0, g, a)) : (i.tag = 0,
                    $e && g && nd(i),
                        kt(null, i, h, a),
                        i = i.child),
                    i;
            case 16:
                c = i.elementType;
                e: {
                    switch (Nl(r, i),
                        r = i.pendingProps,
                        h = c._init,
                        c = h(c._payload),
                        i.type = c,
                        h = i.tag = RP(c),
                        r = hn(c, r),
                        h) {
                        case 0:
                            i = Ad(null, i, c, r, a);
                            break e;
                        case 1:
                            i = yy(null, i, c, r, a);
                            break e;
                        case 11:
                            i = fy(null, i, c, r, a);
                            break e;
                        case 14:
                            i = hy(null, i, c, hn(c.type, r), a);
                            break e
                    }
                    throw Error(n(306, c, ""))
                }
                return i;
            case 0:
                return c = i.type,
                    h = i.pendingProps,
                    h = i.elementType === c ? h : hn(c, h),
                    Ad(r, i, c, h, a);
            case 1:
                return c = i.type,
                    h = i.pendingProps,
                    h = i.elementType === c ? h : hn(c, h),
                    yy(r, i, c, h, a);
            case 3:
                e: {
                    if (vy(i),
                    r === null)
                        throw Error(n(387));
                    c = i.pendingProps,
                        g = i.memoizedState,
                        h = g.element,
                        Lg(r, i),
                        bl(i, c, null, a);
                    var C = i.memoizedState;
                    if (c = C.element,
                        g.isDehydrated)
                        if (g = {
                            element: c,
                            isDehydrated: !1,
                            cache: C.cache,
                            pendingSuspenseBoundaries: C.pendingSuspenseBoundaries,
                            transitions: C.transitions
                        },
                            i.updateQueue.baseState = g,
                            i.memoizedState = g,
                        i.flags & 256) {
                            h = ci(Error(n(423)), i),
                                i = wy(r, i, c, a, h);
                            break e
                        } else if (c !== h) {
                            h = ci(Error(n(424)), i),
                                i = wy(r, i, c, a, h);
                            break e
                        } else
                            for (Ht = wr(i.stateNode.containerInfo.firstChild),
                                     Wt = i,
                                     $e = !0,
                                     fn = null,
                                     a = Ng(i, null, c, a),
                                     i.child = a; a; )
                                a.flags = a.flags & -3 | 4096,
                                    a = a.sibling;
                    else {
                        if (ii(),
                        c === h) {
                            i = Jn(r, i, a);
                            break e
                        }
                        kt(r, i, c, a)
                    }
                    i = i.child
                }
                return i;
            case 5:
                return Dg(i),
                r === null && id(i),
                    c = i.type,
                    h = i.pendingProps,
                    g = r !== null ? r.memoizedProps : null,
                    C = h.children,
                    Xc(c, h) ? C = null : g !== null && Xc(c, g) && (i.flags |= 32),
                    gy(r, i),
                    kt(r, i, C, a),
                    i.child;
            case 6:
                return r === null && id(i),
                    null;
            case 13:
                return xy(r, i, a);
            case 4:
                return hd(i, i.stateNode.containerInfo),
                    c = i.pendingProps,
                    r === null ? i.child = oi(i, null, c, a) : kt(r, i, c, a),
                    i.child;
            case 11:
                return c = i.type,
                    h = i.pendingProps,
                    h = i.elementType === c ? h : hn(c, h),
                    fy(r, i, c, h, a);
            case 7:
                return kt(r, i, i.pendingProps, a),
                    i.child;
            case 8:
                return kt(r, i, i.pendingProps.children, a),
                    i.child;
            case 12:
                return kt(r, i, i.pendingProps.children, a),
                    i.child;
            case 10:
                e: {
                    if (c = i.type._context,
                        h = i.pendingProps,
                        g = i.memoizedProps,
                        C = h.value,
                        Be(wl, c._currentValue),
                        c._currentValue = C,
                    g !== null)
                        if (dn(g.value, C)) {
                            if (g.children === h.children && !Ot.current) {
                                i = Jn(r, i, a);
                                break e
                            }
                        } else
                            for (g = i.child,
                                 g !== null && (g.return = i); g !== null; ) {
                                var A = g.dependencies;
                                if (A !== null) {
                                    C = g.child;
                                    for (var N = A.firstContext; N !== null; ) {
                                        if (N.context === c) {
                                            if (g.tag === 1) {
                                                N = Yn(-1, a & -a),
                                                    N.tag = 2;
                                                var V = g.updateQueue;
                                                if (V !== null) {
                                                    V = V.shared;
                                                    var G = V.pending;
                                                    G === null ? N.next = N : (N.next = G.next,
                                                        G.next = N),
                                                        V.pending = N
                                                }
                                            }
                                            g.lanes |= a,
                                                N = g.alternate,
                                            N !== null && (N.lanes |= a),
                                                cd(g.return, a, i),
                                                A.lanes |= a;
                                            break
                                        }
                                        N = N.next
                                    }
                                } else if (g.tag === 10)
                                    C = g.type === i.type ? null : g.child;
                                else if (g.tag === 18) {
                                    if (C = g.return,
                                    C === null)
                                        throw Error(n(341));
                                    C.lanes |= a,
                                        A = C.alternate,
                                    A !== null && (A.lanes |= a),
                                        cd(C, a, i),
                                        C = g.sibling
                                } else
                                    C = g.child;
                                if (C !== null)
                                    C.return = g;
                                else
                                    for (C = g; C !== null; ) {
                                        if (C === i) {
                                            C = null;
                                            break
                                        }
                                        if (g = C.sibling,
                                        g !== null) {
                                            g.return = C.return,
                                                C = g;
                                            break
                                        }
                                        C = C.return
                                    }
                                g = C
                            }
                    kt(r, i, h.children, a),
                        i = i.child
                }
                return i;
            case 9:
                return h = i.type,
                    c = i.pendingProps.children,
                    li(i, a),
                    h = en(h),
                    c = c(h),
                    i.flags |= 1,
                    kt(r, i, c, a),
                    i.child;
            case 14:
                return c = i.type,
                    h = hn(c, i.pendingProps),
                    h = hn(c.type, h),
                    hy(r, i, c, h, a);
            case 15:
                return py(r, i, i.type, i.pendingProps, a);
            case 17:
                return c = i.type,
                    h = i.pendingProps,
                    h = i.elementType === c ? h : hn(c, h),
                    Nl(r, i),
                    i.tag = 1,
                    Lt(c) ? (r = !0,
                        hl(i)) : r = !1,
                    li(i, a),
                    iy(i, c, h),
                    Td(i, c, h, a),
                    _d(null, i, c, !0, r, a);
            case 19:
                return by(r, i, a);
            case 22:
                return my(r, i, a)
        }
        throw Error(n(156, i.tag))
    }
    ;
    function qy(r, i) {
        return Pm(r, i)
    }
    function kP(r, i, a, c) {
        this.tag = r,
            this.key = a,
            this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
            this.index = 0,
            this.ref = null,
            this.pendingProps = i,
            this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
            this.mode = c,
            this.subtreeFlags = this.flags = 0,
            this.deletions = null,
            this.childLanes = this.lanes = 0,
            this.alternate = null
    }
    function rn(r, i, a, c) {
        return new kP(r,i,a,c)
    }
    function Xd(r) {
        return r = r.prototype,
            !(!r || !r.isReactComponent)
    }
    function RP(r) {
        if (typeof r == "function")
            return Xd(r) ? 1 : 0;
        if (r != null) {
            if (r = r.$$typeof,
            r === z)
                return 11;
            if (r === ie)
                return 14
        }
        return 2
    }
    function _r(r, i) {
        var a = r.alternate;
        return a === null ? (a = rn(r.tag, i, r.key, r.mode),
            a.elementType = r.elementType,
            a.type = r.type,
            a.stateNode = r.stateNode,
            a.alternate = r,
            r.alternate = a) : (a.pendingProps = i,
            a.type = r.type,
            a.flags = 0,
            a.subtreeFlags = 0,
            a.deletions = null),
            a.flags = r.flags & 14680064,
            a.childLanes = r.childLanes,
            a.lanes = r.lanes,
            a.child = r.child,
            a.memoizedProps = r.memoizedProps,
            a.memoizedState = r.memoizedState,
            a.updateQueue = r.updateQueue,
            i = r.dependencies,
            a.dependencies = i === null ? null : {
                lanes: i.lanes,
                firstContext: i.firstContext
            },
            a.sibling = r.sibling,
            a.index = r.index,
            a.ref = r.ref,
            a
    }
    function zl(r, i, a, c, h, g) {
        var C = 2;
        if (c = r,
        typeof r == "function")
            Xd(r) && (C = 1);
        else if (typeof r == "string")
            C = 5;
        else
            e: switch (r) {
                case $:
                    return gs(a.children, h, g, i);
                case O:
                    C = 8,
                        h |= 8;
                    break;
                case W:
                    return r = rn(12, a, i, h | 2),
                        r.elementType = W,
                        r.lanes = g,
                        r;
                case J:
                    return r = rn(13, a, i, h),
                        r.elementType = J,
                        r.lanes = g,
                        r;
                case ae:
                    return r = rn(19, a, i, h),
                        r.elementType = ae,
                        r.lanes = g,
                        r;
                case re:
                    return $l(a, h, g, i);
                default:
                    if (typeof r == "object" && r !== null)
                        switch (r.$$typeof) {
                            case q:
                                C = 10;
                                break e;
                            case X:
                                C = 9;
                                break e;
                            case z:
                                C = 11;
                                break e;
                            case ie:
                                C = 14;
                                break e;
                            case ne:
                                C = 16,
                                    c = null;
                                break e
                        }
                    throw Error(n(130, r == null ? r : typeof r, ""))
            }
        return i = rn(C, a, i, h),
            i.elementType = r,
            i.type = c,
            i.lanes = g,
            i
    }
    function gs(r, i, a, c) {
        return r = rn(7, r, c, i),
            r.lanes = a,
            r
    }
    function $l(r, i, a, c) {
        return r = rn(22, r, c, i),
            r.elementType = re,
            r.lanes = a,
            r.stateNode = {
                isHidden: !1
            },
            r
    }
    function Yd(r, i, a) {
        return r = rn(6, r, null, i),
            r.lanes = a,
            r
    }
    function Jd(r, i, a) {
        return i = rn(4, r.children !== null ? r.children : [], r.key, i),
            i.lanes = a,
            i.stateNode = {
                containerInfo: r.containerInfo,
                pendingChildren: null,
                implementation: r.implementation
            },
            i
    }
    function AP(r, i, a, c, h) {
        this.tag = i,
            this.containerInfo = r,
            this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
            this.timeoutHandle = -1,
            this.callbackNode = this.pendingContext = this.context = null,
            this.callbackPriority = 0,
            this.eventTimes = Pc(0),
            this.expirationTimes = Pc(-1),
            this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
            this.entanglements = Pc(0),
            this.identifierPrefix = c,
            this.onRecoverableError = h,
            this.mutableSourceEagerHydrationData = null
    }
    function Zd(r, i, a, c, h, g, C, A, N) {
        return r = new AP(r,i,a,A,N),
            i === 1 ? (i = 1,
            g === !0 && (i |= 8)) : i = 0,
            g = rn(3, null, null, i),
            r.current = g,
            g.stateNode = r,
            g.memoizedState = {
                element: c,
                isDehydrated: a,
                cache: null,
                transitions: null,
                pendingSuspenseBoundaries: null
            },
            fd(g),
            r
    }
    function _P(r, i, a) {
        var c = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        return {
            $$typeof: H,
            key: c == null ? null : "" + c,
            children: r,
            containerInfo: i,
            implementation: a
        }
    }
    function Ky(r) {
        if (!r)
            return Sr;
        r = r._reactInternals;
        e: {
            if (ss(r) !== r || r.tag !== 1)
                throw Error(n(170));
            var i = r;
            do {
                switch (i.tag) {
                    case 3:
                        i = i.stateNode.context;
                        break e;
                    case 1:
                        if (Lt(i.type)) {
                            i = i.stateNode.__reactInternalMemoizedMergedChildContext;
                            break e
                        }
                }
                i = i.return
            } while (i !== null);
            throw Error(n(171))
        }
        if (r.tag === 1) {
            var a = r.type;
            if (Lt(a))
                return Sg(r, a, i)
        }
        return i
    }
    function Qy(r, i, a, c, h, g, C, A, N) {
        return r = Zd(a, c, !0, r, h, g, C, A, N),
            r.context = Ky(null),
            a = r.current,
            c = Rt(),
            h = Rr(a),
            g = Yn(c, h),
            g.callback = i ?? null,
            Cr(a, g, h),
            r.current.lanes = h,
            fo(r, h, c),
            Dt(r, c),
            r
    }
    function Wl(r, i, a, c) {
        var h = i.current
            , g = Rt()
            , C = Rr(h);
        return a = Ky(a),
            i.context === null ? i.context = a : i.pendingContext = a,
            i = Yn(g, C),
            i.payload = {
                element: r
            },
            c = c === void 0 ? null : c,
        c !== null && (i.callback = c),
            r = Cr(h, i, C),
        r !== null && (gn(r, h, C, g),
            Sl(r, h, C)),
            C
    }
    function Hl(r) {
        if (r = r.current,
            !r.child)
            return null;
        switch (r.child.tag) {
            case 5:
                return r.child.stateNode;
            default:
                return r.child.stateNode
        }
    }
    function Gy(r, i) {
        if (r = r.memoizedState,
        r !== null && r.dehydrated !== null) {
            var a = r.retryLane;
            r.retryLane = a !== 0 && a < i ? a : i
        }
    }
    function ef(r, i) {
        Gy(r, i),
        (r = r.alternate) && Gy(r, i)
    }
    function NP() {
        return null
    }
    var Xy = typeof reportError == "function" ? reportError : function(r) {
            console.error(r)
        }
    ;
    function tf(r) {
        this._internalRoot = r
    }
    ql.prototype.render = tf.prototype.render = function(r) {
        var i = this._internalRoot;
        if (i === null)
            throw Error(n(409));
        Wl(r, i, null, null)
    }
        ,
        ql.prototype.unmount = tf.prototype.unmount = function() {
            var r = this._internalRoot;
            if (r !== null) {
                this._internalRoot = null;
                var i = r.containerInfo;
                hs(function() {
                    Wl(null, r, null, null)
                }),
                    i[qn] = null
            }
        }
    ;
    function ql(r) {
        this._internalRoot = r
    }
    ql.prototype.unstable_scheduleHydration = function(r) {
        if (r) {
            var i = Lm();
            r = {
                blockedOn: null,
                target: r,
                priority: i
            };
            for (var a = 0; a < gr.length && i !== 0 && i < gr[a].priority; a++)
                ;
            gr.splice(a, 0, r),
            a === 0 && Dm(r)
        }
    }
    ;
    function nf(r) {
        return !(!r || r.nodeType !== 1 && r.nodeType !== 9 && r.nodeType !== 11)
    }
    function Kl(r) {
        return !(!r || r.nodeType !== 1 && r.nodeType !== 9 && r.nodeType !== 11 && (r.nodeType !== 8 || r.nodeValue !== " react-mount-point-unstable "))
    }
    function Yy() {}
    function OP(r, i, a, c, h) {
        if (h) {
            if (typeof c == "function") {
                var g = c;
                c = function() {
                    var V = Hl(C);
                    g.call(V)
                }
            }
            var C = Qy(i, c, r, 0, null, !1, !1, "", Yy);
            return r._reactRootContainer = C,
                r[qn] = C.current,
                To(r.nodeType === 8 ? r.parentNode : r),
                hs(),
                C
        }
        for (; h = r.lastChild; )
            r.removeChild(h);
        if (typeof c == "function") {
            var A = c;
            c = function() {
                var V = Hl(N);
                A.call(V)
            }
        }
        var N = Zd(r, 0, !1, null, null, !1, !1, "", Yy);
        return r._reactRootContainer = N,
            r[qn] = N.current,
            To(r.nodeType === 8 ? r.parentNode : r),
            hs(function() {
                Wl(i, N, a, c)
            }),
            N
    }
    function Ql(r, i, a, c, h) {
        var g = a._reactRootContainer;
        if (g) {
            var C = g;
            if (typeof h == "function") {
                var A = h;
                h = function() {
                    var N = Hl(C);
                    A.call(N)
                }
            }
            Wl(i, C, r, h)
        } else
            C = OP(a, i, r, h, c);
        return Hl(C)
    }
    Nm = function(r) {
        switch (r.tag) {
            case 3:
                var i = r.stateNode;
                if (i.current.memoizedState.isDehydrated) {
                    var a = co(i.pendingLanes);
                    a !== 0 && (Tc(i, a | 1),
                        Dt(i, Xe()),
                    (je & 6) === 0 && (hi = Xe() + 500,
                        br()))
                }
                break;
            case 13:
                hs(function() {
                    var c = Xn(r, 1);
                    if (c !== null) {
                        var h = Rt();
                        gn(c, r, 1, h)
                    }
                }),
                    ef(r, 1)
        }
    }
        ,
        kc = function(r) {
            if (r.tag === 13) {
                var i = Xn(r, 134217728);
                if (i !== null) {
                    var a = Rt();
                    gn(i, r, 134217728, a)
                }
                ef(r, 134217728)
            }
        }
        ,
        Om = function(r) {
            if (r.tag === 13) {
                var i = Rr(r)
                    , a = Xn(r, i);
                if (a !== null) {
                    var c = Rt();
                    gn(a, r, i, c)
                }
                ef(r, i)
            }
        }
        ,
        Lm = function() {
            return Fe
        }
        ,
        Mm = function(r, i) {
            var a = Fe;
            try {
                return Fe = r,
                    i()
            } finally {
                Fe = a
            }
        }
        ,
        wc = function(r, i, a) {
            switch (i) {
                case "input":
                    if (Hn(r, a),
                        i = a.name,
                    a.type === "radio" && i != null) {
                        for (a = r; a.parentNode; )
                            a = a.parentNode;
                        for (a = a.querySelectorAll("input[name=" + JSON.stringify("" + i) + '][type="radio"]'),
                                 i = 0; i < a.length; i++) {
                            var c = a[i];
                            if (c !== r && c.form === r.form) {
                                var h = dl(c);
                                if (!h)
                                    throw Error(n(90));
                                Ne(c),
                                    Hn(c, h)
                            }
                        }
                    }
                    break;
                case "textarea":
                    um(r, a);
                    break;
                case "select":
                    i = a.value,
                    i != null && Ws(r, !!a.multiple, i, !1)
            }
        }
        ,
        vm = Kd,
        wm = hs;
    var LP = {
        usingClientEntryPoint: !1,
        Events: [Ao, ei, dl, gm, ym, Kd]
    }
        , $o = {
        findFiberByHostInstance: is,
        bundleType: 0,
        version: "18.3.1",
        rendererPackageName: "react-dom"
    }
        , MP = {
        bundleType: $o.bundleType,
        version: $o.version,
        rendererPackageName: $o.rendererPackageName,
        rendererConfig: $o.rendererConfig,
        overrideHookState: null,
        overrideHookStateDeletePath: null,
        overrideHookStateRenamePath: null,
        overrideProps: null,
        overridePropsDeletePath: null,
        overridePropsRenamePath: null,
        setErrorHandler: null,
        setSuspenseHandler: null,
        scheduleUpdate: null,
        currentDispatcherRef: _.ReactCurrentDispatcher,
        findHostInstanceByFiber: function(r) {
            return r = Em(r),
                r === null ? null : r.stateNode
        },
        findFiberByHostInstance: $o.findFiberByHostInstance || NP,
        findHostInstancesForRefresh: null,
        scheduleRefresh: null,
        scheduleRoot: null,
        setRefreshHandler: null,
        getCurrentFiber: null,
        reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
    };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
        var Gl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!Gl.isDisabled && Gl.supportsFiber)
            try {
                qa = Gl.inject(MP),
                    Tn = Gl
            } catch {}
    }
    return It.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = LP,
        It.createPortal = function(r, i) {
            var a = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
            if (!nf(i))
                throw Error(n(200));
            return _P(r, i, null, a)
        }
        ,
        It.createRoot = function(r, i) {
            if (!nf(r))
                throw Error(n(299));
            var a = !1
                , c = ""
                , h = Xy;
            return i != null && (i.unstable_strictMode === !0 && (a = !0),
            i.identifierPrefix !== void 0 && (c = i.identifierPrefix),
            i.onRecoverableError !== void 0 && (h = i.onRecoverableError)),
                i = Zd(r, 1, !1, null, null, a, !1, c, h),
                r[qn] = i.current,
                To(r.nodeType === 8 ? r.parentNode : r),
                new tf(i)
        }
        ,
        It.findDOMNode = function(r) {
            if (r == null)
                return null;
            if (r.nodeType === 1)
                return r;
            var i = r._reactInternals;
            if (i === void 0)
                throw typeof r.render == "function" ? Error(n(188)) : (r = Object.keys(r).join(","),
                    Error(n(268, r)));
            return r = Em(i),
                r = r === null ? null : r.stateNode,
                r
        }
        ,
        It.flushSync = function(r) {
            return hs(r)
        }
        ,
        It.hydrate = function(r, i, a) {
            if (!Kl(i))
                throw Error(n(200));
            return Ql(null, r, i, !0, a)
        }
        ,
        It.hydrateRoot = function(r, i, a) {
            if (!nf(r))
                throw Error(n(405));
            var c = a != null && a.hydratedSources || null
                , h = !1
                , g = ""
                , C = Xy;
            if (a != null && (a.unstable_strictMode === !0 && (h = !0),
            a.identifierPrefix !== void 0 && (g = a.identifierPrefix),
            a.onRecoverableError !== void 0 && (C = a.onRecoverableError)),
                i = Qy(i, null, r, 1, a ?? null, h, !1, g, C),
                r[qn] = i.current,
                To(r),
                c)
                for (r = 0; r < c.length; r++)
                    a = c[r],
                        h = a._getVersion,
                        h = h(a._source),
                        i.mutableSourceEagerHydrationData == null ? i.mutableSourceEagerHydrationData = [a, h] : i.mutableSourceEagerHydrationData.push(a, h);
            return new ql(i)
        }
        ,
        It.render = function(r, i, a) {
            if (!Kl(i))
                throw Error(n(200));
            return Ql(null, r, i, !1, a)
        }
        ,
        It.unmountComponentAtNode = function(r) {
            if (!Kl(r))
                throw Error(n(40));
            return r._reactRootContainer ? (hs(function() {
                Ql(null, null, r, !1, function() {
                    r._reactRootContainer = null,
                        r[qn] = null
                })
            }),
                !0) : !1
        }
        ,
        It.unstable_batchedUpdates = Kd,
        It.unstable_renderSubtreeIntoContainer = function(r, i, a, c) {
            if (!Kl(a))
                throw Error(n(200));
            if (r == null || r._reactInternals === void 0)
                throw Error(n(38));
            return Ql(r, i, a, !1, c)
        }
        ,
        It.version = "18.3.1-next-f1338f8080-20240426",
        It
}
var ov;
function ox() {
    if (ov)
        return af.exports;
    ov = 1;
    function e() {
        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
            try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)
            } catch (t) {
                console.error(t)
            }
    }
    return e(),
        af.exports = zP(),
        af.exports
}
var av;
function $P() {
    if (av)
        return Yl;
    av = 1;
    var e = ox();
    return Yl.createRoot = e.createRoot,
        Yl.hydrateRoot = e.hydrateRoot,
        Yl
}
var WP = $P();
const HP = Xh(WP)
    , qP = 20
    , KP = 1e6
    , sr = {
    ADD_TOAST: "ADD_TOAST",
    UPDATE_TOAST: "UPDATE_TOAST",
    DISMISS_TOAST: "DISMISS_TOAST",
    REMOVE_TOAST: "REMOVE_TOAST"
};
let cf = 0;
function QP() {
    return cf = (cf + 1) % Number.MAX_VALUE,
        cf.toString()
}
const df = new Map
    , lv = e => {
    if (df.has(e))
        return;
    const t = setTimeout( () => {
            df.delete(e),
                na({
                    type: sr.REMOVE_TOAST,
                    toastId: e
                })
        }
        , KP);
    df.set(e, t)
}
    , GP = (e, t) => {
    switch (t.type) {
        case sr.ADD_TOAST:
            return {
                ...e,
                toasts: [t.toast, ...e.toasts].slice(0, qP)
            };
        case sr.UPDATE_TOAST:
            return {
                ...e,
                toasts: e.toasts.map(n => n.id === t.toast.id ? {
                    ...n,
                    ...t.toast
                } : n)
            };
        case sr.DISMISS_TOAST:
        {
            const {toastId: n} = t;
            return n ? lv(n) : e.toasts.forEach(s => {
                    lv(s.id)
                }
            ),
                {
                    ...e,
                    toasts: e.toasts.map(s => s.id === n || n === void 0 ? {
                        ...s,
                        open: !1
                    } : s)
                }
        }
        case sr.REMOVE_TOAST:
            return t.toastId === void 0 ? {
                ...e,
                toasts: []
            } : {
                ...e,
                toasts: e.toasts.filter(n => n.id !== t.toastId)
            }
    }
}
    , fu = [];
let hu = {
    toasts: []
};
function na(e) {
    hu = GP(hu, e),
        fu.forEach(t => {
                t(hu)
            }
        )
}
function XP({...e}) {
    const t = QP()
        , n = o => na({
        type: sr.UPDATE_TOAST,
        toast: {
            ...o,
            id: t
        }
    })
        , s = () => na({
        type: sr.DISMISS_TOAST,
        toastId: t
    });
    return na({
        type: sr.ADD_TOAST,
        toast: {
            ...e,
            id: t,
            open: !0,
            onOpenChange: o => {
                o || s()
            }
        }
    }),
        {
            id: t,
            dismiss: s,
            update: n
        }
}
function YP() {
    const [e,t] = P.useState(hu);
    return P.useEffect( () => (fu.push(t),
            () => {
                const n = fu.indexOf(t);
                n > -1 && fu.splice(n, 1)
            }
    ), [e]),
        {
            ...e,
            toast: XP,
            dismiss: n => na({
                type: sr.DISMISS_TOAST,
                toastId: n
            })
        }
}
function ax(e) {
    var t, n, s = "";
    if (typeof e == "string" || typeof e == "number")
        s += e;
    else if (typeof e == "object")
        if (Array.isArray(e)) {
            var o = e.length;
            for (t = 0; t < o; t++)
                e[t] && (n = ax(e[t])) && (s && (s += " "),
                    s += n)
        } else
            for (n in e)
                e[n] && (s && (s += " "),
                    s += n);
    return s
}
function lx() {
    for (var e, t, n = 0, s = "", o = arguments.length; n < o; n++)
        (e = arguments[n]) && (t = ax(e)) && (s && (s += " "),
            s += t);
    return s
}
const uv = e => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e
    , cv = lx
    , Zh = (e, t) => n => {
        var s;
        if ((t == null ? void 0 : t.variants) == null)
            return cv(e, n == null ? void 0 : n.class, n == null ? void 0 : n.className);
        const {variants: o, defaultVariants: u} = t
            , l = Object.keys(o).map(p => {
                const m = n == null ? void 0 : n[p]
                    , y = u == null ? void 0 : u[p];
                if (m === null)
                    return null;
                const v = uv(m) || uv(y);
                return o[p][v]
            }
        )
            , d = n && Object.entries(n).reduce( (p, m) => {
                let[y,v] = m;
                return v === void 0 || (p[y] = v),
                    p
            }
            , {})
            , f = t == null || (s = t.compoundVariants) === null || s === void 0 ? void 0 : s.reduce( (p, m) => {
                let {class: y, className: v, ...S} = m;
                return Object.entries(S).every(E => {
                        let[w,x] = E;
                        return Array.isArray(x) ? x.includes({
                            ...u,
                            ...d
                        }[w]) : {
                            ...u,
                            ...d
                        }[w] === x
                    }
                ) ? [...p, y, v] : p
            }
            , []);
        return cv(e, l, f, n == null ? void 0 : n.class, n == null ? void 0 : n.className)
    }
;
/**
 * @license lucide-react v0.475.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const JP = e => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase()
    , ux = (...e) => e.filter( (t, n, s) => !!t && t.trim() !== "" && s.indexOf(t) === n).join(" ").trim();
/**
 * @license lucide-react v0.475.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var ZP = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.475.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const eT = P.forwardRef( ({color: e="currentColor", size: t=24, strokeWidth: n=2, absoluteStrokeWidth: s, className: o="", children: u, iconNode: l, ...d}, f) => P.createElement("svg", {
    ref: f,
    ...ZP,
    width: t,
    height: t,
    stroke: e,
    strokeWidth: s ? Number(n) * 24 / Number(t) : n,
    className: ux("lucide", o),
    ...d
}, [...l.map( ([p,m]) => P.createElement(p, m)), ...Array.isArray(u) ? u : [u]]));
/**
 * @license lucide-react v0.475.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Yt = (e, t) => {
        const n = P.forwardRef( ({className: s, ...o}, u) => P.createElement(eT, {
            ref: u,
            iconNode: t,
            className: ux(`lucide-${JP(e)}`, s),
            ...o
        }));
        return n.displayName = `${e}`,
            n
    }
;
/**
 * @license lucide-react v0.475.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const tT = [["path", {
    d: "m12 19-7-7 7-7",
    key: "1l729n"
}], ["path", {
    d: "M19 12H5",
    key: "x3x0zl"
}]]
    , dv = Yt("ArrowLeft", tT);
/**
 * @license lucide-react v0.475.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const nT = [["path", {
    d: "M20 6 9 17l-5-5",
    key: "1gmf2c"
}]]
    , rT = Yt("Check", nT);
/**
 * @license lucide-react v0.475.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const sT = [["path", {
    d: "m6 9 6 6 6-6",
    key: "qrunsl"
}]]
    , cx = Yt("ChevronDown", sT);
/**
 * @license lucide-react v0.475.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const iT = [["path", {
    d: "m18 15-6-6-6 6",
    key: "153udz"
}]]
    , oT = Yt("ChevronUp", iT);
/**
 * @license lucide-react v0.475.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const aT = [["path", {
    d: "M21.801 10A10 10 0 1 1 17 3.335",
    key: "yps3ct"
}], ["path", {
    d: "m9 11 3 3L22 4",
    key: "1pflzl"
}]]
    , lT = Yt("CircleCheckBig", aT);
/**
 * @license lucide-react v0.475.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const uT = [["circle", {
    cx: "12",
    cy: "12",
    r: "10",
    key: "1mglay"
}], ["path", {
    d: "M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20",
    key: "13o1zl"
}], ["path", {
    d: "M2 12h20",
    key: "9i4pu4"
}]]
    , cT = Yt("Globe", uT);
/**
 * @license lucide-react v0.475.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const dT = [["circle", {
    cx: "12",
    cy: "12",
    r: "10",
    key: "1mglay"
}], ["path", {
    d: "M12 16v-4",
    key: "1dtifu"
}], ["path", {
    d: "M12 8h.01",
    key: "e9boi3"
}]]
    , fT = Yt("Info", dT);
/**
 * @license lucide-react v0.475.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const hT = [["rect", {
    width: "20",
    height: "16",
    x: "2",
    y: "4",
    rx: "2",
    key: "18n3k1"
}], ["path", {
    d: "m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7",
    key: "1ocrg3"
}]]
    , dx = Yt("Mail", hT);
/**
 * @license lucide-react v0.475.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const pT = [["path", {
    d: "M20 10c0 4.993-5.539 10.193-7.399 11.799a1 1 0 0 1-1.202 0C9.539 20.193 4 14.993 4 10a8 8 0 0 1 16 0",
    key: "1r0f0z"
}], ["circle", {
    cx: "12",
    cy: "10",
    r: "3",
    key: "ilqhr7"
}]]
    , fx = Yt("MapPin", pT);
/**
 * @license lucide-react v0.475.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const mT = [["path", {
    d: "M7.9 20A9 9 0 1 0 4 16.1L2 22Z",
    key: "vv11sd"
}]]
    , Ru = Yt("MessageCircle", mT);
/**
 * @license lucide-react v0.475.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const gT = [["path", {
    d: "M11 21.73a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73z",
    key: "1a0edw"
}], ["path", {
    d: "M12 22V12",
    key: "d0xqtd"
}], ["polyline", {
    points: "3.29 7 12 12 20.71 7",
    key: "ousv84"
}], ["path", {
    d: "m7.5 4.27 9 5.15",
    key: "1c824w"
}]]
    , Au = Yt("Package", gT);
/**
 * @license lucide-react v0.475.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const yT = [["path", {
    d: "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z",
    key: "foiqr5"
}]]
    , ca = Yt("Phone", yT);
/**
 * @license lucide-react v0.475.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const vT = [["path", {
        d: "M18 6 6 18",
        key: "1bl5f8"
    }], ["path", {
        d: "m6 6 12 12",
        key: "d8bk6v"
    }]]
    , wT = Yt("X", vT)
    , ep = "-"
    , xT = e => {
        const t = bT(e)
            , {conflictingClassGroups: n, conflictingClassGroupModifiers: s} = e;
        return {
            getClassGroupId: l => {
                const d = l.split(ep);
                return d[0] === "" && d.length !== 1 && d.shift(),
                hx(d, t) || ST(l)
            }
            ,
            getConflictingClassGroupIds: (l, d) => {
                const f = n[l] || [];
                return d && s[l] ? [...f, ...s[l]] : f
            }
        }
    }
    , hx = (e, t) => {
        var l;
        if (e.length === 0)
            return t.classGroupId;
        const n = e[0]
            , s = t.nextPart.get(n)
            , o = s ? hx(e.slice(1), s) : void 0;
        if (o)
            return o;
        if (t.validators.length === 0)
            return;
        const u = e.join(ep);
        return (l = t.validators.find( ({validator: d}) => d(u))) == null ? void 0 : l.classGroupId
    }
    , fv = /^\[(.+)\]$/
    , ST = e => {
        if (fv.test(e)) {
            const t = fv.exec(e)[1]
                , n = t == null ? void 0 : t.substring(0, t.indexOf(":"));
            if (n)
                return "arbitrary.." + n
        }
    }
    , bT = e => {
        const {theme: t, classGroups: n} = e
            , s = {
            nextPart: new Map,
            validators: []
        };
        for (const o in n)
            Wf(n[o], s, o, t);
        return s
    }
    , Wf = (e, t, n, s) => {
        e.forEach(o => {
                if (typeof o == "string") {
                    const u = o === "" ? t : hv(t, o);
                    u.classGroupId = n;
                    return
                }
                if (typeof o == "function") {
                    if (ET(o)) {
                        Wf(o(s), t, n, s);
                        return
                    }
                    t.validators.push({
                        validator: o,
                        classGroupId: n
                    });
                    return
                }
                Object.entries(o).forEach( ([u,l]) => {
                        Wf(l, hv(t, u), n, s)
                    }
                )
            }
        )
    }
    , hv = (e, t) => {
        let n = e;
        return t.split(ep).forEach(s => {
                n.nextPart.has(s) || n.nextPart.set(s, {
                    nextPart: new Map,
                    validators: []
                }),
                    n = n.nextPart.get(s)
            }
        ),
            n
    }
    , ET = e => e.isThemeGetter
    , CT = e => {
        if (e < 1)
            return {
                get: () => {}
                ,
                set: () => {}
            };
        let t = 0
            , n = new Map
            , s = new Map;
        const o = (u, l) => {
                n.set(u, l),
                    t++,
                t > e && (t = 0,
                    s = n,
                    n = new Map)
            }
        ;
        return {
            get(u) {
                let l = n.get(u);
                if (l !== void 0)
                    return l;
                if ((l = s.get(u)) !== void 0)
                    return o(u, l),
                        l
            },
            set(u, l) {
                n.has(u) ? n.set(u, l) : o(u, l)
            }
        }
    }
    , Hf = "!"
    , qf = ":"
    , PT = qf.length
    , TT = e => {
        const {prefix: t, experimentalParseClassName: n} = e;
        let s = o => {
                const u = [];
                let l = 0, d = 0, f = 0, p;
                for (let E = 0; E < o.length; E++) {
                    let w = o[E];
                    if (l === 0 && d === 0) {
                        if (w === qf) {
                            u.push(o.slice(f, E)),
                                f = E + PT;
                            continue
                        }
                        if (w === "/") {
                            p = E;
                            continue
                        }
                    }
                    w === "[" ? l++ : w === "]" ? l-- : w === "(" ? d++ : w === ")" && d--
                }
                const m = u.length === 0 ? o : o.substring(f)
                    , y = kT(m)
                    , v = y !== m
                    , S = p && p > f ? p - f : void 0;
                return {
                    modifiers: u,
                    hasImportantModifier: v,
                    baseClassName: y,
                    maybePostfixModifierPosition: S
                }
            }
        ;
        if (t) {
            const o = t + qf
                , u = s;
            s = l => l.startsWith(o) ? u(l.substring(o.length)) : {
                isExternal: !0,
                modifiers: [],
                hasImportantModifier: !1,
                baseClassName: l,
                maybePostfixModifierPosition: void 0
            }
        }
        if (n) {
            const o = s;
            s = u => n({
                className: u,
                parseClassName: o
            })
        }
        return s
    }
    , kT = e => e.endsWith(Hf) ? e.substring(0, e.length - 1) : e.startsWith(Hf) ? e.substring(1) : e
    , RT = e => {
        const t = Object.fromEntries(e.orderSensitiveModifiers.map(s => [s, !0]));
        return s => {
            if (s.length <= 1)
                return s;
            const o = [];
            let u = [];
            return s.forEach(l => {
                    l[0] === "[" || t[l] ? (o.push(...u.sort(), l),
                        u = []) : u.push(l)
                }
            ),
                o.push(...u.sort()),
                o
        }
    }
    , AT = e => ({
        cache: CT(e.cacheSize),
        parseClassName: TT(e),
        sortModifiers: RT(e),
        ...xT(e)
    })
    , _T = /\s+/
    , NT = (e, t) => {
        const {parseClassName: n, getClassGroupId: s, getConflictingClassGroupIds: o, sortModifiers: u} = t
            , l = []
            , d = e.trim().split(_T);
        let f = "";
        for (let p = d.length - 1; p >= 0; p -= 1) {
            const m = d[p]
                , {isExternal: y, modifiers: v, hasImportantModifier: S, baseClassName: E, maybePostfixModifierPosition: w} = n(m);
            if (y) {
                f = m + (f.length > 0 ? " " + f : f);
                continue
            }
            let x = !!w
                , T = s(x ? E.substring(0, w) : E);
            if (!T) {
                if (!x) {
                    f = m + (f.length > 0 ? " " + f : f);
                    continue
                }
                if (T = s(E),
                    !T) {
                    f = m + (f.length > 0 ? " " + f : f);
                    continue
                }
                x = !1
            }
            const k = u(v).join(":")
                , R = S ? k + Hf : k
                , _ = R + T;
            if (l.includes(_))
                continue;
            l.push(_);
            const D = o(T, x);
            for (let H = 0; H < D.length; ++H) {
                const $ = D[H];
                l.push(R + $)
            }
            f = m + (f.length > 0 ? " " + f : f)
        }
        return f
    }
;
function OT() {
    let e = 0, t, n, s = "";
    for (; e < arguments.length; )
        (t = arguments[e++]) && (n = px(t)) && (s && (s += " "),
            s += n);
    return s
}
const px = e => {
        if (typeof e == "string")
            return e;
        let t, n = "";
        for (let s = 0; s < e.length; s++)
            e[s] && (t = px(e[s])) && (n && (n += " "),
                n += t);
        return n
    }
;
function LT(e, ...t) {
    let n, s, o, u = l;
    function l(f) {
        const p = t.reduce( (m, y) => y(m), e());
        return n = AT(p),
            s = n.cache.get,
            o = n.cache.set,
            u = d,
            d(f)
    }
    function d(f) {
        const p = s(f);
        if (p)
            return p;
        const m = NT(f, n);
        return o(f, m),
            m
    }
    return function() {
        return u(OT.apply(null, arguments))
    }
}
const lt = e => {
    const t = n => n[e] || [];
    return t.isThemeGetter = !0,
        t
}
    , mx = /^\[(?:(\w[\w-]*):)?(.+)\]$/i
    , gx = /^\((?:(\w[\w-]*):)?(.+)\)$/i
    , MT = /^\d+\/\d+$/
    , jT = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/
    , DT = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/
    , IT = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/
    , FT = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/
    , BT = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/
    , mi = e => MT.test(e)
    , Re = e => !!e && !Number.isNaN(Number(e))
    , Or = e => !!e && Number.isInteger(Number(e))
    , ff = e => e.endsWith("%") && Re(e.slice(0, -1))
    , er = e => jT.test(e)
    , VT = () => !0
    , UT = e => DT.test(e) && !IT.test(e)
    , yx = () => !1
    , zT = e => FT.test(e)
    , $T = e => BT.test(e)
    , WT = e => !he(e) && !pe(e)
    , HT = e => Ki(e, xx, yx)
    , he = e => mx.test(e)
    , ys = e => Ki(e, Sx, UT)
    , hf = e => Ki(e, XT, Re)
    , pv = e => Ki(e, vx, yx)
    , qT = e => Ki(e, wx, $T)
    , Jl = e => Ki(e, bx, zT)
    , pe = e => gx.test(e)
    , Ho = e => Qi(e, Sx)
    , KT = e => Qi(e, YT)
    , mv = e => Qi(e, vx)
    , QT = e => Qi(e, xx)
    , GT = e => Qi(e, wx)
    , Zl = e => Qi(e, bx, !0)
    , Ki = (e, t, n) => {
    const s = mx.exec(e);
    return s ? s[1] ? t(s[1]) : n(s[2]) : !1
}
    , Qi = (e, t, n=!1) => {
    const s = gx.exec(e);
    return s ? s[1] ? t(s[1]) : n : !1
}
    , vx = e => e === "position" || e === "percentage"
    , wx = e => e === "image" || e === "url"
    , xx = e => e === "length" || e === "size" || e === "bg-size"
    , Sx = e => e === "length"
    , XT = e => e === "number"
    , YT = e => e === "family-name"
    , bx = e => e === "shadow"
    , JT = () => {
    const e = lt("color")
        , t = lt("font")
        , n = lt("text")
        , s = lt("font-weight")
        , o = lt("tracking")
        , u = lt("leading")
        , l = lt("breakpoint")
        , d = lt("container")
        , f = lt("spacing")
        , p = lt("radius")
        , m = lt("shadow")
        , y = lt("inset-shadow")
        , v = lt("text-shadow")
        , S = lt("drop-shadow")
        , E = lt("blur")
        , w = lt("perspective")
        , x = lt("aspect")
        , T = lt("ease")
        , k = lt("animate")
        , R = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"]
        , _ = () => ["center", "top", "bottom", "left", "right", "top-left", "left-top", "top-right", "right-top", "bottom-right", "right-bottom", "bottom-left", "left-bottom"]
        , D = () => [..._(), pe, he]
        , H = () => ["auto", "hidden", "clip", "visible", "scroll"]
        , $ = () => ["auto", "contain", "none"]
        , O = () => [pe, he, f]
        , W = () => [mi, "full", "auto", ...O()]
        , q = () => [Or, "none", "subgrid", pe, he]
        , X = () => ["auto", {
        span: ["full", Or, pe, he]
    }, Or, pe, he]
        , z = () => [Or, "auto", pe, he]
        , J = () => ["auto", "min", "max", "fr", pe, he]
        , ae = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"]
        , ie = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"]
        , ne = () => ["auto", ...O()]
        , re = () => [mi, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...O()]
        , I = () => [e, pe, he]
        , se = () => [..._(), mv, pv, {
        position: [pe, he]
    }]
        , ee = () => ["no-repeat", {
        repeat: ["", "x", "y", "space", "round"]
    }]
        , j = () => ["auto", "cover", "contain", QT, HT, {
        size: [pe, he]
    }]
        , K = () => [ff, Ho, ys]
        , ce = () => ["", "none", "full", p, pe, he]
        , de = () => ["", Re, Ho, ys]
        , be = () => ["solid", "dashed", "dotted", "double"]
        , Te = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"]
        , Z = () => [Re, ff, mv, pv]
        , ye = () => ["", "none", E, pe, he]
        , Ce = () => ["none", Re, pe, he]
        , Pe = () => ["none", Re, pe, he]
        , _e = () => [Re, pe, he]
        , Ne = () => [mi, "full", ...O()];
    return {
        cacheSize: 500,
        theme: {
            animate: ["spin", "ping", "pulse", "bounce"],
            aspect: ["video"],
            blur: [er],
            breakpoint: [er],
            color: [VT],
            container: [er],
            "drop-shadow": [er],
            ease: ["in", "out", "in-out"],
            font: [WT],
            "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"],
            "inset-shadow": [er],
            leading: ["none", "tight", "snug", "normal", "relaxed", "loose"],
            perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"],
            radius: [er],
            shadow: [er],
            spacing: ["px", Re],
            text: [er],
            "text-shadow": [er],
            tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"]
        },
        classGroups: {
            aspect: [{
                aspect: ["auto", "square", mi, he, pe, x]
            }],
            container: ["container"],
            columns: [{
                columns: [Re, he, pe, d]
            }],
            "break-after": [{
                "break-after": R()
            }],
            "break-before": [{
                "break-before": R()
            }],
            "break-inside": [{
                "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
            }],
            "box-decoration": [{
                "box-decoration": ["slice", "clone"]
            }],
            box: [{
                box: ["border", "content"]
            }],
            display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
            sr: ["sr-only", "not-sr-only"],
            float: [{
                float: ["right", "left", "none", "start", "end"]
            }],
            clear: [{
                clear: ["left", "right", "both", "none", "start", "end"]
            }],
            isolation: ["isolate", "isolation-auto"],
            "object-fit": [{
                object: ["contain", "cover", "fill", "none", "scale-down"]
            }],
            "object-position": [{
                object: D()
            }],
            overflow: [{
                overflow: H()
            }],
            "overflow-x": [{
                "overflow-x": H()
            }],
            "overflow-y": [{
                "overflow-y": H()
            }],
            overscroll: [{
                overscroll: $()
            }],
            "overscroll-x": [{
                "overscroll-x": $()
            }],
            "overscroll-y": [{
                "overscroll-y": $()
            }],
            position: ["static", "fixed", "absolute", "relative", "sticky"],
            inset: [{
                inset: W()
            }],
            "inset-x": [{
                "inset-x": W()
            }],
            "inset-y": [{
                "inset-y": W()
            }],
            start: [{
                start: W()
            }],
            end: [{
                end: W()
            }],
            top: [{
                top: W()
            }],
            right: [{
                right: W()
            }],
            bottom: [{
                bottom: W()
            }],
            left: [{
                left: W()
            }],
            visibility: ["visible", "invisible", "collapse"],
            z: [{
                z: [Or, "auto", pe, he]
            }],
            basis: [{
                basis: [mi, "full", "auto", d, ...O()]
            }],
            "flex-direction": [{
                flex: ["row", "row-reverse", "col", "col-reverse"]
            }],
            "flex-wrap": [{
                flex: ["nowrap", "wrap", "wrap-reverse"]
            }],
            flex: [{
                flex: [Re, mi, "auto", "initial", "none", he]
            }],
            grow: [{
                grow: ["", Re, pe, he]
            }],
            shrink: [{
                shrink: ["", Re, pe, he]
            }],
            order: [{
                order: [Or, "first", "last", "none", pe, he]
            }],
            "grid-cols": [{
                "grid-cols": q()
            }],
            "col-start-end": [{
                col: X()
            }],
            "col-start": [{
                "col-start": z()
            }],
            "col-end": [{
                "col-end": z()
            }],
            "grid-rows": [{
                "grid-rows": q()
            }],
            "row-start-end": [{
                row: X()
            }],
            "row-start": [{
                "row-start": z()
            }],
            "row-end": [{
                "row-end": z()
            }],
            "grid-flow": [{
                "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
            }],
            "auto-cols": [{
                "auto-cols": J()
            }],
            "auto-rows": [{
                "auto-rows": J()
            }],
            gap: [{
                gap: O()
            }],
            "gap-x": [{
                "gap-x": O()
            }],
            "gap-y": [{
                "gap-y": O()
            }],
            "justify-content": [{
                justify: [...ae(), "normal"]
            }],
            "justify-items": [{
                "justify-items": [...ie(), "normal"]
            }],
            "justify-self": [{
                "justify-self": ["auto", ...ie()]
            }],
            "align-content": [{
                content: ["normal", ...ae()]
            }],
            "align-items": [{
                items: [...ie(), {
                    baseline: ["", "last"]
                }]
            }],
            "align-self": [{
                self: ["auto", ...ie(), {
                    baseline: ["", "last"]
                }]
            }],
            "place-content": [{
                "place-content": ae()
            }],
            "place-items": [{
                "place-items": [...ie(), "baseline"]
            }],
            "place-self": [{
                "place-self": ["auto", ...ie()]
            }],
            p: [{
                p: O()
            }],
            px: [{
                px: O()
            }],
            py: [{
                py: O()
            }],
            ps: [{
                ps: O()
            }],
            pe: [{
                pe: O()
            }],
            pt: [{
                pt: O()
            }],
            pr: [{
                pr: O()
            }],
            pb: [{
                pb: O()
            }],
            pl: [{
                pl: O()
            }],
            m: [{
                m: ne()
            }],
            mx: [{
                mx: ne()
            }],
            my: [{
                my: ne()
            }],
            ms: [{
                ms: ne()
            }],
            me: [{
                me: ne()
            }],
            mt: [{
                mt: ne()
            }],
            mr: [{
                mr: ne()
            }],
            mb: [{
                mb: ne()
            }],
            ml: [{
                ml: ne()
            }],
            "space-x": [{
                "space-x": O()
            }],
            "space-x-reverse": ["space-x-reverse"],
            "space-y": [{
                "space-y": O()
            }],
            "space-y-reverse": ["space-y-reverse"],
            size: [{
                size: re()
            }],
            w: [{
                w: [d, "screen", ...re()]
            }],
            "min-w": [{
                "min-w": [d, "screen", "none", ...re()]
            }],
            "max-w": [{
                "max-w": [d, "screen", "none", "prose", {
                    screen: [l]
                }, ...re()]
            }],
            h: [{
                h: ["screen", "lh", ...re()]
            }],
            "min-h": [{
                "min-h": ["screen", "lh", "none", ...re()]
            }],
            "max-h": [{
                "max-h": ["screen", "lh", ...re()]
            }],
            "font-size": [{
                text: ["base", n, Ho, ys]
            }],
            "font-smoothing": ["antialiased", "subpixel-antialiased"],
            "font-style": ["italic", "not-italic"],
            "font-weight": [{
                font: [s, pe, hf]
            }],
            "font-stretch": [{
                "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", ff, he]
            }],
            "font-family": [{
                font: [KT, he, t]
            }],
            "fvn-normal": ["normal-nums"],
            "fvn-ordinal": ["ordinal"],
            "fvn-slashed-zero": ["slashed-zero"],
            "fvn-figure": ["lining-nums", "oldstyle-nums"],
            "fvn-spacing": ["proportional-nums", "tabular-nums"],
            "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
            tracking: [{
                tracking: [o, pe, he]
            }],
            "line-clamp": [{
                "line-clamp": [Re, "none", pe, hf]
            }],
            leading: [{
                leading: [u, ...O()]
            }],
            "list-image": [{
                "list-image": ["none", pe, he]
            }],
            "list-style-position": [{
                list: ["inside", "outside"]
            }],
            "list-style-type": [{
                list: ["disc", "decimal", "none", pe, he]
            }],
            "text-alignment": [{
                text: ["left", "center", "right", "justify", "start", "end"]
            }],
            "placeholder-color": [{
                placeholder: I()
            }],
            "text-color": [{
                text: I()
            }],
            "text-decoration": ["underline", "overline", "line-through", "no-underline"],
            "text-decoration-style": [{
                decoration: [...be(), "wavy"]
            }],
            "text-decoration-thickness": [{
                decoration: [Re, "from-font", "auto", pe, ys]
            }],
            "text-decoration-color": [{
                decoration: I()
            }],
            "underline-offset": [{
                "underline-offset": [Re, "auto", pe, he]
            }],
            "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
            "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
            "text-wrap": [{
                text: ["wrap", "nowrap", "balance", "pretty"]
            }],
            indent: [{
                indent: O()
            }],
            "vertical-align": [{
                align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", pe, he]
            }],
            whitespace: [{
                whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
            }],
            break: [{
                break: ["normal", "words", "all", "keep"]
            }],
            wrap: [{
                wrap: ["break-word", "anywhere", "normal"]
            }],
            hyphens: [{
                hyphens: ["none", "manual", "auto"]
            }],
            content: [{
                content: ["none", pe, he]
            }],
            "bg-attachment": [{
                bg: ["fixed", "local", "scroll"]
            }],
            "bg-clip": [{
                "bg-clip": ["border", "padding", "content", "text"]
            }],
            "bg-origin": [{
                "bg-origin": ["border", "padding", "content"]
            }],
            "bg-position": [{
                bg: se()
            }],
            "bg-repeat": [{
                bg: ee()
            }],
            "bg-size": [{
                bg: j()
            }],
            "bg-image": [{
                bg: ["none", {
                    linear: [{
                        to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
                    }, Or, pe, he],
                    radial: ["", pe, he],
                    conic: [Or, pe, he]
                }, GT, qT]
            }],
            "bg-color": [{
                bg: I()
            }],
            "gradient-from-pos": [{
                from: K()
            }],
            "gradient-via-pos": [{
                via: K()
            }],
            "gradient-to-pos": [{
                to: K()
            }],
            "gradient-from": [{
                from: I()
            }],
            "gradient-via": [{
                via: I()
            }],
            "gradient-to": [{
                to: I()
            }],
            rounded: [{
                rounded: ce()
            }],
            "rounded-s": [{
                "rounded-s": ce()
            }],
            "rounded-e": [{
                "rounded-e": ce()
            }],
            "rounded-t": [{
                "rounded-t": ce()
            }],
            "rounded-r": [{
                "rounded-r": ce()
            }],
            "rounded-b": [{
                "rounded-b": ce()
            }],
            "rounded-l": [{
                "rounded-l": ce()
            }],
            "rounded-ss": [{
                "rounded-ss": ce()
            }],
            "rounded-se": [{
                "rounded-se": ce()
            }],
            "rounded-ee": [{
                "rounded-ee": ce()
            }],
            "rounded-es": [{
                "rounded-es": ce()
            }],
            "rounded-tl": [{
                "rounded-tl": ce()
            }],
            "rounded-tr": [{
                "rounded-tr": ce()
            }],
            "rounded-br": [{
                "rounded-br": ce()
            }],
            "rounded-bl": [{
                "rounded-bl": ce()
            }],
            "border-w": [{
                border: de()
            }],
            "border-w-x": [{
                "border-x": de()
            }],
            "border-w-y": [{
                "border-y": de()
            }],
            "border-w-s": [{
                "border-s": de()
            }],
            "border-w-e": [{
                "border-e": de()
            }],
            "border-w-t": [{
                "border-t": de()
            }],
            "border-w-r": [{
                "border-r": de()
            }],
            "border-w-b": [{
                "border-b": de()
            }],
            "border-w-l": [{
                "border-l": de()
            }],
            "divide-x": [{
                "divide-x": de()
            }],
            "divide-x-reverse": ["divide-x-reverse"],
            "divide-y": [{
                "divide-y": de()
            }],
            "divide-y-reverse": ["divide-y-reverse"],
            "border-style": [{
                border: [...be(), "hidden", "none"]
            }],
            "divide-style": [{
                divide: [...be(), "hidden", "none"]
            }],
            "border-color": [{
                border: I()
            }],
            "border-color-x": [{
                "border-x": I()
            }],
            "border-color-y": [{
                "border-y": I()
            }],
            "border-color-s": [{
                "border-s": I()
            }],
            "border-color-e": [{
                "border-e": I()
            }],
            "border-color-t": [{
                "border-t": I()
            }],
            "border-color-r": [{
                "border-r": I()
            }],
            "border-color-b": [{
                "border-b": I()
            }],
            "border-color-l": [{
                "border-l": I()
            }],
            "divide-color": [{
                divide: I()
            }],
            "outline-style": [{
                outline: [...be(), "none", "hidden"]
            }],
            "outline-offset": [{
                "outline-offset": [Re, pe, he]
            }],
            "outline-w": [{
                outline: ["", Re, Ho, ys]
            }],
            "outline-color": [{
                outline: I()
            }],
            shadow: [{
                shadow: ["", "none", m, Zl, Jl]
            }],
            "shadow-color": [{
                shadow: I()
            }],
            "inset-shadow": [{
                "inset-shadow": ["none", y, Zl, Jl]
            }],
            "inset-shadow-color": [{
                "inset-shadow": I()
            }],
            "ring-w": [{
                ring: de()
            }],
            "ring-w-inset": ["ring-inset"],
            "ring-color": [{
                ring: I()
            }],
            "ring-offset-w": [{
                "ring-offset": [Re, ys]
            }],
            "ring-offset-color": [{
                "ring-offset": I()
            }],
            "inset-ring-w": [{
                "inset-ring": de()
            }],
            "inset-ring-color": [{
                "inset-ring": I()
            }],
            "text-shadow": [{
                "text-shadow": ["none", v, Zl, Jl]
            }],
            "text-shadow-color": [{
                "text-shadow": I()
            }],
            opacity: [{
                opacity: [Re, pe, he]
            }],
            "mix-blend": [{
                "mix-blend": [...Te(), "plus-darker", "plus-lighter"]
            }],
            "bg-blend": [{
                "bg-blend": Te()
            }],
            "mask-clip": [{
                "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"]
            }, "mask-no-clip"],
            "mask-composite": [{
                mask: ["add", "subtract", "intersect", "exclude"]
            }],
            "mask-image-linear-pos": [{
                "mask-linear": [Re]
            }],
            "mask-image-linear-from-pos": [{
                "mask-linear-from": Z()
            }],
            "mask-image-linear-to-pos": [{
                "mask-linear-to": Z()
            }],
            "mask-image-linear-from-color": [{
                "mask-linear-from": I()
            }],
            "mask-image-linear-to-color": [{
                "mask-linear-to": I()
            }],
            "mask-image-t-from-pos": [{
                "mask-t-from": Z()
            }],
            "mask-image-t-to-pos": [{
                "mask-t-to": Z()
            }],
            "mask-image-t-from-color": [{
                "mask-t-from": I()
            }],
            "mask-image-t-to-color": [{
                "mask-t-to": I()
            }],
            "mask-image-r-from-pos": [{
                "mask-r-from": Z()
            }],
            "mask-image-r-to-pos": [{
                "mask-r-to": Z()
            }],
            "mask-image-r-from-color": [{
                "mask-r-from": I()
            }],
            "mask-image-r-to-color": [{
                "mask-r-to": I()
            }],
            "mask-image-b-from-pos": [{
                "mask-b-from": Z()
            }],
            "mask-image-b-to-pos": [{
                "mask-b-to": Z()
            }],
            "mask-image-b-from-color": [{
                "mask-b-from": I()
            }],
            "mask-image-b-to-color": [{
                "mask-b-to": I()
            }],
            "mask-image-l-from-pos": [{
                "mask-l-from": Z()
            }],
            "mask-image-l-to-pos": [{
                "mask-l-to": Z()
            }],
            "mask-image-l-from-color": [{
                "mask-l-from": I()
            }],
            "mask-image-l-to-color": [{
                "mask-l-to": I()
            }],
            "mask-image-x-from-pos": [{
                "mask-x-from": Z()
            }],
            "mask-image-x-to-pos": [{
                "mask-x-to": Z()
            }],
            "mask-image-x-from-color": [{
                "mask-x-from": I()
            }],
            "mask-image-x-to-color": [{
                "mask-x-to": I()
            }],
            "mask-image-y-from-pos": [{
                "mask-y-from": Z()
            }],
            "mask-image-y-to-pos": [{
                "mask-y-to": Z()
            }],
            "mask-image-y-from-color": [{
                "mask-y-from": I()
            }],
            "mask-image-y-to-color": [{
                "mask-y-to": I()
            }],
            "mask-image-radial": [{
                "mask-radial": [pe, he]
            }],
            "mask-image-radial-from-pos": [{
                "mask-radial-from": Z()
            }],
            "mask-image-radial-to-pos": [{
                "mask-radial-to": Z()
            }],
            "mask-image-radial-from-color": [{
                "mask-radial-from": I()
            }],
            "mask-image-radial-to-color": [{
                "mask-radial-to": I()
            }],
            "mask-image-radial-shape": [{
                "mask-radial": ["circle", "ellipse"]
            }],
            "mask-image-radial-size": [{
                "mask-radial": [{
                    closest: ["side", "corner"],
                    farthest: ["side", "corner"]
                }]
            }],
            "mask-image-radial-pos": [{
                "mask-radial-at": _()
            }],
            "mask-image-conic-pos": [{
                "mask-conic": [Re]
            }],
            "mask-image-conic-from-pos": [{
                "mask-conic-from": Z()
            }],
            "mask-image-conic-to-pos": [{
                "mask-conic-to": Z()
            }],
            "mask-image-conic-from-color": [{
                "mask-conic-from": I()
            }],
            "mask-image-conic-to-color": [{
                "mask-conic-to": I()
            }],
            "mask-mode": [{
                mask: ["alpha", "luminance", "match"]
            }],
            "mask-origin": [{
                "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"]
            }],
            "mask-position": [{
                mask: se()
            }],
            "mask-repeat": [{
                mask: ee()
            }],
            "mask-size": [{
                mask: j()
            }],
            "mask-type": [{
                "mask-type": ["alpha", "luminance"]
            }],
            "mask-image": [{
                mask: ["none", pe, he]
            }],
            filter: [{
                filter: ["", "none", pe, he]
            }],
            blur: [{
                blur: ye()
            }],
            brightness: [{
                brightness: [Re, pe, he]
            }],
            contrast: [{
                contrast: [Re, pe, he]
            }],
            "drop-shadow": [{
                "drop-shadow": ["", "none", S, Zl, Jl]
            }],
            "drop-shadow-color": [{
                "drop-shadow": I()
            }],
            grayscale: [{
                grayscale: ["", Re, pe, he]
            }],
            "hue-rotate": [{
                "hue-rotate": [Re, pe, he]
            }],
            invert: [{
                invert: ["", Re, pe, he]
            }],
            saturate: [{
                saturate: [Re, pe, he]
            }],
            sepia: [{
                sepia: ["", Re, pe, he]
            }],
            "backdrop-filter": [{
                "backdrop-filter": ["", "none", pe, he]
            }],
            "backdrop-blur": [{
                "backdrop-blur": ye()
            }],
            "backdrop-brightness": [{
                "backdrop-brightness": [Re, pe, he]
            }],
            "backdrop-contrast": [{
                "backdrop-contrast": [Re, pe, he]
            }],
            "backdrop-grayscale": [{
                "backdrop-grayscale": ["", Re, pe, he]
            }],
            "backdrop-hue-rotate": [{
                "backdrop-hue-rotate": [Re, pe, he]
            }],
            "backdrop-invert": [{
                "backdrop-invert": ["", Re, pe, he]
            }],
            "backdrop-opacity": [{
                "backdrop-opacity": [Re, pe, he]
            }],
            "backdrop-saturate": [{
                "backdrop-saturate": [Re, pe, he]
            }],
            "backdrop-sepia": [{
                "backdrop-sepia": ["", Re, pe, he]
            }],
            "border-collapse": [{
                border: ["collapse", "separate"]
            }],
            "border-spacing": [{
                "border-spacing": O()
            }],
            "border-spacing-x": [{
                "border-spacing-x": O()
            }],
            "border-spacing-y": [{
                "border-spacing-y": O()
            }],
            "table-layout": [{
                table: ["auto", "fixed"]
            }],
            caption: [{
                caption: ["top", "bottom"]
            }],
            transition: [{
                transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", pe, he]
            }],
            "transition-behavior": [{
                transition: ["normal", "discrete"]
            }],
            duration: [{
                duration: [Re, "initial", pe, he]
            }],
            ease: [{
                ease: ["linear", "initial", T, pe, he]
            }],
            delay: [{
                delay: [Re, pe, he]
            }],
            animate: [{
                animate: ["none", k, pe, he]
            }],
            backface: [{
                backface: ["hidden", "visible"]
            }],
            perspective: [{
                perspective: [w, pe, he]
            }],
            "perspective-origin": [{
                "perspective-origin": D()
            }],
            rotate: [{
                rotate: Ce()
            }],
            "rotate-x": [{
                "rotate-x": Ce()
            }],
            "rotate-y": [{
                "rotate-y": Ce()
            }],
            "rotate-z": [{
                "rotate-z": Ce()
            }],
            scale: [{
                scale: Pe()
            }],
            "scale-x": [{
                "scale-x": Pe()
            }],
            "scale-y": [{
                "scale-y": Pe()
            }],
            "scale-z": [{
                "scale-z": Pe()
            }],
            "scale-3d": ["scale-3d"],
            skew: [{
                skew: _e()
            }],
            "skew-x": [{
                "skew-x": _e()
            }],
            "skew-y": [{
                "skew-y": _e()
            }],
            transform: [{
                transform: [pe, he, "", "none", "gpu", "cpu"]
            }],
            "transform-origin": [{
                origin: D()
            }],
            "transform-style": [{
                transform: ["3d", "flat"]
            }],
            translate: [{
                translate: Ne()
            }],
            "translate-x": [{
                "translate-x": Ne()
            }],
            "translate-y": [{
                "translate-y": Ne()
            }],
            "translate-z": [{
                "translate-z": Ne()
            }],
            "translate-none": ["translate-none"],
            accent: [{
                accent: I()
            }],
            appearance: [{
                appearance: ["none", "auto"]
            }],
            "caret-color": [{
                caret: I()
            }],
            "color-scheme": [{
                scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"]
            }],
            cursor: [{
                cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", pe, he]
            }],
            "field-sizing": [{
                "field-sizing": ["fixed", "content"]
            }],
            "pointer-events": [{
                "pointer-events": ["auto", "none"]
            }],
            resize: [{
                resize: ["none", "", "y", "x"]
            }],
            "scroll-behavior": [{
                scroll: ["auto", "smooth"]
            }],
            "scroll-m": [{
                "scroll-m": O()
            }],
            "scroll-mx": [{
                "scroll-mx": O()
            }],
            "scroll-my": [{
                "scroll-my": O()
            }],
            "scroll-ms": [{
                "scroll-ms": O()
            }],
            "scroll-me": [{
                "scroll-me": O()
            }],
            "scroll-mt": [{
                "scroll-mt": O()
            }],
            "scroll-mr": [{
                "scroll-mr": O()
            }],
            "scroll-mb": [{
                "scroll-mb": O()
            }],
            "scroll-ml": [{
                "scroll-ml": O()
            }],
            "scroll-p": [{
                "scroll-p": O()
            }],
            "scroll-px": [{
                "scroll-px": O()
            }],
            "scroll-py": [{
                "scroll-py": O()
            }],
            "scroll-ps": [{
                "scroll-ps": O()
            }],
            "scroll-pe": [{
                "scroll-pe": O()
            }],
            "scroll-pt": [{
                "scroll-pt": O()
            }],
            "scroll-pr": [{
                "scroll-pr": O()
            }],
            "scroll-pb": [{
                "scroll-pb": O()
            }],
            "scroll-pl": [{
                "scroll-pl": O()
            }],
            "snap-align": [{
                snap: ["start", "end", "center", "align-none"]
            }],
            "snap-stop": [{
                snap: ["normal", "always"]
            }],
            "snap-type": [{
                snap: ["none", "x", "y", "both"]
            }],
            "snap-strictness": [{
                snap: ["mandatory", "proximity"]
            }],
            touch: [{
                touch: ["auto", "none", "manipulation"]
            }],
            "touch-x": [{
                "touch-pan": ["x", "left", "right"]
            }],
            "touch-y": [{
                "touch-pan": ["y", "up", "down"]
            }],
            "touch-pz": ["touch-pinch-zoom"],
            select: [{
                select: ["none", "text", "all", "auto"]
            }],
            "will-change": [{
                "will-change": ["auto", "scroll", "contents", "transform", pe, he]
            }],
            fill: [{
                fill: ["none", ...I()]
            }],
            "stroke-w": [{
                stroke: [Re, Ho, ys, hf]
            }],
            stroke: [{
                stroke: ["none", ...I()]
            }],
            "forced-color-adjust": [{
                "forced-color-adjust": ["auto", "none"]
            }]
        },
        conflictingClassGroups: {
            overflow: ["overflow-x", "overflow-y"],
            overscroll: ["overscroll-x", "overscroll-y"],
            inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
            "inset-x": ["right", "left"],
            "inset-y": ["top", "bottom"],
            flex: ["basis", "grow", "shrink"],
            gap: ["gap-x", "gap-y"],
            p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
            px: ["pr", "pl"],
            py: ["pt", "pb"],
            m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
            mx: ["mr", "ml"],
            my: ["mt", "mb"],
            size: ["w", "h"],
            "font-size": ["leading"],
            "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
            "fvn-ordinal": ["fvn-normal"],
            "fvn-slashed-zero": ["fvn-normal"],
            "fvn-figure": ["fvn-normal"],
            "fvn-spacing": ["fvn-normal"],
            "fvn-fraction": ["fvn-normal"],
            "line-clamp": ["display", "overflow"],
            rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
            "rounded-s": ["rounded-ss", "rounded-es"],
            "rounded-e": ["rounded-se", "rounded-ee"],
            "rounded-t": ["rounded-tl", "rounded-tr"],
            "rounded-r": ["rounded-tr", "rounded-br"],
            "rounded-b": ["rounded-br", "rounded-bl"],
            "rounded-l": ["rounded-tl", "rounded-bl"],
            "border-spacing": ["border-spacing-x", "border-spacing-y"],
            "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
            "border-w-x": ["border-w-r", "border-w-l"],
            "border-w-y": ["border-w-t", "border-w-b"],
            "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
            "border-color-x": ["border-color-r", "border-color-l"],
            "border-color-y": ["border-color-t", "border-color-b"],
            translate: ["translate-x", "translate-y", "translate-none"],
            "translate-none": ["translate", "translate-x", "translate-y", "translate-z"],
            "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
            "scroll-mx": ["scroll-mr", "scroll-ml"],
            "scroll-my": ["scroll-mt", "scroll-mb"],
            "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
            "scroll-px": ["scroll-pr", "scroll-pl"],
            "scroll-py": ["scroll-pt", "scroll-pb"],
            touch: ["touch-x", "touch-y", "touch-pz"],
            "touch-x": ["touch"],
            "touch-y": ["touch"],
            "touch-pz": ["touch"]
        },
        conflictingClassGroupModifiers: {
            "font-size": ["leading"]
        },
        orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"]
    }
}
    , Ex = LT(JT);
function Ze(...e) {
    return Ex(lx(e))
}
const Cx = P.forwardRef( ({...e}, t) => b.jsx("div", {
    ref: t,
    className: "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
    ...e
}));
Cx.displayName = "ToastProvider";
const Px = P.forwardRef( ({...e}, t) => b.jsx("div", {
    ref: t,
    className: "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
    ...e
}));
Px.displayName = "ToastViewport";
const ZT = Zh("group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full", {
    variants: {
        variant: {
            default: "border bg-background text-foreground",
            destructive: "destructive group border-destructive bg-destructive text-destructive-foreground"
        }
    },
    defaultVariants: {
        variant: "default"
    }
})
    , Tx = P.forwardRef( ({className: e, variant: t, ...n}, s) => b.jsx("div", {
    ref: s,
    className: Ze(ZT({
        variant: t
    }), e),
    ...n
}));
Tx.displayName = "Toast";
const ek = P.forwardRef( ({className: e, ...t}, n) => b.jsx("div", {
    ref: n,
    className: Ze("inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive", e),
    ...t
}));
ek.displayName = "ToastAction";
const kx = P.forwardRef( ({className: e, ...t}, n) => b.jsx("button", {
    ref: n,
    className: Ze("absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600", e),
    "toast-close": "",
    ...t,
    children: b.jsx(wT, {
        className: "h-4 w-4"
    })
}));
kx.displayName = "ToastClose";
const Rx = P.forwardRef( ({className: e, ...t}, n) => b.jsx("div", {
    ref: n,
    className: Ze("text-sm font-semibold", e),
    ...t
}));
Rx.displayName = "ToastTitle";
const Ax = P.forwardRef( ({className: e, ...t}, n) => b.jsx("div", {
    ref: n,
    className: Ze("text-sm opacity-90", e),
    ...t
}));
Ax.displayName = "ToastDescription";
function tk() {
    const {toasts: e} = YP();
    return b.jsxs(Cx, {
        children: [e.map(function({id: t, title: n, description: s, action: o, ...u}) {
            return b.jsxs(Tx, {
                ...u,
                children: [b.jsxs("div", {
                    className: "grid gap-1",
                    children: [n && b.jsx(Rx, {
                        children: n
                    }), s && b.jsx(Ax, {
                        children: s
                    })]
                }), o, b.jsx(kx, {})]
            }, t)
        }), b.jsx(Px, {})]
    })
}
var Ra = class {
    constructor() {
        this.listeners = new Set,
            this.subscribe = this.subscribe.bind(this)
    }
    subscribe(e) {
        return this.listeners.add(e),
            this.onSubscribe(),
            () => {
                this.listeners.delete(e),
                    this.onUnsubscribe()
            }
    }
    hasListeners() {
        return this.listeners.size > 0
    }
    onSubscribe() {}
    onUnsubscribe() {}
}
    , nk = {
    setTimeout: (e, t) => setTimeout(e, t),
    clearTimeout: e => clearTimeout(e),
    setInterval: (e, t) => setInterval(e, t),
    clearInterval: e => clearInterval(e)
}, Fr, Gh, Xw, rk = (Xw = class {
    constructor() {
        xe(this, Fr, nk);
        xe(this, Gh, !1)
    }
    setTimeoutProvider(e) {
        le(this, Fr, e)
    }
    setTimeout(e, t) {
        return L(this, Fr).setTimeout(e, t)
    }
    clearTimeout(e) {
        L(this, Fr).clearTimeout(e)
    }
    setInterval(e, t) {
        return L(this, Fr).setInterval(e, t)
    }
    clearInterval(e) {
        L(this, Fr).clearInterval(e)
    }
}
    ,
    Fr = new WeakMap,
    Gh = new WeakMap,
    Xw), Ss = new rk;
function sk(e) {
    setTimeout(e, 0)
}
var js = typeof window > "u" || "Deno"in globalThis;
function Bt() {}
function ik(e, t) {
    return typeof e == "function" ? e(t) : e
}
function Kf(e) {
    return typeof e == "number" && e >= 0 && e !== 1 / 0
}
function _x(e, t) {
    return Math.max(e + (t || 0) - Date.now(), 0)
}
function Qr(e, t) {
    return typeof e == "function" ? e(t) : e
}
function ln(e, t) {
    return typeof e == "function" ? e(t) : e
}
function gv(e, t) {
    const {type: n="all", exact: s, fetchStatus: o, predicate: u, queryKey: l, stale: d} = e;
    if (l) {
        if (s) {
            if (t.queryHash !== tp(l, t.options))
                return !1
        } else if (!fa(t.queryKey, l))
            return !1
    }
    if (n !== "all") {
        const f = t.isActive();
        if (n === "active" && !f || n === "inactive" && f)
            return !1
    }
    return !(typeof d == "boolean" && t.isStale() !== d || o && o !== t.state.fetchStatus || u && !u(t))
}
function yv(e, t) {
    const {exact: n, status: s, predicate: o, mutationKey: u} = e;
    if (u) {
        if (!t.options.mutationKey)
            return !1;
        if (n) {
            if (da(t.options.mutationKey) !== da(u))
                return !1
        } else if (!fa(t.options.mutationKey, u))
            return !1
    }
    return !(s && t.state.status !== s || o && !o(t))
}
function tp(e, t) {
    return ((t == null ? void 0 : t.queryKeyHashFn) || da)(e)
}
function da(e) {
    return JSON.stringify(e, (t, n) => Gf(n) ? Object.keys(n).sort().reduce( (s, o) => (s[o] = n[o],
        s), {}) : n)
}
function fa(e, t) {
    return e === t ? !0 : typeof e != typeof t ? !1 : e && t && typeof e == "object" && typeof t == "object" ? Object.keys(t).every(n => fa(e[n], t[n])) : !1
}
var ok = Object.prototype.hasOwnProperty;
function Nx(e, t) {
    if (e === t)
        return e;
    const n = vv(e) && vv(t);
    if (!n && !(Gf(e) && Gf(t)))
        return t;
    const o = (n ? e : Object.keys(e)).length
        , u = n ? t : Object.keys(t)
        , l = u.length
        , d = n ? new Array(l) : {};
    let f = 0;
    for (let p = 0; p < l; p++) {
        const m = n ? p : u[p]
            , y = e[m]
            , v = t[m];
        if (y === v) {
            d[m] = y,
            (n ? p < o : ok.call(e, m)) && f++;
            continue
        }
        if (y === null || v === null || typeof y != "object" || typeof v != "object") {
            d[m] = v;
            continue
        }
        const S = Nx(y, v);
        d[m] = S,
        S === y && f++
    }
    return o === l && f === o ? e : d
}
function Qf(e, t) {
    if (!t || Object.keys(e).length !== Object.keys(t).length)
        return !1;
    for (const n in e)
        if (e[n] !== t[n])
            return !1;
    return !0
}
function vv(e) {
    return Array.isArray(e) && e.length === Object.keys(e).length
}
function Gf(e) {
    if (!wv(e))
        return !1;
    const t = e.constructor;
    if (t === void 0)
        return !0;
    const n = t.prototype;
    return !(!wv(n) || !n.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(e) !== Object.prototype)
}
function wv(e) {
    return Object.prototype.toString.call(e) === "[object Object]"
}
function ak(e) {
    return new Promise(t => {
            Ss.setTimeout(t, e)
        }
    )
}
function Xf(e, t, n) {
    return typeof n.structuralSharing == "function" ? n.structuralSharing(e, t) : n.structuralSharing !== !1 ? Nx(e, t) : t
}
function lk(e, t, n=0) {
    const s = [...e, t];
    return n && s.length > n ? s.slice(1) : s
}
function uk(e, t, n=0) {
    const s = [t, ...e];
    return n && s.length > n ? s.slice(0, -1) : s
}
var np = Symbol();
function Ox(e, t) {
    return !e.queryFn && (t != null && t.initialPromise) ? () => t.initialPromise : !e.queryFn || e.queryFn === np ? () => Promise.reject(new Error(`Missing queryFn: '${e.queryHash}'`)) : e.queryFn
}
function ck(e, t) {
    return typeof e == "function" ? e(...t) : !!e
}
var Cs, Br, _i, Yw, dk = (Yw = class extends Ra {
    constructor() {
        super();
        xe(this, Cs);
        xe(this, Br);
        xe(this, _i);
        le(this, _i, t => {
                if (!js && window.addEventListener) {
                    const n = () => t();
                    return window.addEventListener("visibilitychange", n, !1),
                        () => {
                            window.removeEventListener("visibilitychange", n)
                        }
                }
            }
        )
    }
    onSubscribe() {
        L(this, Br) || this.setEventListener(L(this, _i))
    }
    onUnsubscribe() {
        var t;
        this.hasListeners() || ((t = L(this, Br)) == null || t.call(this),
            le(this, Br, void 0))
    }
    setEventListener(t) {
        var n;
        le(this, _i, t),
        (n = L(this, Br)) == null || n.call(this),
            le(this, Br, t(s => {
                    typeof s == "boolean" ? this.setFocused(s) : this.onFocus()
                }
            ))
    }
    setFocused(t) {
        L(this, Cs) !== t && (le(this, Cs, t),
            this.onFocus())
    }
    onFocus() {
        const t = this.isFocused();
        this.listeners.forEach(n => {
                n(t)
            }
        )
    }
    isFocused() {
        var t;
        return typeof L(this, Cs) == "boolean" ? L(this, Cs) : ((t = globalThis.document) == null ? void 0 : t.visibilityState) !== "hidden"
    }
}
    ,
    Cs = new WeakMap,
    Br = new WeakMap,
    _i = new WeakMap,
    Yw), rp = new dk;
function Yf() {
    let e, t;
    const n = new Promise( (o, u) => {
            e = o,
                t = u
        }
    );
    n.status = "pending",
        n.catch( () => {}
        );
    function s(o) {
        Object.assign(n, o),
            delete n.resolve,
            delete n.reject
    }
    return n.resolve = o => {
        s({
            status: "fulfilled",
            value: o
        }),
            e(o)
    }
        ,
        n.reject = o => {
            s({
                status: "rejected",
                reason: o
            }),
                t(o)
        }
        ,
        n
}
var fk = sk;
function hk() {
    let e = []
        , t = 0
        , n = d => {
        d()
    }
        , s = d => {
        d()
    }
        , o = fk;
    const u = d => {
            t ? e.push(d) : o( () => {
                    n(d)
                }
            )
        }
        , l = () => {
            const d = e;
            e = [],
            d.length && o( () => {
                    s( () => {
                            d.forEach(f => {
                                    n(f)
                                }
                            )
                        }
                    )
                }
            )
        }
    ;
    return {
        batch: d => {
            let f;
            t++;
            try {
                f = d()
            } finally {
                t--,
                t || l()
            }
            return f
        }
        ,
        batchCalls: d => (...f) => {
            u( () => {
                    d(...f)
                }
            )
        }
        ,
        schedule: u,
        setNotifyFunction: d => {
            n = d
        }
        ,
        setBatchNotifyFunction: d => {
            s = d
        }
        ,
        setScheduler: d => {
            o = d
        }
    }
}
var vt = hk(), Ni, Vr, Oi, Jw, pk = (Jw = class extends Ra {
    constructor() {
        super();
        xe(this, Ni, !0);
        xe(this, Vr);
        xe(this, Oi);
        le(this, Oi, t => {
                if (!js && window.addEventListener) {
                    const n = () => t(!0)
                        , s = () => t(!1);
                    return window.addEventListener("online", n, !1),
                        window.addEventListener("offline", s, !1),
                        () => {
                            window.removeEventListener("online", n),
                                window.removeEventListener("offline", s)
                        }
                }
            }
        )
    }
    onSubscribe() {
        L(this, Vr) || this.setEventListener(L(this, Oi))
    }
    onUnsubscribe() {
        var t;
        this.hasListeners() || ((t = L(this, Vr)) == null || t.call(this),
            le(this, Vr, void 0))
    }
    setEventListener(t) {
        var n;
        le(this, Oi, t),
        (n = L(this, Vr)) == null || n.call(this),
            le(this, Vr, t(this.setOnline.bind(this)))
    }
    setOnline(t) {
        L(this, Ni) !== t && (le(this, Ni, t),
            this.listeners.forEach(s => {
                    s(t)
                }
            ))
    }
    isOnline() {
        return L(this, Ni)
    }
}
    ,
    Ni = new WeakMap,
    Vr = new WeakMap,
    Oi = new WeakMap,
    Jw), _u = new pk;
function mk(e) {
    return Math.min(1e3 * 2 ** e, 3e4)
}
function Lx(e) {
    return (e ?? "online") === "online" ? _u.isOnline() : !0
}
var Jf = class extends Error {
        constructor(e) {
            super("CancelledError"),
                this.revert = e == null ? void 0 : e.revert,
                this.silent = e == null ? void 0 : e.silent
        }
    }
;
function Mx(e) {
    let t = !1, n = 0, s;
    const o = Yf()
        , u = () => o.status !== "pending"
        , l = w => {
            var x;
            if (!u()) {
                const T = new Jf(w);
                v(T),
                (x = e.onCancel) == null || x.call(e, T)
            }
        }
        , d = () => {
            t = !0
        }
        , f = () => {
            t = !1
        }
        , p = () => rp.isFocused() && (e.networkMode === "always" || _u.isOnline()) && e.canRun()
        , m = () => Lx(e.networkMode) && e.canRun()
        , y = w => {
            u() || (s == null || s(),
                o.resolve(w))
        }
        , v = w => {
            u() || (s == null || s(),
                o.reject(w))
        }
        , S = () => new Promise(w => {
                var x;
                s = T => {
                    (u() || p()) && w(T)
                }
                    ,
                (x = e.onPause) == null || x.call(e)
            }
        ).then( () => {
                var w;
                s = void 0,
                u() || (w = e.onContinue) == null || w.call(e)
            }
        )
        , E = () => {
            if (u())
                return;
            let w;
            const x = n === 0 ? e.initialPromise : void 0;
            try {
                w = x ?? e.fn()
            } catch (T) {
                w = Promise.reject(T)
            }
            Promise.resolve(w).then(y).catch(T => {
                    var H;
                    if (u())
                        return;
                    const k = e.retry ?? (js ? 0 : 3)
                        , R = e.retryDelay ?? mk
                        , _ = typeof R == "function" ? R(n, T) : R
                        , D = k === !0 || typeof k == "number" && n < k || typeof k == "function" && k(n, T);
                    if (t || !D) {
                        v(T);
                        return
                    }
                    n++,
                    (H = e.onFail) == null || H.call(e, n, T),
                        ak(_).then( () => p() ? void 0 : S()).then( () => {
                                t ? v(T) : E()
                            }
                        )
                }
            )
        }
    ;
    return {
        promise: o,
        status: () => o.status,
        cancel: l,
        continue: () => (s == null || s(),
            o),
        cancelRetry: d,
        continueRetry: f,
        canStart: m,
        start: () => (m() ? E() : S().then(E),
            o)
    }
}
var Ps, Zw, jx = (Zw = class {
    constructor() {
        xe(this, Ps)
    }
    destroy() {
        this.clearGcTimeout()
    }
    scheduleGc() {
        this.clearGcTimeout(),
        Kf(this.gcTime) && le(this, Ps, Ss.setTimeout( () => {
                this.optionalRemove()
            }
            , this.gcTime))
    }
    updateGcTime(e) {
        this.gcTime = Math.max(this.gcTime || 0, e ?? (js ? 1 / 0 : 300 * 1e3))
    }
    clearGcTimeout() {
        L(this, Ps) && (Ss.clearTimeout(L(this, Ps)),
            le(this, Ps, void 0))
    }
}
    ,
    Ps = new WeakMap,
    Zw), Ts, Li, an, ks, ht, Ea, Rs, wn, tr, ex, gk = (ex = class extends jx {
    constructor(t) {
        super();
        xe(this, wn);
        xe(this, Ts);
        xe(this, Li);
        xe(this, an);
        xe(this, ks);
        xe(this, ht);
        xe(this, Ea);
        xe(this, Rs);
        le(this, Rs, !1),
            le(this, Ea, t.defaultOptions),
            this.setOptions(t.options),
            this.observers = [],
            le(this, ks, t.client),
            le(this, an, L(this, ks).getQueryCache()),
            this.queryKey = t.queryKey,
            this.queryHash = t.queryHash,
            le(this, Ts, xv(this.options)),
            this.state = t.state ?? L(this, Ts),
            this.scheduleGc()
    }
    get meta() {
        return this.options.meta
    }
    get promise() {
        var t;
        return (t = L(this, ht)) == null ? void 0 : t.promise
    }
    setOptions(t) {
        if (this.options = {
            ...L(this, Ea),
            ...t
        },
            this.updateGcTime(this.options.gcTime),
        this.state && this.state.data === void 0) {
            const n = xv(this.options);
            n.data !== void 0 && (this.setData(n.data, {
                updatedAt: n.dataUpdatedAt,
                manual: !0
            }),
                le(this, Ts, n))
        }
    }
    optionalRemove() {
        !this.observers.length && this.state.fetchStatus === "idle" && L(this, an).remove(this)
    }
    setData(t, n) {
        const s = Xf(this.state.data, t, this.options);
        return Oe(this, wn, tr).call(this, {
            data: s,
            type: "success",
            dataUpdatedAt: n == null ? void 0 : n.updatedAt,
            manual: n == null ? void 0 : n.manual
        }),
            s
    }
    setState(t, n) {
        Oe(this, wn, tr).call(this, {
            type: "setState",
            state: t,
            setStateOptions: n
        })
    }
    cancel(t) {
        var s, o;
        const n = (s = L(this, ht)) == null ? void 0 : s.promise;
        return (o = L(this, ht)) == null || o.cancel(t),
            n ? n.then(Bt).catch(Bt) : Promise.resolve()
    }
    destroy() {
        super.destroy(),
            this.cancel({
                silent: !0
            })
    }
    reset() {
        this.destroy(),
            this.setState(L(this, Ts))
    }
    isActive() {
        return this.observers.some(t => ln(t.options.enabled, this) !== !1)
    }
    isDisabled() {
        return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === np || this.state.dataUpdateCount + this.state.errorUpdateCount === 0
    }
    isStatic() {
        return this.getObserversCount() > 0 ? this.observers.some(t => Qr(t.options.staleTime, this) === "static") : !1
    }
    isStale() {
        return this.getObserversCount() > 0 ? this.observers.some(t => t.getCurrentResult().isStale) : this.state.data === void 0 || this.state.isInvalidated
    }
    isStaleByTime(t=0) {
        return this.state.data === void 0 ? !0 : t === "static" ? !1 : this.state.isInvalidated ? !0 : !_x(this.state.dataUpdatedAt, t)
    }
    onFocus() {
        var n;
        const t = this.observers.find(s => s.shouldFetchOnWindowFocus());
        t == null || t.refetch({
            cancelRefetch: !1
        }),
        (n = L(this, ht)) == null || n.continue()
    }
    onOnline() {
        var n;
        const t = this.observers.find(s => s.shouldFetchOnReconnect());
        t == null || t.refetch({
            cancelRefetch: !1
        }),
        (n = L(this, ht)) == null || n.continue()
    }
    addObserver(t) {
        this.observers.includes(t) || (this.observers.push(t),
            this.clearGcTimeout(),
            L(this, an).notify({
                type: "observerAdded",
                query: this,
                observer: t
            }))
    }
    removeObserver(t) {
        this.observers.includes(t) && (this.observers = this.observers.filter(n => n !== t),
        this.observers.length || (L(this, ht) && (L(this, Rs) ? L(this, ht).cancel({
            revert: !0
        }) : L(this, ht).cancelRetry()),
            this.scheduleGc()),
            L(this, an).notify({
                type: "observerRemoved",
                query: this,
                observer: t
            }))
    }
    getObserversCount() {
        return this.observers.length
    }
    invalidate() {
        this.state.isInvalidated || Oe(this, wn, tr).call(this, {
            type: "invalidate"
        })
    }
    async fetch(t, n) {
        var f, p, m, y, v, S, E, w, x, T, k, R;
        if (this.state.fetchStatus !== "idle" && ((f = L(this, ht)) == null ? void 0 : f.status()) !== "rejected") {
            if (this.state.data !== void 0 && (n != null && n.cancelRefetch))
                this.cancel({
                    silent: !0
                });
            else if (L(this, ht))
                return L(this, ht).continueRetry(),
                    L(this, ht).promise
        }
        if (t && this.setOptions(t),
            !this.options.queryFn) {
            const _ = this.observers.find(D => D.options.queryFn);
            _ && this.setOptions(_.options)
        }
        const s = new AbortController
            , o = _ => {
            Object.defineProperty(_, "signal", {
                enumerable: !0,
                get: () => (le(this, Rs, !0),
                    s.signal)
            })
        }
            , u = () => {
            const _ = Ox(this.options, n)
                , H = ( () => {
                    const $ = {
                        client: L(this, ks),
                        queryKey: this.queryKey,
                        meta: this.meta
                    };
                    return o($),
                        $
                }
            )();
            return le(this, Rs, !1),
                this.options.persister ? this.options.persister(_, H, this) : _(H)
        }
            , d = ( () => {
                const _ = {
                    fetchOptions: n,
                    options: this.options,
                    queryKey: this.queryKey,
                    client: L(this, ks),
                    state: this.state,
                    fetchFn: u
                };
                return o(_),
                    _
            }
        )();
        (p = this.options.behavior) == null || p.onFetch(d, this),
            le(this, Li, this.state),
        (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((m = d.fetchOptions) == null ? void 0 : m.meta)) && Oe(this, wn, tr).call(this, {
            type: "fetch",
            meta: (y = d.fetchOptions) == null ? void 0 : y.meta
        }),
            le(this, ht, Mx({
                initialPromise: n == null ? void 0 : n.initialPromise,
                fn: d.fetchFn,
                onCancel: _ => {
                    _ instanceof Jf && _.revert && this.setState({
                        ...L(this, Li),
                        fetchStatus: "idle"
                    }),
                        s.abort()
                }
                ,
                onFail: (_, D) => {
                    Oe(this, wn, tr).call(this, {
                        type: "failed",
                        failureCount: _,
                        error: D
                    })
                }
                ,
                onPause: () => {
                    Oe(this, wn, tr).call(this, {
                        type: "pause"
                    })
                }
                ,
                onContinue: () => {
                    Oe(this, wn, tr).call(this, {
                        type: "continue"
                    })
                }
                ,
                retry: d.options.retry,
                retryDelay: d.options.retryDelay,
                networkMode: d.options.networkMode,
                canRun: () => !0
            }));
        try {
            const _ = await L(this, ht).start();
            if (_ === void 0)
                throw new Error(`${this.queryHash} data is undefined`);
            return this.setData(_),
            (S = (v = L(this, an).config).onSuccess) == null || S.call(v, _, this),
            (w = (E = L(this, an).config).onSettled) == null || w.call(E, _, this.state.error, this),
                _
        } catch (_) {
            if (_ instanceof Jf) {
                if (_.silent)
                    return L(this, ht).promise;
                if (_.revert) {
                    if (this.state.data === void 0)
                        throw _;
                    return this.state.data
                }
            }
            throw Oe(this, wn, tr).call(this, {
                type: "error",
                error: _
            }),
            (T = (x = L(this, an).config).onError) == null || T.call(x, _, this),
            (R = (k = L(this, an).config).onSettled) == null || R.call(k, this.state.data, _, this),
                _
        } finally {
            this.scheduleGc()
        }
    }
}
    ,
    Ts = new WeakMap,
    Li = new WeakMap,
    an = new WeakMap,
    ks = new WeakMap,
    ht = new WeakMap,
    Ea = new WeakMap,
    Rs = new WeakMap,
    wn = new WeakSet,
    tr = function(t) {
        const n = s => {
                switch (t.type) {
                    case "failed":
                        return {
                            ...s,
                            fetchFailureCount: t.failureCount,
                            fetchFailureReason: t.error
                        };
                    case "pause":
                        return {
                            ...s,
                            fetchStatus: "paused"
                        };
                    case "continue":
                        return {
                            ...s,
                            fetchStatus: "fetching"
                        };
                    case "fetch":
                        return {
                            ...s,
                            ...Dx(s.data, this.options),
                            fetchMeta: t.meta ?? null
                        };
                    case "success":
                        const o = {
                            ...s,
                            data: t.data,
                            dataUpdateCount: s.dataUpdateCount + 1,
                            dataUpdatedAt: t.dataUpdatedAt ?? Date.now(),
                            error: null,
                            isInvalidated: !1,
                            status: "success",
                            ...!t.manual && {
                                fetchStatus: "idle",
                                fetchFailureCount: 0,
                                fetchFailureReason: null
                            }
                        };
                        return le(this, Li, t.manual ? o : void 0),
                            o;
                    case "error":
                        const u = t.error;
                        return {
                            ...s,
                            error: u,
                            errorUpdateCount: s.errorUpdateCount + 1,
                            errorUpdatedAt: Date.now(),
                            fetchFailureCount: s.fetchFailureCount + 1,
                            fetchFailureReason: u,
                            fetchStatus: "idle",
                            status: "error"
                        };
                    case "invalidate":
                        return {
                            ...s,
                            isInvalidated: !0
                        };
                    case "setState":
                        return {
                            ...s,
                            ...t.state
                        }
                }
            }
        ;
        this.state = n(this.state),
            vt.batch( () => {
                    this.observers.forEach(s => {
                            s.onQueryUpdate()
                        }
                    ),
                        L(this, an).notify({
                            query: this,
                            type: "updated",
                            action: t
                        })
                }
            )
    }
    ,
    ex);
function Dx(e, t) {
    return {
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchStatus: Lx(t.networkMode) ? "fetching" : "paused",
        ...e === void 0 && {
            error: null,
            status: "pending"
        }
    }
}
function xv(e) {
    const t = typeof e.initialData == "function" ? e.initialData() : e.initialData
        , n = t !== void 0
        , s = n ? typeof e.initialDataUpdatedAt == "function" ? e.initialDataUpdatedAt() : e.initialDataUpdatedAt : 0;
    return {
        data: t,
        dataUpdateCount: 0,
        dataUpdatedAt: n ? s ?? Date.now() : 0,
        error: null,
        errorUpdateCount: 0,
        errorUpdatedAt: 0,
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchMeta: null,
        isInvalidated: !1,
        status: n ? "success" : "pending",
        fetchStatus: "idle"
    }
}
var Ft, Le, Ca, At, As, Mi, nr, Ur, Pa, ji, Di, _s, Ns, zr, Ii, Ie, Go, Zf, eh, th, nh, rh, sh, ih, Ix, tx, yk = (tx = class extends Ra {
    constructor(t, n) {
        super();
        xe(this, Ie);
        xe(this, Ft);
        xe(this, Le);
        xe(this, Ca);
        xe(this, At);
        xe(this, As);
        xe(this, Mi);
        xe(this, nr);
        xe(this, Ur);
        xe(this, Pa);
        xe(this, ji);
        xe(this, Di);
        xe(this, _s);
        xe(this, Ns);
        xe(this, zr);
        xe(this, Ii, new Set);
        this.options = n,
            le(this, Ft, t),
            le(this, Ur, null),
            le(this, nr, Yf()),
            this.bindMethods(),
            this.setOptions(n)
    }
    bindMethods() {
        this.refetch = this.refetch.bind(this)
    }
    onSubscribe() {
        this.listeners.size === 1 && (L(this, Le).addObserver(this),
            Sv(L(this, Le), this.options) ? Oe(this, Ie, Go).call(this) : this.updateResult(),
            Oe(this, Ie, nh).call(this))
    }
    onUnsubscribe() {
        this.hasListeners() || this.destroy()
    }
    shouldFetchOnReconnect() {
        return oh(L(this, Le), this.options, this.options.refetchOnReconnect)
    }
    shouldFetchOnWindowFocus() {
        return oh(L(this, Le), this.options, this.options.refetchOnWindowFocus)
    }
    destroy() {
        this.listeners = new Set,
            Oe(this, Ie, rh).call(this),
            Oe(this, Ie, sh).call(this),
            L(this, Le).removeObserver(this)
    }
    setOptions(t) {
        const n = this.options
            , s = L(this, Le);
        if (this.options = L(this, Ft).defaultQueryOptions(t),
        this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof ln(this.options.enabled, L(this, Le)) != "boolean")
            throw new Error("Expected enabled to be a boolean or a callback that returns a boolean");
        Oe(this, Ie, ih).call(this),
            L(this, Le).setOptions(this.options),
        n._defaulted && !Qf(this.options, n) && L(this, Ft).getQueryCache().notify({
            type: "observerOptionsUpdated",
            query: L(this, Le),
            observer: this
        });
        const o = this.hasListeners();
        o && bv(L(this, Le), s, this.options, n) && Oe(this, Ie, Go).call(this),
            this.updateResult(),
        o && (L(this, Le) !== s || ln(this.options.enabled, L(this, Le)) !== ln(n.enabled, L(this, Le)) || Qr(this.options.staleTime, L(this, Le)) !== Qr(n.staleTime, L(this, Le))) && Oe(this, Ie, Zf).call(this);
        const u = Oe(this, Ie, eh).call(this);
        o && (L(this, Le) !== s || ln(this.options.enabled, L(this, Le)) !== ln(n.enabled, L(this, Le)) || u !== L(this, zr)) && Oe(this, Ie, th).call(this, u)
    }
    getOptimisticResult(t) {
        const n = L(this, Ft).getQueryCache().build(L(this, Ft), t)
            , s = this.createResult(n, t);
        return wk(this, s) && (le(this, At, s),
            le(this, Mi, this.options),
            le(this, As, L(this, Le).state)),
            s
    }
    getCurrentResult() {
        return L(this, At)
    }
    trackResult(t, n) {
        return new Proxy(t,{
            get: (s, o) => (this.trackProp(o),
            n == null || n(o),
            o === "promise" && !this.options.experimental_prefetchInRender && L(this, nr).status === "pending" && L(this, nr).reject(new Error("experimental_prefetchInRender feature flag is not enabled")),
                Reflect.get(s, o))
        })
    }
    trackProp(t) {
        L(this, Ii).add(t)
    }
    getCurrentQuery() {
        return L(this, Le)
    }
    refetch({...t}={}) {
        return this.fetch({
            ...t
        })
    }
    fetchOptimistic(t) {
        const n = L(this, Ft).defaultQueryOptions(t)
            , s = L(this, Ft).getQueryCache().build(L(this, Ft), n);
        return s.fetch().then( () => this.createResult(s, n))
    }
    fetch(t) {
        return Oe(this, Ie, Go).call(this, {
            ...t,
            cancelRefetch: t.cancelRefetch ?? !0
        }).then( () => (this.updateResult(),
            L(this, At)))
    }
    createResult(t, n) {
        var W;
        const s = L(this, Le)
            , o = this.options
            , u = L(this, At)
            , l = L(this, As)
            , d = L(this, Mi)
            , p = t !== s ? t.state : L(this, Ca)
            , {state: m} = t;
        let y = {
            ...m
        }, v = !1, S;
        if (n._optimisticResults) {
            const q = this.hasListeners()
                , X = !q && Sv(t, n)
                , z = q && bv(t, s, n, o);
            (X || z) && (y = {
                ...y,
                ...Dx(m.data, t.options)
            }),
            n._optimisticResults === "isRestoring" && (y.fetchStatus = "idle")
        }
        let {error: E, errorUpdatedAt: w, status: x} = y;
        S = y.data;
        let T = !1;
        if (n.placeholderData !== void 0 && S === void 0 && x === "pending") {
            let q;
            u != null && u.isPlaceholderData && n.placeholderData === (d == null ? void 0 : d.placeholderData) ? (q = u.data,
                T = !0) : q = typeof n.placeholderData == "function" ? n.placeholderData((W = L(this, Di)) == null ? void 0 : W.state.data, L(this, Di)) : n.placeholderData,
            q !== void 0 && (x = "success",
                S = Xf(u == null ? void 0 : u.data, q, n),
                v = !0)
        }
        if (n.select && S !== void 0 && !T)
            if (u && S === (l == null ? void 0 : l.data) && n.select === L(this, Pa))
                S = L(this, ji);
            else
                try {
                    le(this, Pa, n.select),
                        S = n.select(S),
                        S = Xf(u == null ? void 0 : u.data, S, n),
                        le(this, ji, S),
                        le(this, Ur, null)
                } catch (q) {
                    le(this, Ur, q)
                }
        L(this, Ur) && (E = L(this, Ur),
            S = L(this, ji),
            w = Date.now(),
            x = "error");
        const k = y.fetchStatus === "fetching"
            , R = x === "pending"
            , _ = x === "error"
            , D = R && k
            , H = S !== void 0
            , O = {
            status: x,
            fetchStatus: y.fetchStatus,
            isPending: R,
            isSuccess: x === "success",
            isError: _,
            isInitialLoading: D,
            isLoading: D,
            data: S,
            dataUpdatedAt: y.dataUpdatedAt,
            error: E,
            errorUpdatedAt: w,
            failureCount: y.fetchFailureCount,
            failureReason: y.fetchFailureReason,
            errorUpdateCount: y.errorUpdateCount,
            isFetched: y.dataUpdateCount > 0 || y.errorUpdateCount > 0,
            isFetchedAfterMount: y.dataUpdateCount > p.dataUpdateCount || y.errorUpdateCount > p.errorUpdateCount,
            isFetching: k,
            isRefetching: k && !R,
            isLoadingError: _ && !H,
            isPaused: y.fetchStatus === "paused",
            isPlaceholderData: v,
            isRefetchError: _ && H,
            isStale: sp(t, n),
            refetch: this.refetch,
            promise: L(this, nr),
            isEnabled: ln(n.enabled, t) !== !1
        };
        if (this.options.experimental_prefetchInRender) {
            const q = J => {
                O.status === "error" ? J.reject(O.error) : O.data !== void 0 && J.resolve(O.data)
            }
                , X = () => {
                const J = le(this, nr, O.promise = Yf());
                q(J)
            }
                , z = L(this, nr);
            switch (z.status) {
                case "pending":
                    t.queryHash === s.queryHash && q(z);
                    break;
                case "fulfilled":
                    (O.status === "error" || O.data !== z.value) && X();
                    break;
                case "rejected":
                    (O.status !== "error" || O.error !== z.reason) && X();
                    break
            }
        }
        return O
    }
    updateResult() {
        const t = L(this, At)
            , n = this.createResult(L(this, Le), this.options);
        if (le(this, As, L(this, Le).state),
            le(this, Mi, this.options),
        L(this, As).data !== void 0 && le(this, Di, L(this, Le)),
            Qf(n, t))
            return;
        le(this, At, n);
        const s = () => {
                if (!t)
                    return !0;
                const {notifyOnChangeProps: o} = this.options
                    , u = typeof o == "function" ? o() : o;
                if (u === "all" || !u && !L(this, Ii).size)
                    return !0;
                const l = new Set(u ?? L(this, Ii));
                return this.options.throwOnError && l.add("error"),
                    Object.keys(L(this, At)).some(d => {
                            const f = d;
                            return L(this, At)[f] !== t[f] && l.has(f)
                        }
                    )
            }
        ;
        Oe(this, Ie, Ix).call(this, {
            listeners: s()
        })
    }
    onQueryUpdate() {
        this.updateResult(),
        this.hasListeners() && Oe(this, Ie, nh).call(this)
    }
}
    ,
    Ft = new WeakMap,
    Le = new WeakMap,
    Ca = new WeakMap,
    At = new WeakMap,
    As = new WeakMap,
    Mi = new WeakMap,
    nr = new WeakMap,
    Ur = new WeakMap,
    Pa = new WeakMap,
    ji = new WeakMap,
    Di = new WeakMap,
    _s = new WeakMap,
    Ns = new WeakMap,
    zr = new WeakMap,
    Ii = new WeakMap,
    Ie = new WeakSet,
    Go = function(t) {
        Oe(this, Ie, ih).call(this);
        let n = L(this, Le).fetch(this.options, t);
        return t != null && t.throwOnError || (n = n.catch(Bt)),
            n
    }
    ,
    Zf = function() {
        Oe(this, Ie, rh).call(this);
        const t = Qr(this.options.staleTime, L(this, Le));
        if (js || L(this, At).isStale || !Kf(t))
            return;
        const s = _x(L(this, At).dataUpdatedAt, t) + 1;
        le(this, _s, Ss.setTimeout( () => {
                L(this, At).isStale || this.updateResult()
            }
            , s))
    }
    ,
    eh = function() {
        return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(L(this, Le)) : this.options.refetchInterval) ?? !1
    }
    ,
    th = function(t) {
        Oe(this, Ie, sh).call(this),
            le(this, zr, t),
        !(js || ln(this.options.enabled, L(this, Le)) === !1 || !Kf(L(this, zr)) || L(this, zr) === 0) && le(this, Ns, Ss.setInterval( () => {
                (this.options.refetchIntervalInBackground || rp.isFocused()) && Oe(this, Ie, Go).call(this)
            }
            , L(this, zr)))
    }
    ,
    nh = function() {
        Oe(this, Ie, Zf).call(this),
            Oe(this, Ie, th).call(this, Oe(this, Ie, eh).call(this))
    }
    ,
    rh = function() {
        L(this, _s) && (Ss.clearTimeout(L(this, _s)),
            le(this, _s, void 0))
    }
    ,
    sh = function() {
        L(this, Ns) && (Ss.clearInterval(L(this, Ns)),
            le(this, Ns, void 0))
    }
    ,
    ih = function() {
        const t = L(this, Ft).getQueryCache().build(L(this, Ft), this.options);
        if (t === L(this, Le))
            return;
        const n = L(this, Le);
        le(this, Le, t),
            le(this, Ca, t.state),
        this.hasListeners() && (n == null || n.removeObserver(this),
            t.addObserver(this))
    }
    ,
    Ix = function(t) {
        vt.batch( () => {
                t.listeners && this.listeners.forEach(n => {
                        n(L(this, At))
                    }
                ),
                    L(this, Ft).getQueryCache().notify({
                        query: L(this, Le),
                        type: "observerResultsUpdated"
                    })
            }
        )
    }
    ,
    tx);
function vk(e, t) {
    return ln(t.enabled, e) !== !1 && e.state.data === void 0 && !(e.state.status === "error" && t.retryOnMount === !1)
}
function Sv(e, t) {
    return vk(e, t) || e.state.data !== void 0 && oh(e, t, t.refetchOnMount)
}
function oh(e, t, n) {
    if (ln(t.enabled, e) !== !1 && Qr(t.staleTime, e) !== "static") {
        const s = typeof n == "function" ? n(e) : n;
        return s === "always" || s !== !1 && sp(e, t)
    }
    return !1
}
function bv(e, t, n, s) {
    return (e !== t || ln(s.enabled, e) === !1) && (!n.suspense || e.state.status !== "error") && sp(e, n)
}
function sp(e, t) {
    return ln(t.enabled, e) !== !1 && e.isStaleByTime(Qr(t.staleTime, e))
}
function wk(e, t) {
    return !Qf(e.getCurrentResult(), t)
}
function Ev(e) {
    return {
        onFetch: (t, n) => {
            var m, y, v, S, E;
            const s = t.options
                , o = (v = (y = (m = t.fetchOptions) == null ? void 0 : m.meta) == null ? void 0 : y.fetchMore) == null ? void 0 : v.direction
                , u = ((S = t.state.data) == null ? void 0 : S.pages) || []
                , l = ((E = t.state.data) == null ? void 0 : E.pageParams) || [];
            let d = {
                pages: [],
                pageParams: []
            }
                , f = 0;
            const p = async () => {
                    let w = !1;
                    const x = R => {
                            Object.defineProperty(R, "signal", {
                                enumerable: !0,
                                get: () => (t.signal.aborted ? w = !0 : t.signal.addEventListener("abort", () => {
                                        w = !0
                                    }
                                ),
                                    t.signal)
                            })
                        }
                        , T = Ox(t.options, t.fetchOptions)
                        , k = async (R, _, D) => {
                            if (w)
                                return Promise.reject();
                            if (_ == null && R.pages.length)
                                return Promise.resolve(R);
                            const $ = ( () => {
                                    const X = {
                                        client: t.client,
                                        queryKey: t.queryKey,
                                        pageParam: _,
                                        direction: D ? "backward" : "forward",
                                        meta: t.options.meta
                                    };
                                    return x(X),
                                        X
                                }
                            )()
                                , O = await T($)
                                , {maxPages: W} = t.options
                                , q = D ? uk : lk;
                            return {
                                pages: q(R.pages, O, W),
                                pageParams: q(R.pageParams, _, W)
                            }
                        }
                    ;
                    if (o && u.length) {
                        const R = o === "backward"
                            , _ = R ? xk : Cv
                            , D = {
                            pages: u,
                            pageParams: l
                        }
                            , H = _(s, D);
                        d = await k(D, H, R)
                    } else {
                        const R = e ?? u.length;
                        do {
                            const _ = f === 0 ? l[0] ?? s.initialPageParam : Cv(s, d);
                            if (f > 0 && _ == null)
                                break;
                            d = await k(d, _),
                                f++
                        } while (f < R)
                    }
                    return d
                }
            ;
            t.options.persister ? t.fetchFn = () => {
                    var w, x;
                    return (x = (w = t.options).persister) == null ? void 0 : x.call(w, p, {
                        client: t.client,
                        queryKey: t.queryKey,
                        meta: t.options.meta,
                        signal: t.signal
                    }, n)
                }
                : t.fetchFn = p
        }
    }
}
function Cv(e, {pages: t, pageParams: n}) {
    const s = t.length - 1;
    return t.length > 0 ? e.getNextPageParam(t[s], t, n[s], n) : void 0
}
function xk(e, {pages: t, pageParams: n}) {
    var s;
    return t.length > 0 ? (s = e.getPreviousPageParam) == null ? void 0 : s.call(e, t[0], t, n[0], n) : void 0
}
var Ta, On, _t, Os, Ln, Mr, nx, Sk = (nx = class extends jx {
    constructor(t) {
        super();
        xe(this, Ln);
        xe(this, Ta);
        xe(this, On);
        xe(this, _t);
        xe(this, Os);
        le(this, Ta, t.client),
            this.mutationId = t.mutationId,
            le(this, _t, t.mutationCache),
            le(this, On, []),
            this.state = t.state || bk(),
            this.setOptions(t.options),
            this.scheduleGc()
    }
    setOptions(t) {
        this.options = t,
            this.updateGcTime(this.options.gcTime)
    }
    get meta() {
        return this.options.meta
    }
    addObserver(t) {
        L(this, On).includes(t) || (L(this, On).push(t),
            this.clearGcTimeout(),
            L(this, _t).notify({
                type: "observerAdded",
                mutation: this,
                observer: t
            }))
    }
    removeObserver(t) {
        le(this, On, L(this, On).filter(n => n !== t)),
            this.scheduleGc(),
            L(this, _t).notify({
                type: "observerRemoved",
                mutation: this,
                observer: t
            })
    }
    optionalRemove() {
        L(this, On).length || (this.state.status === "pending" ? this.scheduleGc() : L(this, _t).remove(this))
    }
    continue() {
        var t;
        return ((t = L(this, Os)) == null ? void 0 : t.continue()) ?? this.execute(this.state.variables)
    }
    async execute(t) {
        var l, d, f, p, m, y, v, S, E, w, x, T, k, R, _, D, H, $, O, W;
        const n = () => {
            Oe(this, Ln, Mr).call(this, {
                type: "continue"
            })
        }
            , s = {
            client: L(this, Ta),
            meta: this.options.meta,
            mutationKey: this.options.mutationKey
        };
        le(this, Os, Mx({
            fn: () => this.options.mutationFn ? this.options.mutationFn(t, s) : Promise.reject(new Error("No mutationFn found")),
            onFail: (q, X) => {
                Oe(this, Ln, Mr).call(this, {
                    type: "failed",
                    failureCount: q,
                    error: X
                })
            }
            ,
            onPause: () => {
                Oe(this, Ln, Mr).call(this, {
                    type: "pause"
                })
            }
            ,
            onContinue: n,
            retry: this.options.retry ?? 0,
            retryDelay: this.options.retryDelay,
            networkMode: this.options.networkMode,
            canRun: () => L(this, _t).canRun(this)
        }));
        const o = this.state.status === "pending"
            , u = !L(this, Os).canStart();
        try {
            if (o)
                n();
            else {
                Oe(this, Ln, Mr).call(this, {
                    type: "pending",
                    variables: t,
                    isPaused: u
                }),
                    await ((d = (l = L(this, _t).config).onMutate) == null ? void 0 : d.call(l, t, this, s));
                const X = await ((p = (f = this.options).onMutate) == null ? void 0 : p.call(f, t, s));
                X !== this.state.context && Oe(this, Ln, Mr).call(this, {
                    type: "pending",
                    context: X,
                    variables: t,
                    isPaused: u
                })
            }
            const q = await L(this, Os).start();
            return await ((y = (m = L(this, _t).config).onSuccess) == null ? void 0 : y.call(m, q, t, this.state.context, this, s)),
                await ((S = (v = this.options).onSuccess) == null ? void 0 : S.call(v, q, t, this.state.context, s)),
                await ((w = (E = L(this, _t).config).onSettled) == null ? void 0 : w.call(E, q, null, this.state.variables, this.state.context, this, s)),
                await ((T = (x = this.options).onSettled) == null ? void 0 : T.call(x, q, null, t, this.state.context, s)),
                Oe(this, Ln, Mr).call(this, {
                    type: "success",
                    data: q
                }),
                q
        } catch (q) {
            try {
                throw await ((R = (k = L(this, _t).config).onError) == null ? void 0 : R.call(k, q, t, this.state.context, this, s)),
                    await ((D = (_ = this.options).onError) == null ? void 0 : D.call(_, q, t, this.state.context, s)),
                    await (($ = (H = L(this, _t).config).onSettled) == null ? void 0 : $.call(H, void 0, q, this.state.variables, this.state.context, this, s)),
                    await ((W = (O = this.options).onSettled) == null ? void 0 : W.call(O, void 0, q, t, this.state.context, s)),
                    q
            } finally {
                Oe(this, Ln, Mr).call(this, {
                    type: "error",
                    error: q
                })
            }
        } finally {
            L(this, _t).runNext(this)
        }
    }
}
    ,
    Ta = new WeakMap,
    On = new WeakMap,
    _t = new WeakMap,
    Os = new WeakMap,
    Ln = new WeakSet,
    Mr = function(t) {
        const n = s => {
                switch (t.type) {
                    case "failed":
                        return {
                            ...s,
                            failureCount: t.failureCount,
                            failureReason: t.error
                        };
                    case "pause":
                        return {
                            ...s,
                            isPaused: !0
                        };
                    case "continue":
                        return {
                            ...s,
                            isPaused: !1
                        };
                    case "pending":
                        return {
                            ...s,
                            context: t.context,
                            data: void 0,
                            failureCount: 0,
                            failureReason: null,
                            error: null,
                            isPaused: t.isPaused,
                            status: "pending",
                            variables: t.variables,
                            submittedAt: Date.now()
                        };
                    case "success":
                        return {
                            ...s,
                            data: t.data,
                            failureCount: 0,
                            failureReason: null,
                            error: null,
                            status: "success",
                            isPaused: !1
                        };
                    case "error":
                        return {
                            ...s,
                            data: void 0,
                            error: t.error,
                            failureCount: s.failureCount + 1,
                            failureReason: t.error,
                            isPaused: !1,
                            status: "error"
                        }
                }
            }
        ;
        this.state = n(this.state),
            vt.batch( () => {
                    L(this, On).forEach(s => {
                            s.onMutationUpdate(t)
                        }
                    ),
                        L(this, _t).notify({
                            mutation: this,
                            type: "updated",
                            action: t
                        })
                }
            )
    }
    ,
    nx);
function bk() {
    return {
        context: void 0,
        data: void 0,
        error: null,
        failureCount: 0,
        failureReason: null,
        isPaused: !1,
        status: "idle",
        variables: void 0,
        submittedAt: 0
    }
}
var rr, xn, ka, rx, Ek = (rx = class extends Ra {
    constructor(t={}) {
        super();
        xe(this, rr);
        xe(this, xn);
        xe(this, ka);
        this.config = t,
            le(this, rr, new Set),
            le(this, xn, new Map),
            le(this, ka, 0)
    }
    build(t, n, s) {
        const o = new Sk({
            client: t,
            mutationCache: this,
            mutationId: ++Xl(this, ka)._,
            options: t.defaultMutationOptions(n),
            state: s
        });
        return this.add(o),
            o
    }
    add(t) {
        L(this, rr).add(t);
        const n = eu(t);
        if (typeof n == "string") {
            const s = L(this, xn).get(n);
            s ? s.push(t) : L(this, xn).set(n, [t])
        }
        this.notify({
            type: "added",
            mutation: t
        })
    }
    remove(t) {
        if (L(this, rr).delete(t)) {
            const n = eu(t);
            if (typeof n == "string") {
                const s = L(this, xn).get(n);
                if (s)
                    if (s.length > 1) {
                        const o = s.indexOf(t);
                        o !== -1 && s.splice(o, 1)
                    } else
                        s[0] === t && L(this, xn).delete(n)
            }
        }
        this.notify({
            type: "removed",
            mutation: t
        })
    }
    canRun(t) {
        const n = eu(t);
        if (typeof n == "string") {
            const s = L(this, xn).get(n)
                , o = s == null ? void 0 : s.find(u => u.state.status === "pending");
            return !o || o === t
        } else
            return !0
    }
    runNext(t) {
        var s;
        const n = eu(t);
        if (typeof n == "string") {
            const o = (s = L(this, xn).get(n)) == null ? void 0 : s.find(u => u !== t && u.state.isPaused);
            return (o == null ? void 0 : o.continue()) ?? Promise.resolve()
        } else
            return Promise.resolve()
    }
    clear() {
        vt.batch( () => {
                L(this, rr).forEach(t => {
                        this.notify({
                            type: "removed",
                            mutation: t
                        })
                    }
                ),
                    L(this, rr).clear(),
                    L(this, xn).clear()
            }
        )
    }
    getAll() {
        return Array.from(L(this, rr))
    }
    find(t) {
        const n = {
            exact: !0,
            ...t
        };
        return this.getAll().find(s => yv(n, s))
    }
    findAll(t={}) {
        return this.getAll().filter(n => yv(t, n))
    }
    notify(t) {
        vt.batch( () => {
                this.listeners.forEach(n => {
                        n(t)
                    }
                )
            }
        )
    }
    resumePausedMutations() {
        const t = this.getAll().filter(n => n.state.isPaused);
        return vt.batch( () => Promise.all(t.map(n => n.continue().catch(Bt))))
    }
}
    ,
    rr = new WeakMap,
    xn = new WeakMap,
    ka = new WeakMap,
    rx);
function eu(e) {
    var t;
    return (t = e.options.scope) == null ? void 0 : t.id
}
var Mn, sx, Ck = (sx = class extends Ra {
    constructor(t={}) {
        super();
        xe(this, Mn);
        this.config = t,
            le(this, Mn, new Map)
    }
    build(t, n, s) {
        const o = n.queryKey
            , u = n.queryHash ?? tp(o, n);
        let l = this.get(u);
        return l || (l = new gk({
            client: t,
            queryKey: o,
            queryHash: u,
            options: t.defaultQueryOptions(n),
            state: s,
            defaultOptions: t.getQueryDefaults(o)
        }),
            this.add(l)),
            l
    }
    add(t) {
        L(this, Mn).has(t.queryHash) || (L(this, Mn).set(t.queryHash, t),
            this.notify({
                type: "added",
                query: t
            }))
    }
    remove(t) {
        const n = L(this, Mn).get(t.queryHash);
        n && (t.destroy(),
        n === t && L(this, Mn).delete(t.queryHash),
            this.notify({
                type: "removed",
                query: t
            }))
    }
    clear() {
        vt.batch( () => {
                this.getAll().forEach(t => {
                        this.remove(t)
                    }
                )
            }
        )
    }
    get(t) {
        return L(this, Mn).get(t)
    }
    getAll() {
        return [...L(this, Mn).values()]
    }
    find(t) {
        const n = {
            exact: !0,
            ...t
        };
        return this.getAll().find(s => gv(n, s))
    }
    findAll(t={}) {
        const n = this.getAll();
        return Object.keys(t).length > 0 ? n.filter(s => gv(t, s)) : n
    }
    notify(t) {
        vt.batch( () => {
                this.listeners.forEach(n => {
                        n(t)
                    }
                )
            }
        )
    }
    onFocus() {
        vt.batch( () => {
                this.getAll().forEach(t => {
                        t.onFocus()
                    }
                )
            }
        )
    }
    onOnline() {
        vt.batch( () => {
                this.getAll().forEach(t => {
                        t.onOnline()
                    }
                )
            }
        )
    }
}
    ,
    Mn = new WeakMap,
    sx), Qe, $r, Wr, Fi, Bi, Hr, Vi, Ui, ix, Pk = (ix = class {
    constructor(e={}) {
        xe(this, Qe);
        xe(this, $r);
        xe(this, Wr);
        xe(this, Fi);
        xe(this, Bi);
        xe(this, Hr);
        xe(this, Vi);
        xe(this, Ui);
        le(this, Qe, e.queryCache || new Ck),
            le(this, $r, e.mutationCache || new Ek),
            le(this, Wr, e.defaultOptions || {}),
            le(this, Fi, new Map),
            le(this, Bi, new Map),
            le(this, Hr, 0)
    }
    mount() {
        Xl(this, Hr)._++,
        L(this, Hr) === 1 && (le(this, Vi, rp.subscribe(async e => {
                e && (await this.resumePausedMutations(),
                    L(this, Qe).onFocus())
            }
        )),
            le(this, Ui, _u.subscribe(async e => {
                    e && (await this.resumePausedMutations(),
                        L(this, Qe).onOnline())
                }
            )))
    }
    unmount() {
        var e, t;
        Xl(this, Hr)._--,
        L(this, Hr) === 0 && ((e = L(this, Vi)) == null || e.call(this),
            le(this, Vi, void 0),
        (t = L(this, Ui)) == null || t.call(this),
            le(this, Ui, void 0))
    }
    isFetching(e) {
        return L(this, Qe).findAll({
            ...e,
            fetchStatus: "fetching"
        }).length
    }
    isMutating(e) {
        return L(this, $r).findAll({
            ...e,
            status: "pending"
        }).length
    }
    getQueryData(e) {
        var n;
        const t = this.defaultQueryOptions({
            queryKey: e
        });
        return (n = L(this, Qe).get(t.queryHash)) == null ? void 0 : n.state.data
    }
    ensureQueryData(e) {
        const t = this.defaultQueryOptions(e)
            , n = L(this, Qe).build(this, t)
            , s = n.state.data;
        return s === void 0 ? this.fetchQuery(e) : (e.revalidateIfStale && n.isStaleByTime(Qr(t.staleTime, n)) && this.prefetchQuery(t),
            Promise.resolve(s))
    }
    getQueriesData(e) {
        return L(this, Qe).findAll(e).map( ({queryKey: t, state: n}) => {
                const s = n.data;
                return [t, s]
            }
        )
    }
    setQueryData(e, t, n) {
        const s = this.defaultQueryOptions({
            queryKey: e
        })
            , o = L(this, Qe).get(s.queryHash)
            , u = o == null ? void 0 : o.state.data
            , l = ik(t, u);
        if (l !== void 0)
            return L(this, Qe).build(this, s).setData(l, {
                ...n,
                manual: !0
            })
    }
    setQueriesData(e, t, n) {
        return vt.batch( () => L(this, Qe).findAll(e).map( ({queryKey: s}) => [s, this.setQueryData(s, t, n)]))
    }
    getQueryState(e) {
        var n;
        const t = this.defaultQueryOptions({
            queryKey: e
        });
        return (n = L(this, Qe).get(t.queryHash)) == null ? void 0 : n.state
    }
    removeQueries(e) {
        const t = L(this, Qe);
        vt.batch( () => {
                t.findAll(e).forEach(n => {
                        t.remove(n)
                    }
                )
            }
        )
    }
    resetQueries(e, t) {
        const n = L(this, Qe);
        return vt.batch( () => (n.findAll(e).forEach(s => {
                s.reset()
            }
        ),
            this.refetchQueries({
                type: "active",
                ...e
            }, t)))
    }
    cancelQueries(e, t={}) {
        const n = {
            revert: !0,
            ...t
        }
            , s = vt.batch( () => L(this, Qe).findAll(e).map(o => o.cancel(n)));
        return Promise.all(s).then(Bt).catch(Bt)
    }
    invalidateQueries(e, t={}) {
        return vt.batch( () => (L(this, Qe).findAll(e).forEach(n => {
                n.invalidate()
            }
        ),
            (e == null ? void 0 : e.refetchType) === "none" ? Promise.resolve() : this.refetchQueries({
                ...e,
                type: (e == null ? void 0 : e.refetchType) ?? (e == null ? void 0 : e.type) ?? "active"
            }, t)))
    }
    refetchQueries(e, t={}) {
        const n = {
            ...t,
            cancelRefetch: t.cancelRefetch ?? !0
        }
            , s = vt.batch( () => L(this, Qe).findAll(e).filter(o => !o.isDisabled() && !o.isStatic()).map(o => {
                let u = o.fetch(void 0, n);
                return n.throwOnError || (u = u.catch(Bt)),
                    o.state.fetchStatus === "paused" ? Promise.resolve() : u
            }
        ));
        return Promise.all(s).then(Bt)
    }
    fetchQuery(e) {
        const t = this.defaultQueryOptions(e);
        t.retry === void 0 && (t.retry = !1);
        const n = L(this, Qe).build(this, t);
        return n.isStaleByTime(Qr(t.staleTime, n)) ? n.fetch(t) : Promise.resolve(n.state.data)
    }
    prefetchQuery(e) {
        return this.fetchQuery(e).then(Bt).catch(Bt)
    }
    fetchInfiniteQuery(e) {
        return e.behavior = Ev(e.pages),
            this.fetchQuery(e)
    }
    prefetchInfiniteQuery(e) {
        return this.fetchInfiniteQuery(e).then(Bt).catch(Bt)
    }
    ensureInfiniteQueryData(e) {
        return e.behavior = Ev(e.pages),
            this.ensureQueryData(e)
    }
    resumePausedMutations() {
        return _u.isOnline() ? L(this, $r).resumePausedMutations() : Promise.resolve()
    }
    getQueryCache() {
        return L(this, Qe)
    }
    getMutationCache() {
        return L(this, $r)
    }
    getDefaultOptions() {
        return L(this, Wr)
    }
    setDefaultOptions(e) {
        le(this, Wr, e)
    }
    setQueryDefaults(e, t) {
        L(this, Fi).set(da(e), {
            queryKey: e,
            defaultOptions: t
        })
    }
    getQueryDefaults(e) {
        const t = [...L(this, Fi).values()]
            , n = {};
        return t.forEach(s => {
                fa(e, s.queryKey) && Object.assign(n, s.defaultOptions)
            }
        ),
            n
    }
    setMutationDefaults(e, t) {
        L(this, Bi).set(da(e), {
            mutationKey: e,
            defaultOptions: t
        })
    }
    getMutationDefaults(e) {
        const t = [...L(this, Bi).values()]
            , n = {};
        return t.forEach(s => {
                fa(e, s.mutationKey) && Object.assign(n, s.defaultOptions)
            }
        ),
            n
    }
    defaultQueryOptions(e) {
        if (e._defaulted)
            return e;
        const t = {
            ...L(this, Wr).queries,
            ...this.getQueryDefaults(e.queryKey),
            ...e,
            _defaulted: !0
        };
        return t.queryHash || (t.queryHash = tp(t.queryKey, t)),
        t.refetchOnReconnect === void 0 && (t.refetchOnReconnect = t.networkMode !== "always"),
        t.throwOnError === void 0 && (t.throwOnError = !!t.suspense),
        !t.networkMode && t.persister && (t.networkMode = "offlineFirst"),
        t.queryFn === np && (t.enabled = !1),
            t
    }
    defaultMutationOptions(e) {
        return e != null && e._defaulted ? e : {
            ...L(this, Wr).mutations,
            ...(e == null ? void 0 : e.mutationKey) && this.getMutationDefaults(e.mutationKey),
            ...e,
            _defaulted: !0
        }
    }
    clear() {
        L(this, Qe).clear(),
            L(this, $r).clear()
    }
}
    ,
    Qe = new WeakMap,
    $r = new WeakMap,
    Wr = new WeakMap,
    Fi = new WeakMap,
    Bi = new WeakMap,
    Hr = new WeakMap,
    Vi = new WeakMap,
    Ui = new WeakMap,
    ix), Fx = P.createContext(void 0), Tk = e => {
    const t = P.useContext(Fx);
    if (!t)
        throw new Error("No QueryClient set, use QueryClientProvider to set one");
    return t
}
    , kk = ({client: e, children: t}) => (P.useEffect( () => (e.mount(),
        () => {
            e.unmount()
        }
), [e]),
    b.jsx(Fx.Provider, {
        value: e,
        children: t
    })), Bx = P.createContext(!1), Rk = () => P.useContext(Bx);
Bx.Provider;
function Ak() {
    let e = !1;
    return {
        clearReset: () => {
            e = !1
        }
        ,
        reset: () => {
            e = !0
        }
        ,
        isReset: () => e
    }
}
var _k = P.createContext(Ak())
    , Nk = () => P.useContext(_k)
    , Ok = (e, t) => {
    (e.suspense || e.throwOnError || e.experimental_prefetchInRender) && (t.isReset() || (e.retryOnMount = !1))
}
    , Lk = e => {
    P.useEffect( () => {
            e.clearReset()
        }
        , [e])
}
    , Mk = ({result: e, errorResetBoundary: t, throwOnError: n, query: s, suspense: o}) => e.isError && !t.isReset() && !e.isFetching && s && (o && e.data === void 0 || ck(n, [e.error, s]))
    , jk = e => {
    if (e.suspense) {
        const n = o => o === "static" ? o : Math.max(o ?? 1e3, 1e3)
            , s = e.staleTime;
        e.staleTime = typeof s == "function" ? (...o) => n(s(...o)) : n(s),
        typeof e.gcTime == "number" && (e.gcTime = Math.max(e.gcTime, 1e3))
    }
}
    , Dk = (e, t) => e.isLoading && e.isFetching && !t
    , Ik = (e, t) => (e == null ? void 0 : e.suspense) && t.isPending
    , Pv = (e, t, n) => t.fetchOptimistic(e).catch( () => {
        n.clearReset()
    }
);
function Fk(e, t, n) {
    var y, v, S, E, w;
    const s = Rk()
        , o = Nk()
        , u = Tk()
        , l = u.defaultQueryOptions(e);
    (v = (y = u.getDefaultOptions().queries) == null ? void 0 : y._experimental_beforeQuery) == null || v.call(y, l),
        l._optimisticResults = s ? "isRestoring" : "optimistic",
        jk(l),
        Ok(l, o),
        Lk(o);
    const d = !u.getQueryCache().get(l.queryHash)
        , [f] = P.useState( () => new t(u,l))
        , p = f.getOptimisticResult(l)
        , m = !s && e.subscribed !== !1;
    if (P.useSyncExternalStore(P.useCallback(x => {
            const T = m ? f.subscribe(vt.batchCalls(x)) : Bt;
            return f.updateResult(),
                T
        }
        , [f, m]), () => f.getCurrentResult(), () => f.getCurrentResult()),
        P.useEffect( () => {
                f.setOptions(l)
            }
            , [l, f]),
        Ik(l, p))
        throw Pv(l, f, o);
    if (Mk({
        result: p,
        errorResetBoundary: o,
        throwOnError: l.throwOnError,
        query: u.getQueryCache().get(l.queryHash),
        suspense: l.suspense
    }))
        throw p.error;
    if ((E = (S = u.getDefaultOptions().queries) == null ? void 0 : S._experimental_afterQuery) == null || E.call(S, l, p),
    l.experimental_prefetchInRender && !js && Dk(p, s)) {
        const x = d ? Pv(l, f, o) : (w = u.getQueryCache().get(l.queryHash)) == null ? void 0 : w.promise;
        x == null || x.catch(Bt).finally( () => {
                f.updateResult()
            }
        )
    }
    return l.notifyOnChangeProps ? p : f.trackResult(p)
}
function ip(e, t) {
    return Fk(e, yk)
}
const Bk = new Pk({
    defaultOptions: {
        queries: {
            refetchOnWindowFocus: !1,
            retry: 1
        }
    }
});
function Vk() {
    const [e,t] = P.useState(!1)
        , n = P.useRef(!1)
        , [s,o] = P.useState(!1)
        , u = P.useRef(!1)
        , [l,d] = P.useState(!1)
        , f = P.useRef(!1)
        , p = P.useRef([])
        , m = P.useRef([])
        , y = P.useRef([])
        , v = P.useRef(null)
        , S = (O=!1) => {
            const W = document.createElement("div");
            return W.style.position = "absolute",
                W.style.pointerEvents = "none",
                W.style.transition = "all 0.1s ease-in-out",
                W.style.zIndex = "9999",
                O ? W.style.border = "2px solid #2563EB" : (W.style.border = "2px solid #95a5fc",
                    W.style.backgroundColor = "rgba(99, 102, 241, 0.05)"),
                W
        }
        , E = (O, W, q=!1) => {
            if (!W || !n.current)
                return;
            W.offsetWidth;
            const X = W.getBoundingClientRect();
            O.style.top = `${X.top + window.scrollY}px`,
                O.style.left = `${X.left + window.scrollX}px`,
                O.style.width = `${X.width}px`,
                O.style.height = `${X.height}px`;
            let z = O.querySelector("div");
            z || (z = document.createElement("div"),
                z.textContent = W.tagName.toLowerCase(),
                z.style.position = "absolute",
                z.style.top = "-27px",
                z.style.left = "-2px",
                z.style.padding = "2px 8px",
                z.style.fontSize = "11px",
                z.style.fontWeight = q ? "500" : "400",
                z.style.color = q ? "#ffffff" : "#526cff",
                z.style.backgroundColor = q ? "#526cff" : "#DBEAFE",
                z.style.borderRadius = "3px",
                z.style.boxShadow = "none",
                z.style.minWidth = "24px",
                z.style.textAlign = "center",
                O.appendChild(z))
        }
        , w = O => {
            if (!O)
                return [];
            const W = [...document.querySelectorAll(`[data-source-location="${O}"]`)];
            return W.length > 0 ? W : [...document.querySelectorAll(`[data-visual-selector-id="${O}"]`)]
        }
        , x = () => {
            p.current.forEach(O => {
                    O && O.parentNode && O.remove()
                }
            ),
                p.current = [],
                y.current = []
        }
        , T = O => {
            if (!n.current || u.current)
                return;
            if (f.current) {
                x();
                return
            }
            if (O.target.tagName.toLowerCase() === "path") {
                x();
                return
            }
            const W = O.target.closest("[data-source-location], [data-visual-selector-id]");
            if (!W) {
                x();
                return
            }
            const q = W.dataset.sourceLocation || W.dataset.visualSelectorId;
            if (W.dataset.sourceLocation,
            v.current === q) {
                x();
                return
            }
            const X = w(q);
            x(),
                X.forEach(z => {
                        const J = S(!1);
                        document.body.appendChild(J),
                            p.current.push(J),
                            E(J, z)
                    }
                ),
                y.current = X
        }
        , k = () => {
            u.current || x()
        }
        , R = O => {
            var ie;
            if (!n.current)
                return;
            if (f.current) {
                O.preventDefault(),
                    O.stopPropagation(),
                    O.stopImmediatePropagation(),
                    window.parent.postMessage({
                        type: "close-dropdowns"
                    }, "*");
                return
            }
            if (O.target.tagName.toLowerCase() === "path")
                return;
            O.preventDefault(),
                O.stopPropagation(),
                O.stopImmediatePropagation();
            const W = O.target.closest("[data-source-location], [data-visual-selector-id]");
            if (!W)
                return;
            const q = W.dataset.sourceLocation || W.dataset.visualSelectorId;
            W.dataset.sourceLocation,
                m.current.forEach(ne => {
                        ne && ne.parentNode && ne.remove()
                    }
                ),
                m.current = [],
                w(q).forEach(ne => {
                        const re = S(!0);
                        document.body.appendChild(re),
                            m.current.push(re),
                            E(re, ne, !0)
                    }
                ),
                v.current = q,
                x();
            const z = W.getBoundingClientRect()
                , J = {
                top: z.top,
                left: z.left,
                right: z.right,
                bottom: z.bottom,
                width: z.width,
                height: z.height,
                centerX: z.left + z.width / 2,
                centerY: z.top + z.height / 2
            }
                , ae = {
                type: "element-selected",
                tagName: W.tagName,
                classes: ((ie = W.className) == null ? void 0 : ie.baseVal) || W.className || "",
                visualSelectorId: q,
                content: W.innerText,
                dataSourceLocation: W.dataset.sourceLocation,
                isDynamicContent: W.dataset.dynamicContent === "true",
                linenumber: W.dataset.linenumber,
                filename: W.dataset.filename,
                position: J
            };
            window.parent.postMessage(ae, "*")
        }
        , _ = () => {
            m.current.forEach(O => {
                    O && O.parentNode && O.remove()
                }
            ),
                m.current = [],
                v.current = null
        }
        , D = (O, W, q=!1) => {
            const X = w(O);
            X.length !== 0 && (X.forEach(z => {
                    var J;
                    if (q)
                        z.className = W;
                    else {
                        const ae = ((J = z.className) == null ? void 0 : J.baseVal) || z.className || "";
                        z.className = Ex(ae, W)
                    }
                }
            ),
                setTimeout( () => {
                        var z, J;
                        v.current === O && m.current.forEach( (ae, ie) => {
                                ie < X.length && E(ae, X[ie])
                            }
                        ),
                        y.current.length > 0 && ((J = (z = y.current[0]) == null ? void 0 : z.dataset) == null ? void 0 : J.visualSelectorId) === O && p.current.forEach( (ie, ne) => {
                                ne < y.current.length && E(ie, y.current[ne])
                            }
                        )
                    }
                    , 50))
        }
        , H = (O, W) => {
            const q = w(O);
            q.length !== 0 && (q.forEach(X => {
                    X.innerText = W
                }
            ),
                setTimeout( () => {
                        v.current === O && m.current.forEach( (X, z) => {
                                z < q.length && E(X, q[z])
                            }
                        )
                    }
                    , 50))
        }
        , $ = O => {
            t(O),
                n.current = O,
                O ? (document.body.style.cursor = "crosshair",
                    document.addEventListener("mouseover", T),
                    document.addEventListener("mouseout", k),
                    document.addEventListener("click", R, !0)) : (x(),
                    m.current.forEach(W => {
                            W && W.parentNode && W.remove()
                        }
                    ),
                    m.current = [],
                    y.current = [],
                    v.current = null,
                    document.body.style.cursor = "default",
                    document.removeEventListener("mouseover", T),
                    document.removeEventListener("mouseout", k),
                    document.removeEventListener("click", R, !0))
        }
    ;
    return P.useEffect( () => {
            document.querySelectorAll("[data-linenumber]:not([data-visual-selector-id])").forEach( (X, z) => {
                    const J = `visual-id-${X.dataset.filename}-${X.dataset.linenumber}-${z}`;
                    X.dataset.visualSelectorId = J
                }
            );
            const W = () => {
                    if (v.current) {
                        const X = w(v.current);
                        if (X.length > 0) {
                            const J = X[0].getBoundingClientRect()
                                , ae = window.innerHeight
                                , ie = window.innerWidth
                                , ne = J.top < ae && J.bottom > 0 && J.left < ie && J.right > 0
                                , re = {
                                top: J.top,
                                left: J.left,
                                right: J.right,
                                bottom: J.bottom,
                                width: J.width,
                                height: J.height,
                                centerX: J.left + J.width / 2,
                                centerY: J.top + J.height / 2
                            };
                            window.parent.postMessage({
                                type: "element-position-update",
                                position: re,
                                isInViewport: ne,
                                visualSelectorId: v.current
                            }, "*")
                        }
                    }
                }
                , q = X => {
                    const z = X.data;
                    switch (z.type) {
                        case "toggle-visual-edit-mode":
                            $(z.data.enabled);
                            break;
                        case "update-classes":
                            z.data && z.data.classes !== void 0 ? D(z.data.visualSelectorId, z.data.classes, z.data.replace || !1) : console.warn("[Agent] Invalid update-classes message:", z);
                            break;
                        case "unselect-element":
                            _();
                            break;
                        case "refresh-page":
                            window.location.reload();
                            break;
                        case "update-content":
                            z.data && z.data.content !== void 0 ? H(z.data.visualSelectorId, z.data.content) : console.warn("[Agent] Invalid update-content message:", z);
                            break;
                        case "request-element-position":
                            if (v.current) {
                                const J = w(v.current);
                                if (J.length > 0) {
                                    const ie = J[0].getBoundingClientRect()
                                        , ne = window.innerHeight
                                        , re = window.innerWidth
                                        , I = ie.top < ne && ie.bottom > 0 && ie.left < re && ie.right > 0
                                        , se = {
                                        top: ie.top,
                                        left: ie.left,
                                        right: ie.right,
                                        bottom: ie.bottom,
                                        width: ie.width,
                                        height: ie.height,
                                        centerX: ie.left + ie.width / 2,
                                        centerY: ie.top + ie.height / 2
                                    };
                                    window.parent.postMessage({
                                        type: "element-position-update",
                                        position: se,
                                        isInViewport: I,
                                        visualSelectorId: v.current
                                    }, "*")
                                }
                            }
                            break;
                        case "popover-drag-state":
                            z.data && z.data.isDragging !== void 0 && (o(z.data.isDragging),
                                u.current = z.data.isDragging,
                            z.data.isDragging && x());
                            break;
                        case "dropdown-state":
                            z.data && z.data.isOpen !== void 0 && (d(z.data.isOpen),
                                f.current = z.data.isOpen,
                            z.data.isOpen && x());
                            break
                    }
                }
            ;
            return window.addEventListener("message", q),
                window.addEventListener("scroll", W, !0),
                document.addEventListener("scroll", W, !0),
                window.parent.postMessage({
                    type: "visual-edit-agent-ready"
                }, "*"),
                () => {
                    window.removeEventListener("message", q),
                        window.removeEventListener("scroll", W, !0),
                        document.removeEventListener("scroll", W, !0),
                        document.removeEventListener("mouseover", T),
                        document.removeEventListener("mouseout", k),
                        document.removeEventListener("click", R, !0),
                        x(),
                        m.current.forEach(X => {
                                X && X.parentNode && X.remove()
                            }
                        )
                }
        }
        , []),
        P.useEffect( () => {
                n.current = e
            }
            , [e]),
        P.useEffect( () => {
                u.current = s
            }
            , [s]),
        P.useEffect( () => {
                f.current = l
            }
            , [l]),
        P.useEffect( () => {
                const O = () => {
                    if (v.current) {
                        const q = w(v.current);
                        m.current.forEach( (X, z) => {
                                z < q.length && E(X, q[z])
                            }
                        )
                    }
                    y.current.length > 0 && p.current.forEach( (q, X) => {
                            X < y.current.length && E(q, y.current[X])
                        }
                    )
                }
                    , W = new MutationObserver(q => {
                        q.some(z => {
                                const J = ie => {
                                        if (ie.nodeType === Node.ELEMENT_NODE) {
                                            if (ie.dataset && ie.dataset.visualSelectorId)
                                                return !0;
                                            for (let ne = 0; ne < ie.children.length; ne++)
                                                if (J(ie.children[ne]))
                                                    return !0
                                        }
                                        return !1
                                    }
                                ;
                                return z.type === "attributes" && (z.attributeName === "style" || z.attributeName === "class" || z.attributeName === "width" || z.attributeName === "height") && J(z.target)
                            }
                        ) && setTimeout(O, 50)
                    }
                );
                return W.observe(document.body, {
                    attributes: !0,
                    childList: !0,
                    subtree: !0,
                    attributeFilter: ["style", "class", "width", "height"]
                }),
                    window.addEventListener("resize", O),
                    window.addEventListener("scroll", O),
                    () => {
                        window.removeEventListener("resize", O),
                            window.removeEventListener("scroll", O),
                            W.disconnect()
                    }
            }
            , []),
        null
}
var Aa = ox();
const Uk = Xh(Aa);
/**
 * @remix-run/router v1.23.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function ha() {
    return ha = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var s in n)
                Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
        }
        return e
    }
        ,
        ha.apply(this, arguments)
}
var qr;
(function(e) {
        e.Pop = "POP",
            e.Push = "PUSH",
            e.Replace = "REPLACE"
    }
)(qr || (qr = {}));
const Tv = "popstate";
function zk(e) {
    e === void 0 && (e = {});
    function t(s, o) {
        let {pathname: u, search: l, hash: d} = s.location;
        return ah("", {
            pathname: u,
            search: l,
            hash: d
        }, o.state && o.state.usr || null, o.state && o.state.key || "default")
    }
    function n(s, o) {
        return typeof o == "string" ? o : Nu(o)
    }
    return Wk(t, n, null, e)
}
function it(e, t) {
    if (e === !1 || e === null || typeof e > "u")
        throw new Error(t)
}
function Vx(e, t) {
    if (!e) {
        typeof console < "u" && console.warn(t);
        try {
            throw new Error(t)
        } catch {}
    }
}
function $k() {
    return Math.random().toString(36).substr(2, 8)
}
function kv(e, t) {
    return {
        usr: e.state,
        key: e.key,
        idx: t
    }
}
function ah(e, t, n, s) {
    return n === void 0 && (n = null),
        ha({
            pathname: typeof e == "string" ? e : e.pathname,
            search: "",
            hash: ""
        }, typeof t == "string" ? Gi(t) : t, {
            state: n,
            key: t && t.key || s || $k()
        })
}
function Nu(e) {
    let {pathname: t="/", search: n="", hash: s=""} = e;
    return n && n !== "?" && (t += n.charAt(0) === "?" ? n : "?" + n),
    s && s !== "#" && (t += s.charAt(0) === "#" ? s : "#" + s),
        t
}
function Gi(e) {
    let t = {};
    if (e) {
        let n = e.indexOf("#");
        n >= 0 && (t.hash = e.substr(n),
            e = e.substr(0, n));
        let s = e.indexOf("?");
        s >= 0 && (t.search = e.substr(s),
            e = e.substr(0, s)),
        e && (t.pathname = e)
    }
    return t
}
function Wk(e, t, n, s) {
    s === void 0 && (s = {});
    let {window: o=document.defaultView, v5Compat: u=!1} = s
        , l = o.history
        , d = qr.Pop
        , f = null
        , p = m();
    p == null && (p = 0,
        l.replaceState(ha({}, l.state, {
            idx: p
        }), ""));
    function m() {
        return (l.state || {
            idx: null
        }).idx
    }
    function y() {
        d = qr.Pop;
        let x = m()
            , T = x == null ? null : x - p;
        p = x,
        f && f({
            action: d,
            location: w.location,
            delta: T
        })
    }
    function v(x, T) {
        d = qr.Push;
        let k = ah(w.location, x, T);
        p = m() + 1;
        let R = kv(k, p)
            , _ = w.createHref(k);
        try {
            l.pushState(R, "", _)
        } catch (D) {
            if (D instanceof DOMException && D.name === "DataCloneError")
                throw D;
            o.location.assign(_)
        }
        u && f && f({
            action: d,
            location: w.location,
            delta: 1
        })
    }
    function S(x, T) {
        d = qr.Replace;
        let k = ah(w.location, x, T);
        p = m();
        let R = kv(k, p)
            , _ = w.createHref(k);
        l.replaceState(R, "", _),
        u && f && f({
            action: d,
            location: w.location,
            delta: 0
        })
    }
    function E(x) {
        let T = o.location.origin !== "null" ? o.location.origin : o.location.href
            , k = typeof x == "string" ? x : Nu(x);
        return k = k.replace(/ $/, "%20"),
            it(T, "No window.location.(origin|href) available to create URL for href: " + k),
            new URL(k,T)
    }
    let w = {
        get action() {
            return d
        },
        get location() {
            return e(o, l)
        },
        listen(x) {
            if (f)
                throw new Error("A history only accepts one active listener");
            return o.addEventListener(Tv, y),
                f = x,
                () => {
                    o.removeEventListener(Tv, y),
                        f = null
                }
        },
        createHref(x) {
            return t(o, x)
        },
        createURL: E,
        encodeLocation(x) {
            let T = E(x);
            return {
                pathname: T.pathname,
                search: T.search,
                hash: T.hash
            }
        },
        push: v,
        replace: S,
        go(x) {
            return l.go(x)
        }
    };
    return w
}
var Rv;
(function(e) {
        e.data = "data",
            e.deferred = "deferred",
            e.redirect = "redirect",
            e.error = "error"
    }
)(Rv || (Rv = {}));
function Hk(e, t, n) {
    return n === void 0 && (n = "/"),
        qk(e, t, n)
}
function qk(e, t, n, s) {
    let o = typeof t == "string" ? Gi(t) : t
        , u = op(o.pathname || "/", n);
    if (u == null)
        return null;
    let l = Ux(e);
    Kk(l);
    let d = null;
    for (let f = 0; d == null && f < l.length; ++f) {
        let p = iR(u);
        d = nR(l[f], p)
    }
    return d
}
function Ux(e, t, n, s) {
    t === void 0 && (t = []),
    n === void 0 && (n = []),
    s === void 0 && (s = "");
    let o = (u, l, d) => {
            let f = {
                relativePath: d === void 0 ? u.path || "" : d,
                caseSensitive: u.caseSensitive === !0,
                childrenIndex: l,
                route: u
            };
            f.relativePath.startsWith("/") && (it(f.relativePath.startsWith(s), 'Absolute route path "' + f.relativePath + '" nested under path ' + ('"' + s + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."),
                f.relativePath = f.relativePath.slice(s.length));
            let p = Gr([s, f.relativePath])
                , m = n.concat(f);
            u.children && u.children.length > 0 && (it(u.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + p + '".')),
                Ux(u.children, t, m, p)),
            !(u.path == null && !u.index) && t.push({
                path: p,
                score: eR(p, u.index),
                routesMeta: m
            })
        }
    ;
    return e.forEach( (u, l) => {
            var d;
            if (u.path === "" || !((d = u.path) != null && d.includes("?")))
                o(u, l);
            else
                for (let f of zx(u.path))
                    o(u, l, f)
        }
    ),
        t
}
function zx(e) {
    let t = e.split("/");
    if (t.length === 0)
        return [];
    let[n,...s] = t
        , o = n.endsWith("?")
        , u = n.replace(/\?$/, "");
    if (s.length === 0)
        return o ? [u, ""] : [u];
    let l = zx(s.join("/"))
        , d = [];
    return d.push(...l.map(f => f === "" ? u : [u, f].join("/"))),
    o && d.push(...l),
        d.map(f => e.startsWith("/") && f === "" ? "/" : f)
}
function Kk(e) {
    e.sort( (t, n) => t.score !== n.score ? n.score - t.score : tR(t.routesMeta.map(s => s.childrenIndex), n.routesMeta.map(s => s.childrenIndex)))
}
const Qk = /^:[\w-]+$/
    , Gk = 3
    , Xk = 2
    , Yk = 1
    , Jk = 10
    , Zk = -2
    , Av = e => e === "*";
function eR(e, t) {
    let n = e.split("/")
        , s = n.length;
    return n.some(Av) && (s += Zk),
    t && (s += Xk),
        n.filter(o => !Av(o)).reduce( (o, u) => o + (Qk.test(u) ? Gk : u === "" ? Yk : Jk), s)
}
function tR(e, t) {
    return e.length === t.length && e.slice(0, -1).every( (s, o) => s === t[o]) ? e[e.length - 1] - t[t.length - 1] : 0
}
function nR(e, t, n) {
    let {routesMeta: s} = e
        , o = {}
        , u = "/"
        , l = [];
    for (let d = 0; d < s.length; ++d) {
        let f = s[d]
            , p = d === s.length - 1
            , m = u === "/" ? t : t.slice(u.length) || "/"
            , y = rR({
            path: f.relativePath,
            caseSensitive: f.caseSensitive,
            end: p
        }, m)
            , v = f.route;
        if (!y)
            return null;
        Object.assign(o, y.params),
            l.push({
                params: o,
                pathname: Gr([u, y.pathname]),
                pathnameBase: uR(Gr([u, y.pathnameBase])),
                route: v
            }),
        y.pathnameBase !== "/" && (u = Gr([u, y.pathnameBase]))
    }
    return l
}
function rR(e, t) {
    typeof e == "string" && (e = {
        path: e,
        caseSensitive: !1,
        end: !0
    });
    let[n,s] = sR(e.path, e.caseSensitive, e.end)
        , o = t.match(n);
    if (!o)
        return null;
    let u = o[0]
        , l = u.replace(/(.)\/+$/, "$1")
        , d = o.slice(1);
    return {
        params: s.reduce( (p, m, y) => {
                let {paramName: v, isOptional: S} = m;
                if (v === "*") {
                    let w = d[y] || "";
                    l = u.slice(0, u.length - w.length).replace(/(.)\/+$/, "$1")
                }
                const E = d[y];
                return S && !E ? p[v] = void 0 : p[v] = (E || "").replace(/%2F/g, "/"),
                    p
            }
            , {}),
        pathname: u,
        pathnameBase: l,
        pattern: e
    }
}
function sR(e, t, n) {
    t === void 0 && (t = !1),
    n === void 0 && (n = !0),
        Vx(e === "*" || !e.endsWith("*") || e.endsWith("/*"), 'Route path "' + e + '" will be treated as if it were ' + ('"' + e.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + e.replace(/\*$/, "/*") + '".'));
    let s = []
        , o = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (l, d, f) => (s.push({
        paramName: d,
        isOptional: f != null
    }),
        f ? "/?([^\\/]+)?" : "/([^\\/]+)"));
    return e.endsWith("*") ? (s.push({
        paramName: "*"
    }),
        o += e === "*" || e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? o += "\\/*$" : e !== "" && e !== "/" && (o += "(?:(?=\\/|$))"),
        [new RegExp(o,t ? void 0 : "i"), s]
}
function iR(e) {
    try {
        return e.split("/").map(t => decodeURIComponent(t).replace(/\//g, "%2F")).join("/")
    } catch (t) {
        return Vx(!1, 'The URL path "' + e + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + t + ").")),
            e
    }
}
function op(e, t) {
    if (t === "/")
        return e;
    if (!e.toLowerCase().startsWith(t.toLowerCase()))
        return null;
    let n = t.endsWith("/") ? t.length - 1 : t.length
        , s = e.charAt(n);
    return s && s !== "/" ? null : e.slice(n) || "/"
}
function oR(e, t) {
    t === void 0 && (t = "/");
    let {pathname: n, search: s="", hash: o=""} = typeof e == "string" ? Gi(e) : e;
    return {
        pathname: n ? n.startsWith("/") ? n : aR(n, t) : t,
        search: cR(s),
        hash: dR(o)
    }
}
function aR(e, t) {
    let n = t.replace(/\/+$/, "").split("/");
    return e.split("/").forEach(o => {
            o === ".." ? n.length > 1 && n.pop() : o !== "." && n.push(o)
        }
    ),
        n.length > 1 ? n.join("/") : "/"
}
function pf(e, t, n, s) {
    return "Cannot include a '" + e + "' character in a manually specified " + ("`to." + t + "` field [" + JSON.stringify(s) + "].  Please separate it out to the ") + ("`to." + n + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.'
}
function lR(e) {
    return e.filter( (t, n) => n === 0 || t.route.path && t.route.path.length > 0)
}
function $x(e, t) {
    let n = lR(e);
    return t ? n.map( (s, o) => o === n.length - 1 ? s.pathname : s.pathnameBase) : n.map(s => s.pathnameBase)
}
function Wx(e, t, n, s) {
    s === void 0 && (s = !1);
    let o;
    typeof e == "string" ? o = Gi(e) : (o = ha({}, e),
        it(!o.pathname || !o.pathname.includes("?"), pf("?", "pathname", "search", o)),
        it(!o.pathname || !o.pathname.includes("#"), pf("#", "pathname", "hash", o)),
        it(!o.search || !o.search.includes("#"), pf("#", "search", "hash", o)));
    let u = e === "" || o.pathname === "", l = u ? "/" : o.pathname, d;
    if (l == null)
        d = n;
    else {
        let y = t.length - 1;
        if (!s && l.startsWith("..")) {
            let v = l.split("/");
            for (; v[0] === ".."; )
                v.shift(),
                    y -= 1;
            o.pathname = v.join("/")
        }
        d = y >= 0 ? t[y] : "/"
    }
    let f = oR(o, d)
        , p = l && l !== "/" && l.endsWith("/")
        , m = (u || l === ".") && n.endsWith("/");
    return !f.pathname.endsWith("/") && (p || m) && (f.pathname += "/"),
        f
}
const Gr = e => e.join("/").replace(/\/\/+/g, "/")
    , uR = e => e.replace(/\/+$/, "").replace(/^\/*/, "/")
    , cR = e => !e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e
    , dR = e => !e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e;
function fR(e) {
    return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.internal == "boolean" && "data"in e
}
const Hx = ["post", "put", "patch", "delete"];
new Set(Hx);
const hR = ["get", ...Hx];
new Set(hR);
/**
 * React Router v6.30.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function pa() {
    return pa = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var s in n)
                Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
        }
        return e
    }
        ,
        pa.apply(this, arguments)
}
const ap = P.createContext(null)
    , pR = P.createContext(null)
    , Us = P.createContext(null)
    , Hu = P.createContext(null)
    , zs = P.createContext({
    outlet: null,
    matches: [],
    isDataRoute: !1
})
    , qx = P.createContext(null);
function mR(e, t) {
    let {relative: n} = t === void 0 ? {} : t;
    _a() || it(!1);
    let {basename: s, navigator: o} = P.useContext(Us)
        , {hash: u, pathname: l, search: d} = Qx(e, {
        relative: n
    })
        , f = l;
    return s !== "/" && (f = l === "/" ? s : Gr([s, l])),
        o.createHref({
            pathname: f,
            search: d,
            hash: u
        })
}
function _a() {
    return P.useContext(Hu) != null
}
function Xi() {
    return _a() || it(!1),
        P.useContext(Hu).location
}
function Kx(e) {
    P.useContext(Us).static || P.useLayoutEffect(e)
}
function gR() {
    let {isDataRoute: e} = P.useContext(zs);
    return e ? AR() : yR()
}
function yR() {
    _a() || it(!1);
    let e = P.useContext(ap)
        , {basename: t, future: n, navigator: s} = P.useContext(Us)
        , {matches: o} = P.useContext(zs)
        , {pathname: u} = Xi()
        , l = JSON.stringify($x(o, n.v7_relativeSplatPath))
        , d = P.useRef(!1);
    return Kx( () => {
            d.current = !0
        }
    ),
        P.useCallback(function(p, m) {
            if (m === void 0 && (m = {}),
                !d.current)
                return;
            if (typeof p == "number") {
                s.go(p);
                return
            }
            let y = Wx(p, JSON.parse(l), u, m.relative === "path");
            e == null && t !== "/" && (y.pathname = y.pathname === "/" ? t : Gr([t, y.pathname])),
                (m.replace ? s.replace : s.push)(y, m.state, m)
        }, [t, s, l, u, e])
}
function Qx(e, t) {
    let {relative: n} = t === void 0 ? {} : t
        , {future: s} = P.useContext(Us)
        , {matches: o} = P.useContext(zs)
        , {pathname: u} = Xi()
        , l = JSON.stringify($x(o, s.v7_relativeSplatPath));
    return P.useMemo( () => Wx(e, JSON.parse(l), u, n === "path"), [e, l, u, n])
}
function vR(e, t) {
    return wR(e, t)
}
function wR(e, t, n, s) {
    _a() || it(!1);
    let {navigator: o} = P.useContext(Us)
        , {matches: u} = P.useContext(zs)
        , l = u[u.length - 1]
        , d = l ? l.params : {};
    l && l.pathname;
    let f = l ? l.pathnameBase : "/";
    l && l.route;
    let p = Xi(), m;
    if (t) {
        var y;
        let x = typeof t == "string" ? Gi(t) : t;
        f === "/" || (y = x.pathname) != null && y.startsWith(f) || it(!1),
            m = x
    } else
        m = p;
    let v = m.pathname || "/"
        , S = v;
    if (f !== "/") {
        let x = f.replace(/^\//, "").split("/");
        S = "/" + v.replace(/^\//, "").split("/").slice(x.length).join("/")
    }
    let E = Hk(e, {
        pathname: S
    })
        , w = CR(E && E.map(x => Object.assign({}, x, {
        params: Object.assign({}, d, x.params),
        pathname: Gr([f, o.encodeLocation ? o.encodeLocation(x.pathname).pathname : x.pathname]),
        pathnameBase: x.pathnameBase === "/" ? f : Gr([f, o.encodeLocation ? o.encodeLocation(x.pathnameBase).pathname : x.pathnameBase])
    })), u, n, s);
    return t && w ? P.createElement(Hu.Provider, {
        value: {
            location: pa({
                pathname: "/",
                search: "",
                hash: "",
                state: null,
                key: "default"
            }, m),
            navigationType: qr.Pop
        }
    }, w) : w
}
function xR() {
    let e = RR()
        , t = fR(e) ? e.status + " " + e.statusText : e instanceof Error ? e.message : JSON.stringify(e)
        , n = e instanceof Error ? e.stack : null
        , o = {
        padding: "0.5rem",
        backgroundColor: "rgba(200,200,200, 0.5)"
    };
    return P.createElement(P.Fragment, null, P.createElement("h2", null, "Unexpected Application Error!"), P.createElement("h3", {
        style: {
            fontStyle: "italic"
        }
    }, t), n ? P.createElement("pre", {
        style: o
    }, n) : null, null)
}
const SR = P.createElement(xR, null);
class bR extends P.Component {
    constructor(t) {
        super(t),
            this.state = {
                location: t.location,
                revalidation: t.revalidation,
                error: t.error
            }
    }
    static getDerivedStateFromError(t) {
        return {
            error: t
        }
    }
    static getDerivedStateFromProps(t, n) {
        return n.location !== t.location || n.revalidation !== "idle" && t.revalidation === "idle" ? {
            error: t.error,
            location: t.location,
            revalidation: t.revalidation
        } : {
            error: t.error !== void 0 ? t.error : n.error,
            location: n.location,
            revalidation: t.revalidation || n.revalidation
        }
    }
    componentDidCatch(t, n) {
        console.error("React Router caught the following error during render", t, n)
    }
    render() {
        return this.state.error !== void 0 ? P.createElement(zs.Provider, {
            value: this.props.routeContext
        }, P.createElement(qx.Provider, {
            value: this.state.error,
            children: this.props.component
        })) : this.props.children
    }
}
function ER(e) {
    let {routeContext: t, match: n, children: s} = e
        , o = P.useContext(ap);
    return o && o.static && o.staticContext && (n.route.errorElement || n.route.ErrorBoundary) && (o.staticContext._deepestRenderedBoundaryId = n.route.id),
        P.createElement(zs.Provider, {
            value: t
        }, s)
}
function CR(e, t, n, s) {
    var o;
    if (t === void 0 && (t = []),
    n === void 0 && (n = null),
    s === void 0 && (s = null),
    e == null) {
        var u;
        if (!n)
            return null;
        if (n.errors)
            e = n.matches;
        else if ((u = s) != null && u.v7_partialHydration && t.length === 0 && !n.initialized && n.matches.length > 0)
            e = n.matches;
        else
            return null
    }
    let l = e
        , d = (o = n) == null ? void 0 : o.errors;
    if (d != null) {
        let m = l.findIndex(y => y.route.id && (d == null ? void 0 : d[y.route.id]) !== void 0);
        m >= 0 || it(!1),
            l = l.slice(0, Math.min(l.length, m + 1))
    }
    let f = !1
        , p = -1;
    if (n && s && s.v7_partialHydration)
        for (let m = 0; m < l.length; m++) {
            let y = l[m];
            if ((y.route.HydrateFallback || y.route.hydrateFallbackElement) && (p = m),
                y.route.id) {
                let {loaderData: v, errors: S} = n
                    , E = y.route.loader && v[y.route.id] === void 0 && (!S || S[y.route.id] === void 0);
                if (y.route.lazy || E) {
                    f = !0,
                        p >= 0 ? l = l.slice(0, p + 1) : l = [l[0]];
                    break
                }
            }
        }
    return l.reduceRight( (m, y, v) => {
            let S, E = !1, w = null, x = null;
            n && (S = d && y.route.id ? d[y.route.id] : void 0,
                w = y.route.errorElement || SR,
            f && (p < 0 && v === 0 ? (_R("route-fallback"),
                E = !0,
                x = null) : p === v && (E = !0,
                x = y.route.hydrateFallbackElement || null)));
            let T = t.concat(l.slice(0, v + 1))
                , k = () => {
                    let R;
                    return S ? R = w : E ? R = x : y.route.Component ? R = P.createElement(y.route.Component, null) : y.route.element ? R = y.route.element : R = m,
                        P.createElement(ER, {
                            match: y,
                            routeContext: {
                                outlet: m,
                                matches: T,
                                isDataRoute: n != null
                            },
                            children: R
                        })
                }
            ;
            return n && (y.route.ErrorBoundary || y.route.errorElement || v === 0) ? P.createElement(bR, {
                location: n.location,
                revalidation: n.revalidation,
                component: w,
                error: S,
                children: k(),
                routeContext: {
                    outlet: null,
                    matches: T,
                    isDataRoute: !0
                }
            }) : k()
        }
        , null)
}
var Gx = (function(e) {
        return e.UseBlocker = "useBlocker",
            e.UseRevalidator = "useRevalidator",
            e.UseNavigateStable = "useNavigate",
            e
    }
)(Gx || {})
    , Xx = (function(e) {
        return e.UseBlocker = "useBlocker",
            e.UseLoaderData = "useLoaderData",
            e.UseActionData = "useActionData",
            e.UseRouteError = "useRouteError",
            e.UseNavigation = "useNavigation",
            e.UseRouteLoaderData = "useRouteLoaderData",
            e.UseMatches = "useMatches",
            e.UseRevalidator = "useRevalidator",
            e.UseNavigateStable = "useNavigate",
            e.UseRouteId = "useRouteId",
            e
    }
)(Xx || {});
function PR(e) {
    let t = P.useContext(ap);
    return t || it(!1),
        t
}
function TR(e) {
    let t = P.useContext(pR);
    return t || it(!1),
        t
}
function kR(e) {
    let t = P.useContext(zs);
    return t || it(!1),
        t
}
function Yx(e) {
    let t = kR()
        , n = t.matches[t.matches.length - 1];
    return n.route.id || it(!1),
        n.route.id
}
function RR() {
    var e;
    let t = P.useContext(qx)
        , n = TR()
        , s = Yx();
    return t !== void 0 ? t : (e = n.errors) == null ? void 0 : e[s]
}
function AR() {
    let {router: e} = PR(Gx.UseNavigateStable)
        , t = Yx(Xx.UseNavigateStable)
        , n = P.useRef(!1);
    return Kx( () => {
            n.current = !0
        }
    ),
        P.useCallback(function(o, u) {
            u === void 0 && (u = {}),
            n.current && (typeof o == "number" ? e.navigate(o) : e.navigate(o, pa({
                fromRouteId: t
            }, u)))
        }, [e, t])
}
const _v = {};
function _R(e, t, n) {
    _v[e] || (_v[e] = !0)
}
function NR(e, t) {
    e == null || e.v7_startTransition,
    e == null || e.v7_relativeSplatPath
}
function pu(e) {
    it(!1)
}
function OR(e) {
    let {basename: t="/", children: n=null, location: s, navigationType: o=qr.Pop, navigator: u, static: l=!1, future: d} = e;
    _a() && it(!1);
    let f = t.replace(/^\/*/, "/")
        , p = P.useMemo( () => ({
        basename: f,
        navigator: u,
        static: l,
        future: pa({
            v7_relativeSplatPath: !1
        }, d)
    }), [f, d, u, l]);
    typeof s == "string" && (s = Gi(s));
    let {pathname: m="/", search: y="", hash: v="", state: S=null, key: E="default"} = s
        , w = P.useMemo( () => {
            let x = op(m, f);
            return x == null ? null : {
                location: {
                    pathname: x,
                    search: y,
                    hash: v,
                    state: S,
                    key: E
                },
                navigationType: o
            }
        }
        , [f, m, y, v, S, E, o]);
    return w == null ? null : P.createElement(Us.Provider, {
        value: p
    }, P.createElement(Hu.Provider, {
        children: n,
        value: w
    }))
}
function LR(e) {
    let {children: t, location: n} = e;
    return vR(lh(t), n)
}
new Promise( () => {}
);
function lh(e, t) {
    t === void 0 && (t = []);
    let n = [];
    return P.Children.forEach(e, (s, o) => {
            if (!P.isValidElement(s))
                return;
            let u = [...t, o];
            if (s.type === P.Fragment) {
                n.push.apply(n, lh(s.props.children, u));
                return
            }
            s.type !== pu && it(!1),
            !s.props.index || !s.props.children || it(!1);
            let l = {
                id: s.props.id || u.join("-"),
                caseSensitive: s.props.caseSensitive,
                element: s.props.element,
                Component: s.props.Component,
                index: s.props.index,
                path: s.props.path,
                loader: s.props.loader,
                action: s.props.action,
                errorElement: s.props.errorElement,
                ErrorBoundary: s.props.ErrorBoundary,
                hasErrorBoundary: s.props.ErrorBoundary != null || s.props.errorElement != null,
                shouldRevalidate: s.props.shouldRevalidate,
                handle: s.props.handle,
                lazy: s.props.lazy
            };
            s.props.children && (l.children = lh(s.props.children, u)),
                n.push(l)
        }
    ),
        n
}
/**
 * React Router DOM v6.30.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function uh() {
    return uh = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var s in n)
                Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
        }
        return e
    }
        ,
        uh.apply(this, arguments)
}
function MR(e, t) {
    if (e == null)
        return {};
    var n = {}, s = Object.keys(e), o, u;
    for (u = 0; u < s.length; u++)
        o = s[u],
        !(t.indexOf(o) >= 0) && (n[o] = e[o]);
    return n
}
function jR(e) {
    return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
}
function DR(e, t) {
    return e.button === 0 && (!t || t === "_self") && !jR(e)
}
const IR = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"]
    , FR = "6";
try {
    window.__reactRouterVersion = FR
} catch {}
const BR = "startTransition"
    , Nv = Jh[BR];
function VR(e) {
    let {basename: t, children: n, future: s, window: o} = e
        , u = P.useRef();
    u.current == null && (u.current = zk({
        window: o,
        v5Compat: !0
    }));
    let l = u.current
        , [d,f] = P.useState({
        action: l.action,
        location: l.location
    })
        , {v7_startTransition: p} = s || {}
        , m = P.useCallback(y => {
            p && Nv ? Nv( () => f(y)) : f(y)
        }
        , [f, p]);
    return P.useLayoutEffect( () => l.listen(m), [l, m]),
        P.useEffect( () => NR(s), [s]),
        P.createElement(OR, {
            basename: t,
            children: n,
            location: d.location,
            navigationType: d.action,
            navigator: l,
            future: s
        })
}
const UR = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u"
    , zR = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i
    , Ti = P.forwardRef(function(t, n) {
    let {onClick: s, relative: o, reloadDocument: u, replace: l, state: d, target: f, to: p, preventScrollReset: m, viewTransition: y} = t, v = MR(t, IR), {basename: S} = P.useContext(Us), E, w = !1;
    if (typeof p == "string" && zR.test(p) && (E = p,
        UR))
        try {
            let R = new URL(window.location.href)
                , _ = p.startsWith("//") ? new URL(R.protocol + p) : new URL(p)
                , D = op(_.pathname, S);
            _.origin === R.origin && D != null ? p = D + _.search + _.hash : w = !0
        } catch {}
    let x = mR(p, {
        relative: o
    })
        , T = $R(p, {
        replace: l,
        state: d,
        target: f,
        preventScrollReset: m,
        relative: o,
        viewTransition: y
    });
    function k(R) {
        s && s(R),
        R.defaultPrevented || T(R)
    }
    return P.createElement("a", uh({}, v, {
        href: E || x,
        onClick: w || u ? s : k,
        ref: n,
        target: f
    }))
});
var Ov;
(function(e) {
        e.UseScrollRestoration = "useScrollRestoration",
            e.UseSubmit = "useSubmit",
            e.UseSubmitFetcher = "useSubmitFetcher",
            e.UseFetcher = "useFetcher",
            e.useViewTransitionState = "useViewTransitionState"
    }
)(Ov || (Ov = {}));
var Lv;
(function(e) {
        e.UseFetcher = "useFetcher",
            e.UseFetchers = "useFetchers",
            e.UseScrollRestoration = "useScrollRestoration"
    }
)(Lv || (Lv = {}));
function $R(e, t) {
    let {target: n, replace: s, state: o, preventScrollReset: u, relative: l, viewTransition: d} = t === void 0 ? {} : t
        , f = gR()
        , p = Xi()
        , m = Qx(e, {
        relative: l
    });
    return P.useCallback(y => {
            if (DR(y, n)) {
                y.preventDefault();
                let v = s !== void 0 ? s : Nu(p) === Nu(m);
                f(e, {
                    replace: v,
                    state: o,
                    preventScrollReset: u,
                    relative: l,
                    viewTransition: d
                })
            }
        }
        , [p, f, m, s, o, n, e, u, l, d])
}
function Jx(e, t) {
    return function() {
        return e.apply(t, arguments)
    }
}
const {toString: WR} = Object.prototype
    , {getPrototypeOf: lp} = Object
    , {iterator: qu, toStringTag: Zx} = Symbol
    , Ku = (e => t => {
        const n = WR.call(t);
        return e[n] || (e[n] = n.slice(8, -1).toLowerCase())
    }
)(Object.create(null))
    , Pn = e => (e = e.toLowerCase(),
    t => Ku(t) === e)
    , Qu = e => t => typeof t === e
    , {isArray: Yi} = Array
    , zi = Qu("undefined");
function Na(e) {
    return e !== null && !zi(e) && e.constructor !== null && !zi(e.constructor) && Vt(e.constructor.isBuffer) && e.constructor.isBuffer(e)
}
const eS = Pn("ArrayBuffer");
function HR(e) {
    let t;
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && eS(e.buffer),
        t
}
const qR = Qu("string")
    , Vt = Qu("function")
    , tS = Qu("number")
    , Oa = e => e !== null && typeof e == "object"
    , KR = e => e === !0 || e === !1
    , mu = e => {
    if (Ku(e) !== "object")
        return !1;
    const t = lp(e);
    return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Zx in e) && !(qu in e)
}
    , QR = e => {
    if (!Oa(e) || Na(e))
        return !1;
    try {
        return Object.keys(e).length === 0 && Object.getPrototypeOf(e) === Object.prototype
    } catch {
        return !1
    }
}
    , GR = Pn("Date")
    , XR = Pn("File")
    , YR = Pn("Blob")
    , JR = Pn("FileList")
    , ZR = e => Oa(e) && Vt(e.pipe)
    , eA = e => {
    let t;
    return e && (typeof FormData == "function" && e instanceof FormData || Vt(e.append) && ((t = Ku(e)) === "formdata" || t === "object" && Vt(e.toString) && e.toString() === "[object FormData]"))
}
    , tA = Pn("URLSearchParams")
    , [nA,rA,sA,iA] = ["ReadableStream", "Request", "Response", "Headers"].map(Pn)
    , oA = e => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function La(e, t, {allOwnKeys: n=!1}={}) {
    if (e === null || typeof e > "u")
        return;
    let s, o;
    if (typeof e != "object" && (e = [e]),
        Yi(e))
        for (s = 0,
                 o = e.length; s < o; s++)
            t.call(null, e[s], s, e);
    else {
        if (Na(e))
            return;
        const u = n ? Object.getOwnPropertyNames(e) : Object.keys(e)
            , l = u.length;
        let d;
        for (s = 0; s < l; s++)
            d = u[s],
                t.call(null, e[d], d, e)
    }
}
function nS(e, t) {
    if (Na(e))
        return null;
    t = t.toLowerCase();
    const n = Object.keys(e);
    let s = n.length, o;
    for (; s-- > 0; )
        if (o = n[s],
        t === o.toLowerCase())
            return o;
    return null
}
const bs = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global
    , rS = e => !zi(e) && e !== bs;
function ch() {
    const {caseless: e, skipUndefined: t} = rS(this) && this || {}
        , n = {}
        , s = (o, u) => {
            const l = e && nS(n, u) || u;
            mu(n[l]) && mu(o) ? n[l] = ch(n[l], o) : mu(o) ? n[l] = ch({}, o) : Yi(o) ? n[l] = o.slice() : (!t || !zi(o)) && (n[l] = o)
        }
    ;
    for (let o = 0, u = arguments.length; o < u; o++)
        arguments[o] && La(arguments[o], s);
    return n
}
const aA = (e, t, n, {allOwnKeys: s}={}) => (La(t, (o, u) => {
        n && Vt(o) ? e[u] = Jx(o, n) : e[u] = o
    }
    , {
        allOwnKeys: s
    }),
    e)
    , lA = e => (e.charCodeAt(0) === 65279 && (e = e.slice(1)),
    e)
    , uA = (e, t, n, s) => {
    e.prototype = Object.create(t.prototype, s),
        e.prototype.constructor = e,
        Object.defineProperty(e, "super", {
            value: t.prototype
        }),
    n && Object.assign(e.prototype, n)
}
    , cA = (e, t, n, s) => {
    let o, u, l;
    const d = {};
    if (t = t || {},
    e == null)
        return t;
    do {
        for (o = Object.getOwnPropertyNames(e),
                 u = o.length; u-- > 0; )
            l = o[u],
            (!s || s(l, e, t)) && !d[l] && (t[l] = e[l],
                d[l] = !0);
        e = n !== !1 && lp(e)
    } while (e && (!n || n(e, t)) && e !== Object.prototype);
    return t
}
    , dA = (e, t, n) => {
    e = String(e),
    (n === void 0 || n > e.length) && (n = e.length),
        n -= t.length;
    const s = e.indexOf(t, n);
    return s !== -1 && s === n
}
    , fA = e => {
    if (!e)
        return null;
    if (Yi(e))
        return e;
    let t = e.length;
    if (!tS(t))
        return null;
    const n = new Array(t);
    for (; t-- > 0; )
        n[t] = e[t];
    return n
}
    , hA = (e => t => e && t instanceof e)(typeof Uint8Array < "u" && lp(Uint8Array))
    , pA = (e, t) => {
    const s = (e && e[qu]).call(e);
    let o;
    for (; (o = s.next()) && !o.done; ) {
        const u = o.value;
        t.call(e, u[0], u[1])
    }
}
    , mA = (e, t) => {
    let n;
    const s = [];
    for (; (n = e.exec(t)) !== null; )
        s.push(n);
    return s
}
    , gA = Pn("HTMLFormElement")
    , yA = e => e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(n, s, o) {
    return s.toUpperCase() + o
})
    , Mv = ( ({hasOwnProperty: e}) => (t, n) => e.call(t, n))(Object.prototype)
    , vA = Pn("RegExp")
    , sS = (e, t) => {
    const n = Object.getOwnPropertyDescriptors(e)
        , s = {};
    La(n, (o, u) => {
            let l;
            (l = t(o, u, e)) !== !1 && (s[u] = l || o)
        }
    ),
        Object.defineProperties(e, s)
}
    , wA = e => {
    sS(e, (t, n) => {
            if (Vt(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
                return !1;
            const s = e[n];
            if (Vt(s)) {
                if (t.enumerable = !1,
                "writable"in t) {
                    t.writable = !1;
                    return
                }
                t.set || (t.set = () => {
                        throw Error("Can not rewrite read-only method '" + n + "'")
                    }
                )
            }
        }
    )
}
    , xA = (e, t) => {
    const n = {}
        , s = o => {
            o.forEach(u => {
                    n[u] = !0
                }
            )
        }
    ;
    return Yi(e) ? s(e) : s(String(e).split(t)),
        n
}
    , SA = () => {}
    , bA = (e, t) => e != null && Number.isFinite(e = +e) ? e : t;
function EA(e) {
    return !!(e && Vt(e.append) && e[Zx] === "FormData" && e[qu])
}
const CA = e => {
    const t = new Array(10)
        , n = (s, o) => {
            if (Oa(s)) {
                if (t.indexOf(s) >= 0)
                    return;
                if (Na(s))
                    return s;
                if (!("toJSON"in s)) {
                    t[o] = s;
                    const u = Yi(s) ? [] : {};
                    return La(s, (l, d) => {
                            const f = n(l, o + 1);
                            !zi(f) && (u[d] = f)
                        }
                    ),
                        t[o] = void 0,
                        u
                }
            }
            return s
        }
    ;
    return n(e, 0)
}
    , PA = Pn("AsyncFunction")
    , TA = e => e && (Oa(e) || Vt(e)) && Vt(e.then) && Vt(e.catch)
    , iS = ( (e, t) => e ? setImmediate : t ? ( (n, s) => (bs.addEventListener("message", ({source: o, data: u}) => {
            o === bs && u === n && s.length && s.shift()()
        }
        , !1),
        o => {
            s.push(o),
                bs.postMessage(n, "*")
        }
))(`axios@${Math.random()}`, []) : n => setTimeout(n))(typeof setImmediate == "function", Vt(bs.postMessage))
    , kA = typeof queueMicrotask < "u" ? queueMicrotask.bind(bs) : typeof process < "u" && process.nextTick || iS
    , RA = e => e != null && Vt(e[qu])
    , U = {
    isArray: Yi,
    isArrayBuffer: eS,
    isBuffer: Na,
    isFormData: eA,
    isArrayBufferView: HR,
    isString: qR,
    isNumber: tS,
    isBoolean: KR,
    isObject: Oa,
    isPlainObject: mu,
    isEmptyObject: QR,
    isReadableStream: nA,
    isRequest: rA,
    isResponse: sA,
    isHeaders: iA,
    isUndefined: zi,
    isDate: GR,
    isFile: XR,
    isBlob: YR,
    isRegExp: vA,
    isFunction: Vt,
    isStream: ZR,
    isURLSearchParams: tA,
    isTypedArray: hA,
    isFileList: JR,
    forEach: La,
    merge: ch,
    extend: aA,
    trim: oA,
    stripBOM: lA,
    inherits: uA,
    toFlatObject: cA,
    kindOf: Ku,
    kindOfTest: Pn,
    endsWith: dA,
    toArray: fA,
    forEachEntry: pA,
    matchAll: mA,
    isHTMLForm: gA,
    hasOwnProperty: Mv,
    hasOwnProp: Mv,
    reduceDescriptors: sS,
    freezeMethods: wA,
    toObjectSet: xA,
    toCamelCase: yA,
    noop: SA,
    toFiniteNumber: bA,
    findKey: nS,
    global: bs,
    isContextDefined: rS,
    isSpecCompliantForm: EA,
    toJSONObject: CA,
    isAsyncFn: PA,
    isThenable: TA,
    setImmediate: iS,
    asap: kA,
    isIterable: RA
};
function ke(e, t, n, s, o) {
    Error.call(this),
        Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack,
        this.message = e,
        this.name = "AxiosError",
    t && (this.code = t),
    n && (this.config = n),
    s && (this.request = s),
    o && (this.response = o,
        this.status = o.status ? o.status : null)
}
U.inherits(ke, Error, {
    toJSON: function() {
        return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: U.toJSONObject(this.config),
            code: this.code,
            status: this.status
        }
    }
});
const oS = ke.prototype
    , aS = {};
["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(e => {
        aS[e] = {
            value: e
        }
    }
);
Object.defineProperties(ke, aS);
Object.defineProperty(oS, "isAxiosError", {
    value: !0
});
ke.from = (e, t, n, s, o, u) => {
    const l = Object.create(oS);
    U.toFlatObject(e, l, function(m) {
        return m !== Error.prototype
    }, p => p !== "isAxiosError");
    const d = e && e.message ? e.message : "Error"
        , f = t == null && e ? e.code : t;
    return ke.call(l, d, f, n, s, o),
    e && l.cause == null && Object.defineProperty(l, "cause", {
        value: e,
        configurable: !0
    }),
        l.name = e && e.name || "Error",
    u && Object.assign(l, u),
        l
}
;
const AA = null;
function dh(e) {
    return U.isPlainObject(e) || U.isArray(e)
}
function lS(e) {
    return U.endsWith(e, "[]") ? e.slice(0, -2) : e
}
function jv(e, t, n) {
    return e ? e.concat(t).map(function(o, u) {
        return o = lS(o),
            !n && u ? "[" + o + "]" : o
    }).join(n ? "." : "") : t
}
function _A(e) {
    return U.isArray(e) && !e.some(dh)
}
const NA = U.toFlatObject(U, {}, null, function(t) {
    return /^is[A-Z]/.test(t)
});
function Gu(e, t, n) {
    if (!U.isObject(e))
        throw new TypeError("target must be an object");
    t = t || new FormData,
        n = U.toFlatObject(n, {
            metaTokens: !0,
            dots: !1,
            indexes: !1
        }, !1, function(w, x) {
            return !U.isUndefined(x[w])
        });
    const s = n.metaTokens
        , o = n.visitor || m
        , u = n.dots
        , l = n.indexes
        , f = (n.Blob || typeof Blob < "u" && Blob) && U.isSpecCompliantForm(t);
    if (!U.isFunction(o))
        throw new TypeError("visitor must be a function");
    function p(E) {
        if (E === null)
            return "";
        if (U.isDate(E))
            return E.toISOString();
        if (U.isBoolean(E))
            return E.toString();
        if (!f && U.isBlob(E))
            throw new ke("Blob is not supported. Use a Buffer instead.");
        return U.isArrayBuffer(E) || U.isTypedArray(E) ? f && typeof Blob == "function" ? new Blob([E]) : Buffer.from(E) : E
    }
    function m(E, w, x) {
        let T = E;
        if (E && !x && typeof E == "object") {
            if (U.endsWith(w, "{}"))
                w = s ? w : w.slice(0, -2),
                    E = JSON.stringify(E);
            else if (U.isArray(E) && _A(E) || (U.isFileList(E) || U.endsWith(w, "[]")) && (T = U.toArray(E)))
                return w = lS(w),
                    T.forEach(function(R, _) {
                        !(U.isUndefined(R) || R === null) && t.append(l === !0 ? jv([w], _, u) : l === null ? w : w + "[]", p(R))
                    }),
                    !1
        }
        return dh(E) ? !0 : (t.append(jv(x, w, u), p(E)),
            !1)
    }
    const y = []
        , v = Object.assign(NA, {
        defaultVisitor: m,
        convertValue: p,
        isVisitable: dh
    });
    function S(E, w) {
        if (!U.isUndefined(E)) {
            if (y.indexOf(E) !== -1)
                throw Error("Circular reference detected in " + w.join("."));
            y.push(E),
                U.forEach(E, function(T, k) {
                    (!(U.isUndefined(T) || T === null) && o.call(t, T, U.isString(k) ? k.trim() : k, w, v)) === !0 && S(T, w ? w.concat(k) : [k])
                }),
                y.pop()
        }
    }
    if (!U.isObject(e))
        throw new TypeError("data must be an object");
    return S(e),
        t
}
function Dv(e) {
    const t = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
    };
    return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(s) {
        return t[s]
    })
}
function up(e, t) {
    this._pairs = [],
    e && Gu(e, this, t)
}
const uS = up.prototype;
uS.append = function(t, n) {
    this._pairs.push([t, n])
}
;
uS.toString = function(t) {
    const n = t ? function(s) {
            return t.call(this, s, Dv)
        }
        : Dv;
    return this._pairs.map(function(o) {
        return n(o[0]) + "=" + n(o[1])
    }, "").join("&")
}
;
function OA(e) {
    return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+")
}
function cS(e, t, n) {
    if (!t)
        return e;
    const s = n && n.encode || OA;
    U.isFunction(n) && (n = {
        serialize: n
    });
    const o = n && n.serialize;
    let u;
    if (o ? u = o(t, n) : u = U.isURLSearchParams(t) ? t.toString() : new up(t,n).toString(s),
        u) {
        const l = e.indexOf("#");
        l !== -1 && (e = e.slice(0, l)),
            e += (e.indexOf("?") === -1 ? "?" : "&") + u
    }
    return e
}
class Iv {
    constructor() {
        this.handlers = []
    }
    use(t, n, s) {
        return this.handlers.push({
            fulfilled: t,
            rejected: n,
            synchronous: s ? s.synchronous : !1,
            runWhen: s ? s.runWhen : null
        }),
        this.handlers.length - 1
    }
    eject(t) {
        this.handlers[t] && (this.handlers[t] = null)
    }
    clear() {
        this.handlers && (this.handlers = [])
    }
    forEach(t) {
        U.forEach(this.handlers, function(s) {
            s !== null && t(s)
        })
    }
}
const dS = {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1
}
    , LA = typeof URLSearchParams < "u" ? URLSearchParams : up
    , MA = typeof FormData < "u" ? FormData : null
    , jA = typeof Blob < "u" ? Blob : null
    , DA = {
    isBrowser: !0,
    classes: {
        URLSearchParams: LA,
        FormData: MA,
        Blob: jA
    },
    protocols: ["http", "https", "file", "blob", "url", "data"]
}
    , cp = typeof window < "u" && typeof document < "u"
    , fh = typeof navigator == "object" && navigator || void 0
    , IA = cp && (!fh || ["ReactNative", "NativeScript", "NS"].indexOf(fh.product) < 0)
    , FA = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function"
    , BA = cp && window.location.href || "http://localhost"
    , VA = Object.freeze(Object.defineProperty({
    __proto__: null,
    hasBrowserEnv: cp,
    hasStandardBrowserEnv: IA,
    hasStandardBrowserWebWorkerEnv: FA,
    navigator: fh,
    origin: BA
}, Symbol.toStringTag, {
    value: "Module"
}))
    , Pt = {
    ...VA,
    ...DA
};
function UA(e, t) {
    return Gu(e, new Pt.classes.URLSearchParams, {
        visitor: function(n, s, o, u) {
            return Pt.isNode && U.isBuffer(n) ? (this.append(s, n.toString("base64")),
                !1) : u.defaultVisitor.apply(this, arguments)
        },
        ...t
    })
}
function zA(e) {
    return U.matchAll(/\w+|\[(\w*)]/g, e).map(t => t[0] === "[]" ? "" : t[1] || t[0])
}
function $A(e) {
    const t = {}
        , n = Object.keys(e);
    let s;
    const o = n.length;
    let u;
    for (s = 0; s < o; s++)
        u = n[s],
            t[u] = e[u];
    return t
}
function fS(e) {
    function t(n, s, o, u) {
        let l = n[u++];
        if (l === "__proto__")
            return !0;
        const d = Number.isFinite(+l)
            , f = u >= n.length;
        return l = !l && U.isArray(o) ? o.length : l,
            f ? (U.hasOwnProp(o, l) ? o[l] = [o[l], s] : o[l] = s,
                !d) : ((!o[l] || !U.isObject(o[l])) && (o[l] = []),
            t(n, s, o[l], u) && U.isArray(o[l]) && (o[l] = $A(o[l])),
                !d)
    }
    if (U.isFormData(e) && U.isFunction(e.entries)) {
        const n = {};
        return U.forEachEntry(e, (s, o) => {
                t(zA(s), o, n, 0)
            }
        ),
            n
    }
    return null
}
function WA(e, t, n) {
    if (U.isString(e))
        try {
            return (t || JSON.parse)(e),
                U.trim(e)
        } catch (s) {
            if (s.name !== "SyntaxError")
                throw s
        }
    return (n || JSON.stringify)(e)
}
const Ma = {
    transitional: dS,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [function(t, n) {
        const s = n.getContentType() || ""
            , o = s.indexOf("application/json") > -1
            , u = U.isObject(t);
        if (u && U.isHTMLForm(t) && (t = new FormData(t)),
            U.isFormData(t))
            return o ? JSON.stringify(fS(t)) : t;
        if (U.isArrayBuffer(t) || U.isBuffer(t) || U.isStream(t) || U.isFile(t) || U.isBlob(t) || U.isReadableStream(t))
            return t;
        if (U.isArrayBufferView(t))
            return t.buffer;
        if (U.isURLSearchParams(t))
            return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1),
                t.toString();
        let d;
        if (u) {
            if (s.indexOf("application/x-www-form-urlencoded") > -1)
                return UA(t, this.formSerializer).toString();
            if ((d = U.isFileList(t)) || s.indexOf("multipart/form-data") > -1) {
                const f = this.env && this.env.FormData;
                return Gu(d ? {
                    "files[]": t
                } : t, f && new f, this.formSerializer)
            }
        }
        return u || o ? (n.setContentType("application/json", !1),
            WA(t)) : t
    }
    ],
    transformResponse: [function(t) {
        const n = this.transitional || Ma.transitional
            , s = n && n.forcedJSONParsing
            , o = this.responseType === "json";
        if (U.isResponse(t) || U.isReadableStream(t))
            return t;
        if (t && U.isString(t) && (s && !this.responseType || o)) {
            const l = !(n && n.silentJSONParsing) && o;
            try {
                return JSON.parse(t, this.parseReviver)
            } catch (d) {
                if (l)
                    throw d.name === "SyntaxError" ? ke.from(d, ke.ERR_BAD_RESPONSE, this, null, this.response) : d
            }
        }
        return t
    }
    ],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
        FormData: Pt.classes.FormData,
        Blob: Pt.classes.Blob
    },
    validateStatus: function(t) {
        return t >= 200 && t < 300
    },
    headers: {
        common: {
            Accept: "application/json, text/plain, */*",
            "Content-Type": void 0
        }
    }
};
U.forEach(["delete", "get", "head", "post", "put", "patch"], e => {
        Ma.headers[e] = {}
    }
);
const HA = U.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"])
    , qA = e => {
    const t = {};
    let n, s, o;
    return e && e.split(`
`).forEach(function(l) {
        o = l.indexOf(":"),
            n = l.substring(0, o).trim().toLowerCase(),
            s = l.substring(o + 1).trim(),
        !(!n || t[n] && HA[n]) && (n === "set-cookie" ? t[n] ? t[n].push(s) : t[n] = [s] : t[n] = t[n] ? t[n] + ", " + s : s)
    }),
        t
}
    , Fv = Symbol("internals");
function qo(e) {
    return e && String(e).trim().toLowerCase()
}
function gu(e) {
    return e === !1 || e == null ? e : U.isArray(e) ? e.map(gu) : String(e)
}
function KA(e) {
    const t = Object.create(null)
        , n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let s;
    for (; s = n.exec(e); )
        t[s[1]] = s[2];
    return t
}
const QA = e => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function mf(e, t, n, s, o) {
    if (U.isFunction(s))
        return s.call(this, t, n);
    if (o && (t = n),
        !!U.isString(t)) {
        if (U.isString(s))
            return t.indexOf(s) !== -1;
        if (U.isRegExp(s))
            return s.test(t)
    }
}
function GA(e) {
    return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, s) => n.toUpperCase() + s)
}
function XA(e, t) {
    const n = U.toCamelCase(" " + t);
    ["get", "set", "has"].forEach(s => {
            Object.defineProperty(e, s + n, {
                value: function(o, u, l) {
                    return this[s].call(this, t, o, u, l)
                },
                configurable: !0
            })
        }
    )
}
let Ut = class {
        constructor(t) {
            t && this.set(t)
        }
        set(t, n, s) {
            const o = this;
            function u(d, f, p) {
                const m = qo(f);
                if (!m)
                    throw new Error("header name must be a non-empty string");
                const y = U.findKey(o, m);
                (!y || o[y] === void 0 || p === !0 || p === void 0 && o[y] !== !1) && (o[y || f] = gu(d))
            }
            const l = (d, f) => U.forEach(d, (p, m) => u(p, m, f));
            if (U.isPlainObject(t) || t instanceof this.constructor)
                l(t, n);
            else if (U.isString(t) && (t = t.trim()) && !QA(t))
                l(qA(t), n);
            else if (U.isObject(t) && U.isIterable(t)) {
                let d = {}, f, p;
                for (const m of t) {
                    if (!U.isArray(m))
                        throw TypeError("Object iterator must return a key-value pair");
                    d[p = m[0]] = (f = d[p]) ? U.isArray(f) ? [...f, m[1]] : [f, m[1]] : m[1]
                }
                l(d, n)
            } else
                t != null && u(n, t, s);
            return this
        }
        get(t, n) {
            if (t = qo(t),
                t) {
                const s = U.findKey(this, t);
                if (s) {
                    const o = this[s];
                    if (!n)
                        return o;
                    if (n === !0)
                        return KA(o);
                    if (U.isFunction(n))
                        return n.call(this, o, s);
                    if (U.isRegExp(n))
                        return n.exec(o);
                    throw new TypeError("parser must be boolean|regexp|function")
                }
            }
        }
        has(t, n) {
            if (t = qo(t),
                t) {
                const s = U.findKey(this, t);
                return !!(s && this[s] !== void 0 && (!n || mf(this, this[s], s, n)))
            }
            return !1
        }
        delete(t, n) {
            const s = this;
            let o = !1;
            function u(l) {
                if (l = qo(l),
                    l) {
                    const d = U.findKey(s, l);
                    d && (!n || mf(s, s[d], d, n)) && (delete s[d],
                        o = !0)
                }
            }
            return U.isArray(t) ? t.forEach(u) : u(t),
                o
        }
        clear(t) {
            const n = Object.keys(this);
            let s = n.length
                , o = !1;
            for (; s--; ) {
                const u = n[s];
                (!t || mf(this, this[u], u, t, !0)) && (delete this[u],
                    o = !0)
            }
            return o
        }
        normalize(t) {
            const n = this
                , s = {};
            return U.forEach(this, (o, u) => {
                    const l = U.findKey(s, u);
                    if (l) {
                        n[l] = gu(o),
                            delete n[u];
                        return
                    }
                    const d = t ? GA(u) : String(u).trim();
                    d !== u && delete n[u],
                        n[d] = gu(o),
                        s[d] = !0
                }
            ),
                this
        }
        concat(...t) {
            return this.constructor.concat(this, ...t)
        }
        toJSON(t) {
            const n = Object.create(null);
            return U.forEach(this, (s, o) => {
                    s != null && s !== !1 && (n[o] = t && U.isArray(s) ? s.join(", ") : s)
                }
            ),
                n
        }
        [Symbol.iterator]() {
            return Object.entries(this.toJSON())[Symbol.iterator]()
        }
        toString() {
            return Object.entries(this.toJSON()).map( ([t,n]) => t + ": " + n).join(`
`)
        }
        getSetCookie() {
            return this.get("set-cookie") || []
        }
        get[Symbol.toStringTag]() {
            return "AxiosHeaders"
        }
        static from(t) {
            return t instanceof this ? t : new this(t)
        }
        static concat(t, ...n) {
            const s = new this(t);
            return n.forEach(o => s.set(o)),
                s
        }
        static accessor(t) {
            const s = (this[Fv] = this[Fv] = {
                accessors: {}
            }).accessors
                , o = this.prototype;
            function u(l) {
                const d = qo(l);
                s[d] || (XA(o, l),
                    s[d] = !0)
            }
            return U.isArray(t) ? t.forEach(u) : u(t),
                this
        }
    }
;
Ut.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
U.reduceDescriptors(Ut.prototype, ({value: e}, t) => {
        let n = t[0].toUpperCase() + t.slice(1);
        return {
            get: () => e,
            set(s) {
                this[n] = s
            }
        }
    }
);
U.freezeMethods(Ut);
function gf(e, t) {
    const n = this || Ma
        , s = t || n
        , o = Ut.from(s.headers);
    let u = s.data;
    return U.forEach(e, function(d) {
        u = d.call(n, u, o.normalize(), t ? t.status : void 0)
    }),
        o.normalize(),
        u
}
function hS(e) {
    return !!(e && e.__CANCEL__)
}
function Ji(e, t, n) {
    ke.call(this, e ?? "canceled", ke.ERR_CANCELED, t, n),
        this.name = "CanceledError"
}
U.inherits(Ji, ke, {
    __CANCEL__: !0
});
function pS(e, t, n) {
    const s = n.config.validateStatus;
    !n.status || !s || s(n.status) ? e(n) : t(new ke("Request failed with status code " + n.status,[ke.ERR_BAD_REQUEST, ke.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],n.config,n.request,n))
}
function YA(e) {
    const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
    return t && t[1] || ""
}
function JA(e, t) {
    e = e || 10;
    const n = new Array(e)
        , s = new Array(e);
    let o = 0, u = 0, l;
    return t = t !== void 0 ? t : 1e3,
        function(f) {
            const p = Date.now()
                , m = s[u];
            l || (l = p),
                n[o] = f,
                s[o] = p;
            let y = u
                , v = 0;
            for (; y !== o; )
                v += n[y++],
                    y = y % e;
            if (o = (o + 1) % e,
            o === u && (u = (u + 1) % e),
            p - l < t)
                return;
            const S = m && p - m;
            return S ? Math.round(v * 1e3 / S) : void 0
        }
}
function ZA(e, t) {
    let n = 0, s = 1e3 / t, o, u;
    const l = (p, m=Date.now()) => {
            n = m,
                o = null,
            u && (clearTimeout(u),
                u = null),
                e(...p)
        }
    ;
    return [ (...p) => {
        const m = Date.now()
            , y = m - n;
        y >= s ? l(p, m) : (o = p,
        u || (u = setTimeout( () => {
                u = null,
                    l(o)
            }
            , s - y)))
    }
        , () => o && l(o)]
}
const Ou = (e, t, n=3) => {
    let s = 0;
    const o = JA(50, 250);
    return ZA(u => {
            const l = u.loaded
                , d = u.lengthComputable ? u.total : void 0
                , f = l - s
                , p = o(f)
                , m = l <= d;
            s = l;
            const y = {
                loaded: l,
                total: d,
                progress: d ? l / d : void 0,
                bytes: f,
                rate: p || void 0,
                estimated: p && d && m ? (d - l) / p : void 0,
                event: u,
                lengthComputable: d != null,
                [t ? "download" : "upload"]: !0
            };
            e(y)
        }
        , n)
}
    , Bv = (e, t) => {
    const n = e != null;
    return [s => t[0]({
        lengthComputable: n,
        total: e,
        loaded: s
    }), t[1]]
}
    , Vv = e => (...t) => U.asap( () => e(...t))
    , e_ = Pt.hasStandardBrowserEnv ? ( (e, t) => n => (n = new URL(n,Pt.origin),
e.protocol === n.protocol && e.host === n.host && (t || e.port === n.port)))(new URL(Pt.origin), Pt.navigator && /(msie|trident)/i.test(Pt.navigator.userAgent)) : () => !0
    , t_ = Pt.hasStandardBrowserEnv ? {
    write(e, t, n, s, o, u) {
        const l = [e + "=" + encodeURIComponent(t)];
        U.isNumber(n) && l.push("expires=" + new Date(n).toGMTString()),
        U.isString(s) && l.push("path=" + s),
        U.isString(o) && l.push("domain=" + o),
        u === !0 && l.push("secure"),
            document.cookie = l.join("; ")
    },
    read(e) {
        const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
        return t ? decodeURIComponent(t[3]) : null
    },
    remove(e) {
        this.write(e, "", Date.now() - 864e5)
    }
} : {
    write() {},
    read() {
        return null
    },
    remove() {}
};
function n_(e) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e)
}
function r_(e, t) {
    return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e
}
function mS(e, t, n) {
    let s = !n_(t);
    return e && (s || n == !1) ? r_(e, t) : t
}
const Uv = e => e instanceof Ut ? {
    ...e
} : e;
function Ds(e, t) {
    t = t || {};
    const n = {};
    function s(p, m, y, v) {
        return U.isPlainObject(p) && U.isPlainObject(m) ? U.merge.call({
            caseless: v
        }, p, m) : U.isPlainObject(m) ? U.merge({}, m) : U.isArray(m) ? m.slice() : m
    }
    function o(p, m, y, v) {
        if (U.isUndefined(m)) {
            if (!U.isUndefined(p))
                return s(void 0, p, y, v)
        } else
            return s(p, m, y, v)
    }
    function u(p, m) {
        if (!U.isUndefined(m))
            return s(void 0, m)
    }
    function l(p, m) {
        if (U.isUndefined(m)) {
            if (!U.isUndefined(p))
                return s(void 0, p)
        } else
            return s(void 0, m)
    }
    function d(p, m, y) {
        if (y in t)
            return s(p, m);
        if (y in e)
            return s(void 0, p)
    }
    const f = {
        url: u,
        method: u,
        data: u,
        baseURL: l,
        transformRequest: l,
        transformResponse: l,
        paramsSerializer: l,
        timeout: l,
        timeoutMessage: l,
        withCredentials: l,
        withXSRFToken: l,
        adapter: l,
        responseType: l,
        xsrfCookieName: l,
        xsrfHeaderName: l,
        onUploadProgress: l,
        onDownloadProgress: l,
        decompress: l,
        maxContentLength: l,
        maxBodyLength: l,
        beforeRedirect: l,
        transport: l,
        httpAgent: l,
        httpsAgent: l,
        cancelToken: l,
        socketPath: l,
        responseEncoding: l,
        validateStatus: d,
        headers: (p, m, y) => o(Uv(p), Uv(m), y, !0)
    };
    return U.forEach(Object.keys({
        ...e,
        ...t
    }), function(m) {
        const y = f[m] || o
            , v = y(e[m], t[m], m);
        U.isUndefined(v) && y !== d || (n[m] = v)
    }),
        n
}
const gS = e => {
        const t = Ds({}, e);
        let {data: n, withXSRFToken: s, xsrfHeaderName: o, xsrfCookieName: u, headers: l, auth: d} = t;
        if (t.headers = l = Ut.from(l),
            t.url = cS(mS(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer),
        d && l.set("Authorization", "Basic " + btoa((d.username || "") + ":" + (d.password ? unescape(encodeURIComponent(d.password)) : ""))),
            U.isFormData(n)) {
            if (Pt.hasStandardBrowserEnv || Pt.hasStandardBrowserWebWorkerEnv)
                l.setContentType(void 0);
            else if (U.isFunction(n.getHeaders)) {
                const f = n.getHeaders()
                    , p = ["content-type", "content-length"];
                Object.entries(f).forEach( ([m,y]) => {
                        p.includes(m.toLowerCase()) && l.set(m, y)
                    }
                )
            }
        }
        if (Pt.hasStandardBrowserEnv && (s && U.isFunction(s) && (s = s(t)),
        s || s !== !1 && e_(t.url))) {
            const f = o && u && t_.read(u);
            f && l.set(o, f)
        }
        return t
    }
    , s_ = typeof XMLHttpRequest < "u"
    , i_ = s_ && function(e) {
        return new Promise(function(n, s) {
                const o = gS(e);
                let u = o.data;
                const l = Ut.from(o.headers).normalize();
                let {responseType: d, onUploadProgress: f, onDownloadProgress: p} = o, m, y, v, S, E;
                function w() {
                    S && S(),
                    E && E(),
                    o.cancelToken && o.cancelToken.unsubscribe(m),
                    o.signal && o.signal.removeEventListener("abort", m)
                }
                let x = new XMLHttpRequest;
                x.open(o.method.toUpperCase(), o.url, !0),
                    x.timeout = o.timeout;
                function T() {
                    if (!x)
                        return;
                    const R = Ut.from("getAllResponseHeaders"in x && x.getAllResponseHeaders())
                        , D = {
                        data: !d || d === "text" || d === "json" ? x.responseText : x.response,
                        status: x.status,
                        statusText: x.statusText,
                        headers: R,
                        config: e,
                        request: x
                    };
                    pS(function($) {
                        n($),
                            w()
                    }, function($) {
                        s($),
                            w()
                    }, D),
                        x = null
                }
                "onloadend"in x ? x.onloadend = T : x.onreadystatechange = function() {
                    !x || x.readyState !== 4 || x.status === 0 && !(x.responseURL && x.responseURL.indexOf("file:") === 0) || setTimeout(T)
                }
                    ,
                    x.onabort = function() {
                        x && (s(new ke("Request aborted",ke.ECONNABORTED,e,x)),
                            x = null)
                    }
                    ,
                    x.onerror = function(_) {
                        const D = _ && _.message ? _.message : "Network Error"
                            , H = new ke(D,ke.ERR_NETWORK,e,x);
                        H.event = _ || null,
                            s(H),
                            x = null
                    }
                    ,
                    x.ontimeout = function() {
                        let _ = o.timeout ? "timeout of " + o.timeout + "ms exceeded" : "timeout exceeded";
                        const D = o.transitional || dS;
                        o.timeoutErrorMessage && (_ = o.timeoutErrorMessage),
                            s(new ke(_,D.clarifyTimeoutError ? ke.ETIMEDOUT : ke.ECONNABORTED,e,x)),
                            x = null
                    }
                    ,
                u === void 0 && l.setContentType(null),
                "setRequestHeader"in x && U.forEach(l.toJSON(), function(_, D) {
                    x.setRequestHeader(D, _)
                }),
                U.isUndefined(o.withCredentials) || (x.withCredentials = !!o.withCredentials),
                d && d !== "json" && (x.responseType = o.responseType),
                p && ([v,E] = Ou(p, !0),
                    x.addEventListener("progress", v)),
                f && x.upload && ([y,S] = Ou(f),
                    x.upload.addEventListener("progress", y),
                    x.upload.addEventListener("loadend", S)),
                (o.cancelToken || o.signal) && (m = R => {
                    x && (s(!R || R.type ? new Ji(null,e,x) : R),
                        x.abort(),
                        x = null)
                }
                    ,
                o.cancelToken && o.cancelToken.subscribe(m),
                o.signal && (o.signal.aborted ? m() : o.signal.addEventListener("abort", m)));
                const k = YA(o.url);
                if (k && Pt.protocols.indexOf(k) === -1) {
                    s(new ke("Unsupported protocol " + k + ":",ke.ERR_BAD_REQUEST,e));
                    return
                }
                x.send(u || null)
            }
        )
    }
    , o_ = (e, t) => {
        const {length: n} = e = e ? e.filter(Boolean) : [];
        if (t || n) {
            let s = new AbortController, o;
            const u = function(p) {
                if (!o) {
                    o = !0,
                        d();
                    const m = p instanceof Error ? p : this.reason;
                    s.abort(m instanceof ke ? m : new Ji(m instanceof Error ? m.message : m))
                }
            };
            let l = t && setTimeout( () => {
                    l = null,
                        u(new ke(`timeout ${t} of ms exceeded`,ke.ETIMEDOUT))
                }
                , t);
            const d = () => {
                    e && (l && clearTimeout(l),
                        l = null,
                        e.forEach(p => {
                                p.unsubscribe ? p.unsubscribe(u) : p.removeEventListener("abort", u)
                            }
                        ),
                        e = null)
                }
            ;
            e.forEach(p => p.addEventListener("abort", u));
            const {signal: f} = s;
            return f.unsubscribe = () => U.asap(d),
                f
        }
    }
    , a_ = function*(e, t) {
        let n = e.byteLength;
        if (n < t) {
            yield e;
            return
        }
        let s = 0, o;
        for (; s < n; )
            o = s + t,
                yield e.slice(s, o),
                s = o
    }
    , l_ = async function*(e, t) {
        for await(const n of u_(e))
            yield*a_(n, t)
    }
    , u_ = async function*(e) {
        if (e[Symbol.asyncIterator]) {
            yield*e;
            return
        }
        const t = e.getReader();
        try {
            for (; ; ) {
                const {done: n, value: s} = await t.read();
                if (n)
                    break;
                yield s
            }
        } finally {
            await t.cancel()
        }
    }
    , zv = (e, t, n, s) => {
        const o = l_(e, t);
        let u = 0, l, d = f => {
                l || (l = !0,
                s && s(f))
            }
        ;
        return new ReadableStream({
            async pull(f) {
                try {
                    const {done: p, value: m} = await o.next();
                    if (p) {
                        d(),
                            f.close();
                        return
                    }
                    let y = m.byteLength;
                    if (n) {
                        let v = u += y;
                        n(v)
                    }
                    f.enqueue(new Uint8Array(m))
                } catch (p) {
                    throw d(p),
                        p
                }
            },
            cancel(f) {
                return d(f),
                    o.return()
            }
        },{
            highWaterMark: 2
        })
    }
    , $v = 64 * 1024
    , {isFunction: tu} = U
    , c_ = ( ({Request: e, Response: t}) => ({
        Request: e,
        Response: t
    }))(U.global)
    , {ReadableStream: Wv, TextEncoder: Hv} = U.global
    , qv = (e, ...t) => {
        try {
            return !!e(...t)
        } catch {
            return !1
        }
    }
    , d_ = e => {
        e = U.merge.call({
            skipUndefined: !0
        }, c_, e);
        const {fetch: t, Request: n, Response: s} = e
            , o = t ? tu(t) : typeof fetch == "function"
            , u = tu(n)
            , l = tu(s);
        if (!o)
            return !1;
        const d = o && tu(Wv)
            , f = o && (typeof Hv == "function" ? (E => w => E.encode(w))(new Hv) : async E => new Uint8Array(await new n(E).arrayBuffer()))
            , p = u && d && qv( () => {
                let E = !1;
                const w = new n(Pt.origin,{
                    body: new Wv,
                    method: "POST",
                    get duplex() {
                        return E = !0,
                            "half"
                    }
                }).headers.has("Content-Type");
                return E && !w
            }
        )
            , m = l && d && qv( () => U.isReadableStream(new s("").body))
            , y = {
            stream: m && (E => E.body)
        };
        o && ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(E => {
                !y[E] && (y[E] = (w, x) => {
                        let T = w && w[E];
                        if (T)
                            return T.call(w);
                        throw new ke(`Response type '${E}' is not supported`,ke.ERR_NOT_SUPPORT,x)
                    }
                )
            }
        );
        const v = async E => {
                if (E == null)
                    return 0;
                if (U.isBlob(E))
                    return E.size;
                if (U.isSpecCompliantForm(E))
                    return (await new n(Pt.origin,{
                        method: "POST",
                        body: E
                    }).arrayBuffer()).byteLength;
                if (U.isArrayBufferView(E) || U.isArrayBuffer(E))
                    return E.byteLength;
                if (U.isURLSearchParams(E) && (E = E + ""),
                    U.isString(E))
                    return (await f(E)).byteLength
            }
            , S = async (E, w) => {
                const x = U.toFiniteNumber(E.getContentLength());
                return x ?? v(w)
            }
        ;
        return async E => {
            let {url: w, method: x, data: T, signal: k, cancelToken: R, timeout: _, onDownloadProgress: D, onUploadProgress: H, responseType: $, headers: O, withCredentials: W="same-origin", fetchOptions: q} = gS(E)
                , X = t || fetch;
            $ = $ ? ($ + "").toLowerCase() : "text";
            let z = o_([k, R && R.toAbortSignal()], _)
                , J = null;
            const ae = z && z.unsubscribe && ( () => {
                    z.unsubscribe()
                }
            );
            let ie;
            try {
                if (H && p && x !== "get" && x !== "head" && (ie = await S(O, T)) !== 0) {
                    let j = new n(w,{
                        method: "POST",
                        body: T,
                        duplex: "half"
                    }), K;
                    if (U.isFormData(T) && (K = j.headers.get("content-type")) && O.setContentType(K),
                        j.body) {
                        const [ce,de] = Bv(ie, Ou(Vv(H)));
                        T = zv(j.body, $v, ce, de)
                    }
                }
                U.isString(W) || (W = W ? "include" : "omit");
                const ne = u && "credentials"in n.prototype
                    , re = {
                    ...q,
                    signal: z,
                    method: x.toUpperCase(),
                    headers: O.normalize().toJSON(),
                    body: T,
                    duplex: "half",
                    credentials: ne ? W : void 0
                };
                J = u && new n(w,re);
                let I = await (u ? X(J, q) : X(w, re));
                const se = m && ($ === "stream" || $ === "response");
                if (m && (D || se && ae)) {
                    const j = {};
                    ["status", "statusText", "headers"].forEach(be => {
                            j[be] = I[be]
                        }
                    );
                    const K = U.toFiniteNumber(I.headers.get("content-length"))
                        , [ce,de] = D && Bv(K, Ou(Vv(D), !0)) || [];
                    I = new s(zv(I.body, $v, ce, () => {
                            de && de(),
                            ae && ae()
                        }
                    ),j)
                }
                $ = $ || "text";
                let ee = await y[U.findKey(y, $) || "text"](I, E);
                return !se && ae && ae(),
                    await new Promise( (j, K) => {
                            pS(j, K, {
                                data: ee,
                                headers: Ut.from(I.headers),
                                status: I.status,
                                statusText: I.statusText,
                                config: E,
                                request: J
                            })
                        }
                    )
            } catch (ne) {
                throw ae && ae(),
                    ne && ne.name === "TypeError" && /Load failed|fetch/i.test(ne.message) ? Object.assign(new ke("Network Error",ke.ERR_NETWORK,E,J), {
                        cause: ne.cause || ne
                    }) : ke.from(ne, ne && ne.code, E, J)
            }
        }
    }
    , f_ = new Map
    , yS = e => {
        let t = e ? e.env : {};
        const {fetch: n, Request: s, Response: o} = t
            , u = [s, o, n];
        let l = u.length, d = l, f, p, m = f_;
        for (; d--; )
            f = u[d],
                p = m.get(f),
            p === void 0 && m.set(f, p = d ? new Map : d_(t)),
                m = p;
        return p
    }
;
yS();
const hh = {
    http: AA,
    xhr: i_,
    fetch: {
        get: yS
    }
};
U.forEach(hh, (e, t) => {
        if (e) {
            try {
                Object.defineProperty(e, "name", {
                    value: t
                })
            } catch {}
            Object.defineProperty(e, "adapterName", {
                value: t
            })
        }
    }
);
const Kv = e => `- ${e}`
    , h_ = e => U.isFunction(e) || e === null || e === !1
    , vS = {
    getAdapter: (e, t) => {
        e = U.isArray(e) ? e : [e];
        const {length: n} = e;
        let s, o;
        const u = {};
        for (let l = 0; l < n; l++) {
            s = e[l];
            let d;
            if (o = s,
            !h_(s) && (o = hh[(d = String(s)).toLowerCase()],
            o === void 0))
                throw new ke(`Unknown adapter '${d}'`);
            if (o && (U.isFunction(o) || (o = o.get(t))))
                break;
            u[d || "#" + l] = o
        }
        if (!o) {
            const l = Object.entries(u).map( ([f,p]) => `adapter ${f} ` + (p === !1 ? "is not supported by the environment" : "is not available in the build"));
            let d = n ? l.length > 1 ? `since :
` + l.map(Kv).join(`
`) : " " + Kv(l[0]) : "as no adapter specified";
            throw new ke("There is no suitable adapter to dispatch the request " + d,"ERR_NOT_SUPPORT")
        }
        return o
    }
    ,
    adapters: hh
};
function yf(e) {
    if (e.cancelToken && e.cancelToken.throwIfRequested(),
    e.signal && e.signal.aborted)
        throw new Ji(null,e)
}
function Qv(e) {
    return yf(e),
        e.headers = Ut.from(e.headers),
        e.data = gf.call(e, e.transformRequest),
    ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1),
        vS.getAdapter(e.adapter || Ma.adapter, e)(e).then(function(s) {
            return yf(e),
                s.data = gf.call(e, e.transformResponse, s),
                s.headers = Ut.from(s.headers),
                s
        }, function(s) {
            return hS(s) || (yf(e),
            s && s.response && (s.response.data = gf.call(e, e.transformResponse, s.response),
                s.response.headers = Ut.from(s.response.headers))),
                Promise.reject(s)
        })
}
const wS = "1.12.2"
    , Xu = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach( (e, t) => {
        Xu[e] = function(s) {
            return typeof s === e || "a" + (t < 1 ? "n " : " ") + e
        }
    }
);
const Gv = {};
Xu.transitional = function(t, n, s) {
    function o(u, l) {
        return "[Axios v" + wS + "] Transitional option '" + u + "'" + l + (s ? ". " + s : "")
    }
    return (u, l, d) => {
        if (t === !1)
            throw new ke(o(l, " has been removed" + (n ? " in " + n : "")),ke.ERR_DEPRECATED);
        return n && !Gv[l] && (Gv[l] = !0,
            console.warn(o(l, " has been deprecated since v" + n + " and will be removed in the near future"))),
            t ? t(u, l, d) : !0
    }
}
;
Xu.spelling = function(t) {
    return (n, s) => (console.warn(`${s} is likely a misspelling of ${t}`),
        !0)
}
;
function p_(e, t, n) {
    if (typeof e != "object")
        throw new ke("options must be an object",ke.ERR_BAD_OPTION_VALUE);
    const s = Object.keys(e);
    let o = s.length;
    for (; o-- > 0; ) {
        const u = s[o]
            , l = t[u];
        if (l) {
            const d = e[u]
                , f = d === void 0 || l(d, u, e);
            if (f !== !0)
                throw new ke("option " + u + " must be " + f,ke.ERR_BAD_OPTION_VALUE);
            continue
        }
        if (n !== !0)
            throw new ke("Unknown option " + u,ke.ERR_BAD_OPTION)
    }
}
const yu = {
    assertOptions: p_,
    validators: Xu
}
    , Nn = yu.validators;
let Ls = class {
        constructor(t) {
            this.defaults = t || {},
                this.interceptors = {
                    request: new Iv,
                    response: new Iv
                }
        }
        async request(t, n) {
            try {
                return await this._request(t, n)
            } catch (s) {
                if (s instanceof Error) {
                    let o = {};
                    Error.captureStackTrace ? Error.captureStackTrace(o) : o = new Error;
                    const u = o.stack ? o.stack.replace(/^.+\n/, "") : "";
                    try {
                        s.stack ? u && !String(s.stack).endsWith(u.replace(/^.+\n.+\n/, "")) && (s.stack += `
` + u) : s.stack = u
                    } catch {}
                }
                throw s
            }
        }
        _request(t, n) {
            typeof t == "string" ? (n = n || {},
                n.url = t) : n = t || {},
                n = Ds(this.defaults, n);
            const {transitional: s, paramsSerializer: o, headers: u} = n;
            s !== void 0 && yu.assertOptions(s, {
                silentJSONParsing: Nn.transitional(Nn.boolean),
                forcedJSONParsing: Nn.transitional(Nn.boolean),
                clarifyTimeoutError: Nn.transitional(Nn.boolean)
            }, !1),
            o != null && (U.isFunction(o) ? n.paramsSerializer = {
                serialize: o
            } : yu.assertOptions(o, {
                encode: Nn.function,
                serialize: Nn.function
            }, !0)),
            n.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? n.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : n.allowAbsoluteUrls = !0),
                yu.assertOptions(n, {
                    baseUrl: Nn.spelling("baseURL"),
                    withXsrfToken: Nn.spelling("withXSRFToken")
                }, !0),
                n.method = (n.method || this.defaults.method || "get").toLowerCase();
            let l = u && U.merge(u.common, u[n.method]);
            u && U.forEach(["delete", "get", "head", "post", "put", "patch", "common"], E => {
                    delete u[E]
                }
            ),
                n.headers = Ut.concat(l, u);
            const d = [];
            let f = !0;
            this.interceptors.request.forEach(function(w) {
                typeof w.runWhen == "function" && w.runWhen(n) === !1 || (f = f && w.synchronous,
                    d.unshift(w.fulfilled, w.rejected))
            });
            const p = [];
            this.interceptors.response.forEach(function(w) {
                p.push(w.fulfilled, w.rejected)
            });
            let m, y = 0, v;
            if (!f) {
                const E = [Qv.bind(this), void 0];
                for (E.unshift(...d),
                         E.push(...p),
                         v = E.length,
                         m = Promise.resolve(n); y < v; )
                    m = m.then(E[y++], E[y++]);
                return m
            }
            v = d.length;
            let S = n;
            for (; y < v; ) {
                const E = d[y++]
                    , w = d[y++];
                try {
                    S = E(S)
                } catch (x) {
                    w.call(this, x);
                    break
                }
            }
            try {
                m = Qv.call(this, S)
            } catch (E) {
                return Promise.reject(E)
            }
            for (y = 0,
                     v = p.length; y < v; )
                m = m.then(p[y++], p[y++]);
            return m
        }
        getUri(t) {
            t = Ds(this.defaults, t);
            const n = mS(t.baseURL, t.url, t.allowAbsoluteUrls);
            return cS(n, t.params, t.paramsSerializer)
        }
    }
;
U.forEach(["delete", "get", "head", "options"], function(t) {
    Ls.prototype[t] = function(n, s) {
        return this.request(Ds(s || {}, {
            method: t,
            url: n,
            data: (s || {}).data
        }))
    }
});
U.forEach(["post", "put", "patch"], function(t) {
    function n(s) {
        return function(u, l, d) {
            return this.request(Ds(d || {}, {
                method: t,
                headers: s ? {
                    "Content-Type": "multipart/form-data"
                } : {},
                url: u,
                data: l
            }))
        }
    }
    Ls.prototype[t] = n(),
        Ls.prototype[t + "Form"] = n(!0)
});
let m_ = class xS {
        constructor(t) {
            if (typeof t != "function")
                throw new TypeError("executor must be a function.");
            let n;
            this.promise = new Promise(function(u) {
                    n = u
                }
            );
            const s = this;
            this.promise.then(o => {
                    if (!s._listeners)
                        return;
                    let u = s._listeners.length;
                    for (; u-- > 0; )
                        s._listeners[u](o);
                    s._listeners = null
                }
            ),
                this.promise.then = o => {
                    let u;
                    const l = new Promise(d => {
                            s.subscribe(d),
                                u = d
                        }
                    ).then(o);
                    return l.cancel = function() {
                        s.unsubscribe(u)
                    }
                        ,
                        l
                }
                ,
                t(function(u, l, d) {
                    s.reason || (s.reason = new Ji(u,l,d),
                        n(s.reason))
                })
        }
        throwIfRequested() {
            if (this.reason)
                throw this.reason
        }
        subscribe(t) {
            if (this.reason) {
                t(this.reason);
                return
            }
            this._listeners ? this._listeners.push(t) : this._listeners = [t]
        }
        unsubscribe(t) {
            if (!this._listeners)
                return;
            const n = this._listeners.indexOf(t);
            n !== -1 && this._listeners.splice(n, 1)
        }
        toAbortSignal() {
            const t = new AbortController
                , n = s => {
                    t.abort(s)
                }
            ;
            return this.subscribe(n),
                t.signal.unsubscribe = () => this.unsubscribe(n),
                t.signal
        }
        static source() {
            let t;
            return {
                token: new xS(function(o) {
                        t = o
                    }
                ),
                cancel: t
            }
        }
    }
;
function g_(e) {
    return function(n) {
        return e.apply(null, n)
    }
}
function y_(e) {
    return U.isObject(e) && e.isAxiosError === !0
}
const ph = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
};
Object.entries(ph).forEach( ([e,t]) => {
        ph[t] = e
    }
);
function SS(e) {
    const t = new Ls(e)
        , n = Jx(Ls.prototype.request, t);
    return U.extend(n, Ls.prototype, t, {
        allOwnKeys: !0
    }),
        U.extend(n, t, null, {
            allOwnKeys: !0
        }),
        n.create = function(o) {
            return SS(Ds(e, o))
        }
        ,
        n
}
const et = SS(Ma);
et.Axios = Ls;
et.CanceledError = Ji;
et.CancelToken = m_;
et.isCancel = hS;
et.VERSION = wS;
et.toFormData = Gu;
et.AxiosError = ke;
et.Cancel = et.CanceledError;
et.all = function(t) {
    return Promise.all(t)
}
;
et.spread = g_;
et.isAxiosError = y_;
et.mergeConfig = Ds;
et.AxiosHeaders = Ut;
et.formToJSON = e => fS(U.isHTMLForm(e) ? new FormData(e) : e);
et.getAdapter = vS.getAdapter;
et.HttpStatusCode = ph;
et.default = et;
const {Axios: GF, AxiosError: XF, CanceledError: YF, isCancel: JF, CancelToken: ZF, VERSION: eB, all: tB, Cancel: nB, isAxiosError: rB, spread: sB, toFormData: iB, AxiosHeaders: oB, HttpStatusCode: aB, formToJSON: lB, getAdapter: uB, mergeConfig: cB} = et
    , v_ = typeof window > "u"
    , Xv = !v_ && window.self !== window.top
    , gt = [];
for (let e = 0; e < 256; ++e)
    gt.push((e + 256).toString(16).slice(1));
function w_(e, t=0) {
    return (gt[e[t + 0]] + gt[e[t + 1]] + gt[e[t + 2]] + gt[e[t + 3]] + "-" + gt[e[t + 4]] + gt[e[t + 5]] + "-" + gt[e[t + 6]] + gt[e[t + 7]] + "-" + gt[e[t + 8]] + gt[e[t + 9]] + "-" + gt[e[t + 10]] + gt[e[t + 11]] + gt[e[t + 12]] + gt[e[t + 13]] + gt[e[t + 14]] + gt[e[t + 15]]).toLowerCase()
}
let vf;
const x_ = new Uint8Array(16);
function S_() {
    if (!vf) {
        if (typeof crypto > "u" || !crypto.getRandomValues)
            throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        vf = crypto.getRandomValues.bind(crypto)
    }
    return vf(x_)
}
const b_ = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto)
    , Yv = {
    randomUUID: b_
};
function E_(e, t, n) {
    var o;
    e = e || {};
    const s = e.random ?? ((o = e.rng) == null ? void 0 : o.call(e)) ?? S_();
    if (s.length < 16)
        throw new Error("Random bytes length must be >= 16");
    return s[6] = s[6] & 15 | 64,
        s[8] = s[8] & 63 | 128,
        w_(s)
}
function C_(e, t, n) {
    return Yv.randomUUID && !e ? Yv.randomUUID() : E_(e)
}
class P_ extends Error {
    constructor(t, n, s, o, u) {
        super(t),
            this.name = "Base44Error",
            this.status = n,
            this.code = s,
            this.data = o,
            this.originalError = u
    }
    toJSON() {
        return {
            name: this.name,
            message: this.message,
            status: this.status,
            code: this.code,
            data: this.data
        }
    }
}
function Xo({baseURL: e, headers: t={}, token: n, interceptResponses: s=!0, onError: o}) {
    const u = et.create({
        baseURL: e,
        headers: {
            "Content-Type": "application/json",
            Accept: "application/json",
            ...t
        }
    });
    return n && (u.defaults.headers.common.Authorization = `Bearer ${n}`),
        u.interceptors.request.use(l => {
                typeof window < "u" && l.headers.set("X-Origin-URL", window.location.href);
                const d = C_();
                if (l.requestId = d,
                    Xv)
                    try {
                        window.parent.postMessage({
                            type: "api-request-start",
                            requestId: d,
                            data: {
                                url: e + l.url,
                                method: l.method,
                                body: l.data instanceof FormData ? "[FormData object]" : l.data
                            }
                        }, "*")
                    } catch {}
                return l
            }
        ),
    s && u.interceptors.response.use(l => {
            var d;
            const f = (d = l.config) === null || d === void 0 ? void 0 : d.requestId;
            try {
                Xv && f && window.parent.postMessage({
                    type: "api-request-end",
                    requestId: f,
                    data: {
                        statusCode: l.status,
                        response: l.data
                    }
                }, "*")
            } catch {}
            return l.data
        }
        , l => {
            var d, f, p, m, y, v, S, E;
            const w = ((f = (d = l.response) === null || d === void 0 ? void 0 : d.data) === null || f === void 0 ? void 0 : f.message) || ((m = (p = l.response) === null || p === void 0 ? void 0 : p.data) === null || m === void 0 ? void 0 : m.detail) || l.message
                , x = new P_(w,(y = l.response) === null || y === void 0 ? void 0 : y.status,(S = (v = l.response) === null || v === void 0 ? void 0 : v.data) === null || S === void 0 ? void 0 : S.code,(E = l.response) === null || E === void 0 ? void 0 : E.data,l);
            return o == null || o(x),
                Promise.reject(x)
        }
    ),
        u
}
function Jv(e, t) {
    return new Proxy({},{
        get(n, s) {
            if (!(typeof s != "string" || s === "then" || s.startsWith("_")))
                return T_(e, t, s)
        }
    })
}
function T_(e, t, n) {
    const s = `/apps/${t}/entities/${n}`;
    return {
        async list(o, u, l, d) {
            const f = {};
            return o && (f.sort = o),
            u && (f.limit = u),
            l && (f.skip = l),
            d && (f.fields = Array.isArray(d) ? d.join(",") : d),
                e.get(s, {
                    params: f
                })
        },
        async filter(o, u, l, d, f) {
            const p = {
                q: JSON.stringify(o)
            };
            return u && (p.sort = u),
            l && (p.limit = l),
            d && (p.skip = d),
            f && (p.fields = Array.isArray(f) ? f.join(",") : f),
                e.get(s, {
                    params: p
                })
        },
        async get(o) {
            return e.get(`${s}/${o}`)
        },
        async create(o) {
            return e.post(s, o)
        },
        async update(o, u) {
            return e.put(`${s}/${o}`, u)
        },
        async delete(o) {
            return e.delete(`${s}/${o}`)
        },
        async deleteMany(o) {
            return e.delete(s, {
                data: o
            })
        },
        async bulkCreate(o) {
            return e.post(`${s}/bulk`, o)
        },
        async importEntities(o) {
            const u = new FormData;
            return u.append("file", o, o.name),
                e.post(`${s}/import`, u, {
                    headers: {
                        "Content-Type": "multipart/form-data"
                    }
                })
        }
    }
}
function Zv(e, t) {
    return new Proxy({},{
        get(n, s) {
            if (!(typeof s != "string" || s === "then" || s.startsWith("_")))
                return new Proxy({},{
                    get(o, u) {
                        if (!(typeof u != "string" || u === "then" || u.startsWith("_")))
                            return async l => {
                                if (typeof l == "string")
                                    throw new Error(`Integration ${u} must receive an object with named parameters, received: ${l}`);
                                let d, f;
                                return l instanceof FormData || l && Object.values(l).some(p => p instanceof File) ? (d = new FormData,
                                    Object.keys(l).forEach(p => {
                                            l[p]instanceof File ? d.append(p, l[p], l[p].name) : typeof l[p] == "object" && l[p] !== null ? d.append(p, JSON.stringify(l[p])) : d.append(p, l[p])
                                        }
                                    ),
                                    f = "multipart/form-data") : (d = l,
                                    f = "application/json"),
                                    s === "Core" ? e.post(`/apps/${t}/integration-endpoints/Core/${u}`, d || l, {
                                        headers: {
                                            "Content-Type": f
                                        }
                                    }) : e.post(`/apps/${t}/integration-endpoints/installable/${s}/integration-endpoints/${u}`, d || l, {
                                        headers: {
                                            "Content-Type": f
                                        }
                                    })
                            }
                    }
                })
        }
    })
}
function k_(e, t, n, s) {
    return {
        async me() {
            return e.get(`/apps/${n}/entities/User/me`)
        },
        async updateMe(o) {
            return e.put(`/apps/${n}/entities/User/me`, o)
        },
        redirectToLogin(o) {
            var u;
            if (typeof window > "u")
                throw new Error("Login method can only be used in a browser environment");
            const l = o ? new URL(o,window.location.origin).toString() : window.location.href
                , d = `${(u = s.appBaseUrl) !== null && u !== void 0 ? u : ""}/login?from_url=${encodeURIComponent(l)}`;
            window.location.href = d
        },
        logout(o) {
            if (delete e.defaults.headers.common.Authorization,
            typeof window < "u" && window.localStorage)
                try {
                    window.localStorage.removeItem("base44_access_token"),
                        window.localStorage.removeItem("token")
                } catch (u) {
                    console.error("Failed to remove token from localStorage:", u)
                }
            typeof window < "u" && (o ? window.location.href = o : window.location.reload())
        },
        setToken(o, u=!0) {
            if (o && (e.defaults.headers.common.Authorization = `Bearer ${o}`,
                t.defaults.headers.common.Authorization = `Bearer ${o}`,
            u && typeof window < "u" && window.localStorage))
                try {
                    window.localStorage.setItem("base44_access_token", o),
                        window.localStorage.setItem("token", o)
                } catch (l) {
                    console.error("Failed to save token to localStorage:", l)
                }
        },
        async loginViaEmailPassword(o, u, l) {
            var d;
            try {
                const f = await e.post(`/apps/${n}/auth/login`, {
                    email: o,
                    password: u,
                    ...l && {
                        turnstile_token: l
                    }
                })
                    , {access_token: p, user: m} = f;
                return p && this.setToken(p),
                    {
                        access_token: p,
                        user: m
                    }
            } catch (f) {
                throw ((d = f.response) === null || d === void 0 ? void 0 : d.status) === 401 && await this.logout(),
                    f
            }
        },
        async isAuthenticated() {
            try {
                return await this.me(),
                    !0
            } catch {
                return !1
            }
        },
        inviteUser(o, u) {
            return e.post(`/apps/${n}/users/invite-user`, {
                user_email: o,
                role: u
            })
        },
        register(o) {
            return e.post(`/apps/${n}/auth/register`, o)
        },
        verifyOtp({email: o, otpCode: u}) {
            return e.post(`/apps/${n}/auth/verify-otp`, {
                email: o,
                otp_code: u
            })
        },
        resendOtp(o) {
            return e.post(`/apps/${n}/auth/resend-otp`, {
                email: o
            })
        },
        resetPasswordRequest(o) {
            return e.post(`/apps/${n}/auth/reset-password-request`, {
                email: o
            })
        },
        resetPassword({resetToken: o, newPassword: u}) {
            return e.post(`/apps/${n}/auth/reset-password`, {
                reset_token: o,
                new_password: u
            })
        },
        changePassword({userId: o, currentPassword: u, newPassword: l}) {
            return e.post(`/apps/${n}/auth/change-password`, {
                user_id: o,
                current_password: u,
                new_password: l
            })
        }
    }
}
function R_(e, t, n) {
    return {
        async getAccessToken(s) {
            const o = `/apps/${t}/auth/sso/accesstoken/${s}`
                , u = {};
            return n && (u["on-behalf-of"] = `Bearer ${n}`),
                e.get(o, {
                    headers: u
                })
        }
    }
}
function A_(e, t) {
    return {
        async getAccessToken(n) {
            if (!n || typeof n != "string")
                throw new Error("Integration type is required and must be a string");
            return (await e.get(`/apps/${t}/external-auth/tokens/${n}`)).access_token
        }
    }
}
function dp(e={}) {
    const {storageKey: t="base44_access_token", paramName: n="access_token", saveToStorage: s=!0, removeFromUrl: o=!0} = e;
    let u = null;
    if (typeof window < "u" && window.location)
        try {
            const l = new URLSearchParams(window.location.search);
            if (u = l.get(n),
                u) {
                if (s && __(u, {
                    storageKey: t
                }),
                    o) {
                    l.delete(n);
                    const d = `${window.location.pathname}${l.toString() ? `?${l.toString()}` : ""}${window.location.hash}`;
                    window.history.replaceState({}, document.title, d)
                }
                return u
            }
        } catch (l) {
            console.error("Error retrieving token from URL:", l)
        }
    if (typeof window < "u" && window.localStorage)
        try {
            return u = window.localStorage.getItem(t),
                u
        } catch (l) {
            console.error("Error retrieving token from localStorage:", l)
        }
    return null
}
function __(e, t) {
    const {storageKey: n="base44_access_token"} = t;
    if (typeof window > "u" || !window.localStorage || !e)
        return !1;
    try {
        return window.localStorage.setItem(n, e),
            window.localStorage.setItem("token", e),
            !0
    } catch (s) {
        return console.error("Error saving token to localStorage:", s),
            !1
    }
}
function e0(e, t) {
    return {
        async invoke(n, s) {
            if (typeof s == "string")
                throw new Error(`Function ${n} must receive an object with named parameters, received: ${s}`);
            let o, u;
            return s instanceof FormData || s && Object.values(s).some(l => l instanceof File) ? (o = new FormData,
                Object.keys(s).forEach(l => {
                        s[l]instanceof File ? o.append(l, s[l], s[l].name) : typeof s[l] == "object" && s[l] !== null ? o.append(l, JSON.stringify(s[l])) : o.append(l, s[l])
                    }
                ),
                u = "multipart/form-data") : (o = s,
                u = "application/json"),
                e.post(`/apps/${t}/functions/${n}`, o || s, {
                    headers: {
                        "Content-Type": u
                    }
                })
        }
    }
}
function t0({axios: e, socket: t, appId: n, serverUrl: s, token: o}) {
    const u = `/apps/${n}/agents`;
    return {
        getConversations: () => e.get(`${u}/conversations`),
        getConversation: S => e.get(`${u}/conversations/${S}`),
        listConversations: S => e.get(`${u}/conversations`, {
            params: S
        }),
        createConversation: S => e.post(`${u}/conversations`, S),
        addMessage: async (S, E) => {
            const w = `/agent-conversations/${S.id}`;
            return await t.updateModel(w, {
                ...S,
                messages: [...S.messages || [], E]
            }),
                e.post(`${u}/conversations/${S.id}/messages`, E)
        }
        ,
        subscribeToConversation: (S, E) => {
            const w = `/agent-conversations/${S}`;
            return t.subscribeToRoom(w, {
                connect: () => {}
                ,
                update_model: ({data: x}) => {
                    const T = JSON.parse(x);
                    E == null || E(T)
                }
            })
        }
        ,
        getWhatsAppConnectURL: S => {
            const E = `${s}/api/apps/${n}/agents/${encodeURIComponent(S)}/whatsapp`
                , w = o ?? dp();
            return w ? `${E}?token=${w}` : E
        }
    }
}
function n0(e, t) {
    const n = `/app-logs/${t}`;
    return {
        async logUserInApp(s) {
            await e.post(`${n}/log-user-in-app/${s}`)
        },
        async fetchLogs(s={}) {
            return await e.get(n, {
                params: s
            })
        },
        async getStats(s={}) {
            return await e.get(`${n}/stats`, {
                params: s
            })
        }
    }
}
const zn = Object.create(null);
zn.open = "0";
zn.close = "1";
zn.ping = "2";
zn.pong = "3";
zn.message = "4";
zn.upgrade = "5";
zn.noop = "6";
const vu = Object.create(null);
Object.keys(zn).forEach(e => {
        vu[zn[e]] = e
    }
);
const mh = {
        type: "error",
        data: "parser error"
    }
    , bS = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]"
    , ES = typeof ArrayBuffer == "function"
    , CS = e => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(e) : e && e.buffer instanceof ArrayBuffer
    , fp = ({type: e, data: t}, n, s) => bS && t instanceof Blob ? n ? s(t) : r0(t, s) : ES && (t instanceof ArrayBuffer || CS(t)) ? n ? s(t) : r0(new Blob([t]), s) : s(zn[e] + (t || ""))
    , r0 = (e, t) => {
        const n = new FileReader;
        return n.onload = function() {
            const s = n.result.split(",")[1];
            t("b" + (s || ""))
        }
            ,
            n.readAsDataURL(e)
    }
;
function s0(e) {
    return e instanceof Uint8Array ? e : e instanceof ArrayBuffer ? new Uint8Array(e) : new Uint8Array(e.buffer,e.byteOffset,e.byteLength)
}
let wf;
function N_(e, t) {
    if (bS && e.data instanceof Blob)
        return e.data.arrayBuffer().then(s0).then(t);
    if (ES && (e.data instanceof ArrayBuffer || CS(e.data)))
        return t(s0(e.data));
    fp(e, !1, n => {
            wf || (wf = new TextEncoder),
                t(wf.encode(n))
        }
    )
}
const i0 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
    , Yo = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (let e = 0; e < i0.length; e++)
    Yo[i0.charCodeAt(e)] = e;
const O_ = e => {
        let t = e.length * .75, n = e.length, s, o = 0, u, l, d, f;
        e[e.length - 1] === "=" && (t--,
        e[e.length - 2] === "=" && t--);
        const p = new ArrayBuffer(t)
            , m = new Uint8Array(p);
        for (s = 0; s < n; s += 4)
            u = Yo[e.charCodeAt(s)],
                l = Yo[e.charCodeAt(s + 1)],
                d = Yo[e.charCodeAt(s + 2)],
                f = Yo[e.charCodeAt(s + 3)],
                m[o++] = u << 2 | l >> 4,
                m[o++] = (l & 15) << 4 | d >> 2,
                m[o++] = (d & 3) << 6 | f & 63;
        return p
    }
    , L_ = typeof ArrayBuffer == "function"
    , hp = (e, t) => {
        if (typeof e != "string")
            return {
                type: "message",
                data: PS(e, t)
            };
        const n = e.charAt(0);
        return n === "b" ? {
            type: "message",
            data: M_(e.substring(1), t)
        } : vu[n] ? e.length > 1 ? {
            type: vu[n],
            data: e.substring(1)
        } : {
            type: vu[n]
        } : mh
    }
    , M_ = (e, t) => {
        if (L_) {
            const n = O_(e);
            return PS(n, t)
        } else
            return {
                base64: !0,
                data: e
            }
    }
    , PS = (e, t) => {
        switch (t) {
            case "blob":
                return e instanceof Blob ? e : new Blob([e]);
            case "arraybuffer":
            default:
                return e instanceof ArrayBuffer ? e : e.buffer
        }
    }
    , TS = ""
    , j_ = (e, t) => {
        const n = e.length
            , s = new Array(n);
        let o = 0;
        e.forEach( (u, l) => {
                fp(u, !1, d => {
                        s[l] = d,
                        ++o === n && t(s.join(TS))
                    }
                )
            }
        )
    }
    , D_ = (e, t) => {
        const n = e.split(TS)
            , s = [];
        for (let o = 0; o < n.length; o++) {
            const u = hp(n[o], t);
            if (s.push(u),
            u.type === "error")
                break
        }
        return s
    }
;
function I_() {
    return new TransformStream({
        transform(e, t) {
            N_(e, n => {
                    const s = n.length;
                    let o;
                    if (s < 126)
                        o = new Uint8Array(1),
                            new DataView(o.buffer).setUint8(0, s);
                    else if (s < 65536) {
                        o = new Uint8Array(3);
                        const u = new DataView(o.buffer);
                        u.setUint8(0, 126),
                            u.setUint16(1, s)
                    } else {
                        o = new Uint8Array(9);
                        const u = new DataView(o.buffer);
                        u.setUint8(0, 127),
                            u.setBigUint64(1, BigInt(s))
                    }
                    e.data && typeof e.data != "string" && (o[0] |= 128),
                        t.enqueue(o),
                        t.enqueue(n)
                }
            )
        }
    })
}
let xf;
function nu(e) {
    return e.reduce( (t, n) => t + n.length, 0)
}
function ru(e, t) {
    if (e[0].length === t)
        return e.shift();
    const n = new Uint8Array(t);
    let s = 0;
    for (let o = 0; o < t; o++)
        n[o] = e[0][s++],
        s === e[0].length && (e.shift(),
            s = 0);
    return e.length && s < e[0].length && (e[0] = e[0].slice(s)),
        n
}
function F_(e, t) {
    xf || (xf = new TextDecoder);
    const n = [];
    let s = 0
        , o = -1
        , u = !1;
    return new TransformStream({
        transform(l, d) {
            for (n.push(l); ; ) {
                if (s === 0) {
                    if (nu(n) < 1)
                        break;
                    const f = ru(n, 1);
                    u = (f[0] & 128) === 128,
                        o = f[0] & 127,
                        o < 126 ? s = 3 : o === 126 ? s = 1 : s = 2
                } else if (s === 1) {
                    if (nu(n) < 2)
                        break;
                    const f = ru(n, 2);
                    o = new DataView(f.buffer,f.byteOffset,f.length).getUint16(0),
                        s = 3
                } else if (s === 2) {
                    if (nu(n) < 8)
                        break;
                    const f = ru(n, 8)
                        , p = new DataView(f.buffer,f.byteOffset,f.length)
                        , m = p.getUint32(0);
                    if (m > Math.pow(2, 21) - 1) {
                        d.enqueue(mh);
                        break
                    }
                    o = m * Math.pow(2, 32) + p.getUint32(4),
                        s = 3
                } else {
                    if (nu(n) < o)
                        break;
                    const f = ru(n, o);
                    d.enqueue(hp(u ? f : xf.decode(f), t)),
                        s = 0
                }
                if (o === 0 || o > e) {
                    d.enqueue(mh);
                    break
                }
            }
        }
    })
}
const kS = 4;
function st(e) {
    if (e)
        return B_(e)
}
function B_(e) {
    for (var t in st.prototype)
        e[t] = st.prototype[t];
    return e
}
st.prototype.on = st.prototype.addEventListener = function(e, t) {
    return this._callbacks = this._callbacks || {},
        (this._callbacks["$" + e] = this._callbacks["$" + e] || []).push(t),
        this
}
;
st.prototype.once = function(e, t) {
    function n() {
        this.off(e, n),
            t.apply(this, arguments)
    }
    return n.fn = t,
        this.on(e, n),
        this
}
;
st.prototype.off = st.prototype.removeListener = st.prototype.removeAllListeners = st.prototype.removeEventListener = function(e, t) {
    if (this._callbacks = this._callbacks || {},
    arguments.length == 0)
        return this._callbacks = {},
            this;
    var n = this._callbacks["$" + e];
    if (!n)
        return this;
    if (arguments.length == 1)
        return delete this._callbacks["$" + e],
            this;
    for (var s, o = 0; o < n.length; o++)
        if (s = n[o],
        s === t || s.fn === t) {
            n.splice(o, 1);
            break
        }
    return n.length === 0 && delete this._callbacks["$" + e],
        this
}
;
st.prototype.emit = function(e) {
    this._callbacks = this._callbacks || {};
    for (var t = new Array(arguments.length - 1), n = this._callbacks["$" + e], s = 1; s < arguments.length; s++)
        t[s - 1] = arguments[s];
    if (n) {
        n = n.slice(0);
        for (var s = 0, o = n.length; s < o; ++s)
            n[s].apply(this, t)
    }
    return this
}
;
st.prototype.emitReserved = st.prototype.emit;
st.prototype.listeners = function(e) {
    return this._callbacks = this._callbacks || {},
    this._callbacks["$" + e] || []
}
;
st.prototype.hasListeners = function(e) {
    return !!this.listeners(e).length
}
;
const Yu = typeof Promise == "function" && typeof Promise.resolve == "function" ? t => Promise.resolve().then(t) : (t, n) => n(t, 0)
    , un = typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")()
    , V_ = "arraybuffer";
function RS(e, ...t) {
    return t.reduce( (n, s) => (e.hasOwnProperty(s) && (n[s] = e[s]),
        n), {})
}
const U_ = un.setTimeout
    , z_ = un.clearTimeout;
function Ju(e, t) {
    t.useNativeTimers ? (e.setTimeoutFn = U_.bind(un),
        e.clearTimeoutFn = z_.bind(un)) : (e.setTimeoutFn = un.setTimeout.bind(un),
        e.clearTimeoutFn = un.clearTimeout.bind(un))
}
const $_ = 1.33;
function W_(e) {
    return typeof e == "string" ? H_(e) : Math.ceil((e.byteLength || e.size) * $_)
}
function H_(e) {
    let t = 0
        , n = 0;
    for (let s = 0, o = e.length; s < o; s++)
        t = e.charCodeAt(s),
            t < 128 ? n += 1 : t < 2048 ? n += 2 : t < 55296 || t >= 57344 ? n += 3 : (s++,
                n += 4);
    return n
}
function AS() {
    return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5)
}
function q_(e) {
    let t = "";
    for (let n in e)
        e.hasOwnProperty(n) && (t.length && (t += "&"),
            t += encodeURIComponent(n) + "=" + encodeURIComponent(e[n]));
    return t
}
function K_(e) {
    let t = {}
        , n = e.split("&");
    for (let s = 0, o = n.length; s < o; s++) {
        let u = n[s].split("=");
        t[decodeURIComponent(u[0])] = decodeURIComponent(u[1])
    }
    return t
}
class Q_ extends Error {
    constructor(t, n, s) {
        super(t),
            this.description = n,
            this.context = s,
            this.type = "TransportError"
    }
}
class pp extends st {
    constructor(t) {
        super(),
            this.writable = !1,
            Ju(this, t),
            this.opts = t,
            this.query = t.query,
            this.socket = t.socket,
            this.supportsBinary = !t.forceBase64
    }
    onError(t, n, s) {
        return super.emitReserved("error", new Q_(t,n,s)),
            this
    }
    open() {
        return this.readyState = "opening",
            this.doOpen(),
            this
    }
    close() {
        return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(),
            this.onClose()),
            this
    }
    send(t) {
        this.readyState === "open" && this.write(t)
    }
    onOpen() {
        this.readyState = "open",
            this.writable = !0,
            super.emitReserved("open")
    }
    onData(t) {
        const n = hp(t, this.socket.binaryType);
        this.onPacket(n)
    }
    onPacket(t) {
        super.emitReserved("packet", t)
    }
    onClose(t) {
        this.readyState = "closed",
            super.emitReserved("close", t)
    }
    pause(t) {}
    createUri(t, n={}) {
        return t + "://" + this._hostname() + this._port() + this.opts.path + this._query(n)
    }
    _hostname() {
        const t = this.opts.hostname;
        return t.indexOf(":") === -1 ? t : "[" + t + "]"
    }
    _port() {
        return this.opts.port && (this.opts.secure && +(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80) ? ":" + this.opts.port : ""
    }
    _query(t) {
        const n = q_(t);
        return n.length ? "?" + n : ""
    }
}
class G_ extends pp {
    constructor() {
        super(...arguments),
            this._polling = !1
    }
    get name() {
        return "polling"
    }
    doOpen() {
        this._poll()
    }
    pause(t) {
        this.readyState = "pausing";
        const n = () => {
                this.readyState = "paused",
                    t()
            }
        ;
        if (this._polling || !this.writable) {
            let s = 0;
            this._polling && (s++,
                this.once("pollComplete", function() {
                    --s || n()
                })),
            this.writable || (s++,
                this.once("drain", function() {
                    --s || n()
                }))
        } else
            n()
    }
    _poll() {
        this._polling = !0,
            this.doPoll(),
            this.emitReserved("poll")
    }
    onData(t) {
        const n = s => {
                if (this.readyState === "opening" && s.type === "open" && this.onOpen(),
                s.type === "close")
                    return this.onClose({
                        description: "transport closed by the server"
                    }),
                        !1;
                this.onPacket(s)
            }
        ;
        D_(t, this.socket.binaryType).forEach(n),
        this.readyState !== "closed" && (this._polling = !1,
            this.emitReserved("pollComplete"),
        this.readyState === "open" && this._poll())
    }
    doClose() {
        const t = () => {
                this.write([{
                    type: "close"
                }])
            }
        ;
        this.readyState === "open" ? t() : this.once("open", t)
    }
    write(t) {
        this.writable = !1,
            j_(t, n => {
                    this.doWrite(n, () => {
                            this.writable = !0,
                                this.emitReserved("drain")
                        }
                    )
                }
            )
    }
    uri() {
        const t = this.opts.secure ? "https" : "http"
            , n = this.query || {};
        return this.opts.timestampRequests !== !1 && (n[this.opts.timestampParam] = AS()),
        !this.supportsBinary && !n.sid && (n.b64 = 1),
            this.createUri(t, n)
    }
}
let _S = !1;
try {
    _S = typeof XMLHttpRequest < "u" && "withCredentials"in new XMLHttpRequest
} catch {}
const X_ = _S;
function Y_() {}
class J_ extends G_ {
    constructor(t) {
        if (super(t),
        typeof location < "u") {
            const n = location.protocol === "https:";
            let s = location.port;
            s || (s = n ? "443" : "80"),
                this.xd = typeof location < "u" && t.hostname !== location.hostname || s !== t.port
        }
    }
    doWrite(t, n) {
        const s = this.request({
            method: "POST",
            data: t
        });
        s.on("success", n),
            s.on("error", (o, u) => {
                    this.onError("xhr post error", o, u)
                }
            )
    }
    doPoll() {
        const t = this.request();
        t.on("data", this.onData.bind(this)),
            t.on("error", (n, s) => {
                    this.onError("xhr poll error", n, s)
                }
            ),
            this.pollXhr = t
    }
}
class Fn extends st {
    constructor(t, n, s) {
        super(),
            this.createRequest = t,
            Ju(this, s),
            this._opts = s,
            this._method = s.method || "GET",
            this._uri = n,
            this._data = s.data !== void 0 ? s.data : null,
            this._create()
    }
    _create() {
        var t;
        const n = RS(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
        n.xdomain = !!this._opts.xd;
        const s = this._xhr = this.createRequest(n);
        try {
            s.open(this._method, this._uri, !0);
            try {
                if (this._opts.extraHeaders) {
                    s.setDisableHeaderCheck && s.setDisableHeaderCheck(!0);
                    for (let o in this._opts.extraHeaders)
                        this._opts.extraHeaders.hasOwnProperty(o) && s.setRequestHeader(o, this._opts.extraHeaders[o])
                }
            } catch {}
            if (this._method === "POST")
                try {
                    s.setRequestHeader("Content-type", "text/plain;charset=UTF-8")
                } catch {}
            try {
                s.setRequestHeader("Accept", "*/*")
            } catch {}
            (t = this._opts.cookieJar) === null || t === void 0 || t.addCookies(s),
            "withCredentials"in s && (s.withCredentials = this._opts.withCredentials),
            this._opts.requestTimeout && (s.timeout = this._opts.requestTimeout),
                s.onreadystatechange = () => {
                    var o;
                    s.readyState === 3 && ((o = this._opts.cookieJar) === null || o === void 0 || o.parseCookies(s.getResponseHeader("set-cookie"))),
                    s.readyState === 4 && (s.status === 200 || s.status === 1223 ? this._onLoad() : this.setTimeoutFn( () => {
                            this._onError(typeof s.status == "number" ? s.status : 0)
                        }
                        , 0))
                }
                ,
                s.send(this._data)
        } catch (o) {
            this.setTimeoutFn( () => {
                    this._onError(o)
                }
                , 0);
            return
        }
        typeof document < "u" && (this._index = Fn.requestsCount++,
            Fn.requests[this._index] = this)
    }
    _onError(t) {
        this.emitReserved("error", t, this._xhr),
            this._cleanup(!0)
    }
    _cleanup(t) {
        if (!(typeof this._xhr > "u" || this._xhr === null)) {
            if (this._xhr.onreadystatechange = Y_,
                t)
                try {
                    this._xhr.abort()
                } catch {}
            typeof document < "u" && delete Fn.requests[this._index],
                this._xhr = null
        }
    }
    _onLoad() {
        const t = this._xhr.responseText;
        t !== null && (this.emitReserved("data", t),
            this.emitReserved("success"),
            this._cleanup())
    }
    abort() {
        this._cleanup()
    }
}
Fn.requestsCount = 0;
Fn.requests = {};
if (typeof document < "u") {
    if (typeof attachEvent == "function")
        attachEvent("onunload", o0);
    else if (typeof addEventListener == "function") {
        const e = "onpagehide"in un ? "pagehide" : "unload";
        addEventListener(e, o0, !1)
    }
}
function o0() {
    for (let e in Fn.requests)
        Fn.requests.hasOwnProperty(e) && Fn.requests[e].abort()
}
const Z_ = (function() {
        const e = NS({
            xdomain: !1
        });
        return e && e.responseType !== null
    }
)();
class eN extends J_ {
    constructor(t) {
        super(t);
        const n = t && t.forceBase64;
        this.supportsBinary = Z_ && !n
    }
    request(t={}) {
        return Object.assign(t, {
            xd: this.xd
        }, this.opts),
            new Fn(NS,this.uri(),t)
    }
}
function NS(e) {
    const t = e.xdomain;
    try {
        if (typeof XMLHttpRequest < "u" && (!t || X_))
            return new XMLHttpRequest
    } catch {}
    if (!t)
        try {
            return new un[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP")
        } catch {}
}
const OS = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative";
class tN extends pp {
    get name() {
        return "websocket"
    }
    doOpen() {
        const t = this.uri()
            , n = this.opts.protocols
            , s = OS ? {} : RS(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
        this.opts.extraHeaders && (s.headers = this.opts.extraHeaders);
        try {
            this.ws = this.createSocket(t, n, s)
        } catch (o) {
            return this.emitReserved("error", o)
        }
        this.ws.binaryType = this.socket.binaryType,
            this.addEventListeners()
    }
    addEventListeners() {
        this.ws.onopen = () => {
            this.opts.autoUnref && this.ws._socket.unref(),
                this.onOpen()
        }
            ,
            this.ws.onclose = t => this.onClose({
                description: "websocket connection closed",
                context: t
            }),
            this.ws.onmessage = t => this.onData(t.data),
            this.ws.onerror = t => this.onError("websocket error", t)
    }
    write(t) {
        this.writable = !1;
        for (let n = 0; n < t.length; n++) {
            const s = t[n]
                , o = n === t.length - 1;
            fp(s, this.supportsBinary, u => {
                    try {
                        this.doWrite(s, u)
                    } catch {}
                    o && Yu( () => {
                            this.writable = !0,
                                this.emitReserved("drain")
                        }
                        , this.setTimeoutFn)
                }
            )
        }
    }
    doClose() {
        typeof this.ws < "u" && (this.ws.onerror = () => {}
            ,
            this.ws.close(),
            this.ws = null)
    }
    uri() {
        const t = this.opts.secure ? "wss" : "ws"
            , n = this.query || {};
        return this.opts.timestampRequests && (n[this.opts.timestampParam] = AS()),
        this.supportsBinary || (n.b64 = 1),
            this.createUri(t, n)
    }
}
const Sf = un.WebSocket || un.MozWebSocket;
class nN extends tN {
    createSocket(t, n, s) {
        return OS ? new Sf(t,n,s) : n ? new Sf(t,n) : new Sf(t)
    }
    doWrite(t, n) {
        this.ws.send(n)
    }
}
class rN extends pp {
    get name() {
        return "webtransport"
    }
    doOpen() {
        try {
            this._transport = new WebTransport(this.createUri("https"),this.opts.transportOptions[this.name])
        } catch (t) {
            return this.emitReserved("error", t)
        }
        this._transport.closed.then( () => {
                this.onClose()
            }
        ).catch(t => {
                this.onError("webtransport error", t)
            }
        ),
            this._transport.ready.then( () => {
                    this._transport.createBidirectionalStream().then(t => {
                            const n = F_(Number.MAX_SAFE_INTEGER, this.socket.binaryType)
                                , s = t.readable.pipeThrough(n).getReader()
                                , o = I_();
                            o.readable.pipeTo(t.writable),
                                this._writer = o.writable.getWriter();
                            const u = () => {
                                    s.read().then( ({done: d, value: f}) => {
                                            d || (this.onPacket(f),
                                                u())
                                        }
                                    ).catch(d => {}
                                    )
                                }
                            ;
                            u();
                            const l = {
                                type: "open"
                            };
                            this.query.sid && (l.data = `{"sid":"${this.query.sid}"}`),
                                this._writer.write(l).then( () => this.onOpen())
                        }
                    )
                }
            )
    }
    write(t) {
        this.writable = !1;
        for (let n = 0; n < t.length; n++) {
            const s = t[n]
                , o = n === t.length - 1;
            this._writer.write(s).then( () => {
                    o && Yu( () => {
                            this.writable = !0,
                                this.emitReserved("drain")
                        }
                        , this.setTimeoutFn)
                }
            )
        }
    }
    doClose() {
        var t;
        (t = this._transport) === null || t === void 0 || t.close()
    }
}
const sN = {
    websocket: nN,
    webtransport: rN,
    polling: eN
}
    , iN = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
    , oN = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"];
function gh(e) {
    if (e.length > 8e3)
        throw "URI too long";
    const t = e
        , n = e.indexOf("[")
        , s = e.indexOf("]");
    n != -1 && s != -1 && (e = e.substring(0, n) + e.substring(n, s).replace(/:/g, ";") + e.substring(s, e.length));
    let o = iN.exec(e || "")
        , u = {}
        , l = 14;
    for (; l--; )
        u[oN[l]] = o[l] || "";
    return n != -1 && s != -1 && (u.source = t,
        u.host = u.host.substring(1, u.host.length - 1).replace(/;/g, ":"),
        u.authority = u.authority.replace("[", "").replace("]", "").replace(/;/g, ":"),
        u.ipv6uri = !0),
        u.pathNames = aN(u, u.path),
        u.queryKey = lN(u, u.query),
        u
}
function aN(e, t) {
    const n = /\/{2,9}/g
        , s = t.replace(n, "/").split("/");
    return (t.slice(0, 1) == "/" || t.length === 0) && s.splice(0, 1),
    t.slice(-1) == "/" && s.splice(s.length - 1, 1),
        s
}
function lN(e, t) {
    const n = {};
    return t.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(s, o, u) {
        o && (n[o] = u)
    }),
        n
}
const yh = typeof addEventListener == "function" && typeof removeEventListener == "function"
    , wu = [];
yh && addEventListener("offline", () => {
        wu.forEach(e => e())
    }
    , !1);
class Xr extends st {
    constructor(t, n) {
        if (super(),
            this.binaryType = V_,
            this.writeBuffer = [],
            this._prevBufferLen = 0,
            this._pingInterval = -1,
            this._pingTimeout = -1,
            this._maxPayload = -1,
            this._pingTimeoutTime = 1 / 0,
        t && typeof t == "object" && (n = t,
            t = null),
            t) {
            const s = gh(t);
            n.hostname = s.host,
                n.secure = s.protocol === "https" || s.protocol === "wss",
                n.port = s.port,
            s.query && (n.query = s.query)
        } else
            n.host && (n.hostname = gh(n.host).host);
        Ju(this, n),
            this.secure = n.secure != null ? n.secure : typeof location < "u" && location.protocol === "https:",
        n.hostname && !n.port && (n.port = this.secure ? "443" : "80"),
            this.hostname = n.hostname || (typeof location < "u" ? location.hostname : "localhost"),
            this.port = n.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"),
            this.transports = [],
            this._transportsByName = {},
            n.transports.forEach(s => {
                    const o = s.prototype.name;
                    this.transports.push(o),
                        this._transportsByName[o] = s
                }
            ),
            this.opts = Object.assign({
                path: "/engine.io",
                agent: !1,
                withCredentials: !1,
                upgrade: !0,
                timestampParam: "t",
                rememberUpgrade: !1,
                addTrailingSlash: !0,
                rejectUnauthorized: !0,
                perMessageDeflate: {
                    threshold: 1024
                },
                transportOptions: {},
                closeOnBeforeunload: !1
            }, n),
            this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : ""),
        typeof this.opts.query == "string" && (this.opts.query = K_(this.opts.query)),
        yh && (this.opts.closeOnBeforeunload && (this._beforeunloadEventListener = () => {
            this.transport && (this.transport.removeAllListeners(),
                this.transport.close())
        }
            ,
            addEventListener("beforeunload", this._beforeunloadEventListener, !1)),
        this.hostname !== "localhost" && (this._offlineEventListener = () => {
            this._onClose("transport close", {
                description: "network connection lost"
            })
        }
            ,
            wu.push(this._offlineEventListener))),
        this.opts.withCredentials && (this._cookieJar = void 0),
            this._open()
    }
    createTransport(t) {
        const n = Object.assign({}, this.opts.query);
        n.EIO = kS,
            n.transport = t,
        this.id && (n.sid = this.id);
        const s = Object.assign({}, this.opts, {
            query: n,
            socket: this,
            hostname: this.hostname,
            secure: this.secure,
            port: this.port
        }, this.opts.transportOptions[t]);
        return new this._transportsByName[t](s)
    }
    _open() {
        if (this.transports.length === 0) {
            this.setTimeoutFn( () => {
                    this.emitReserved("error", "No transports available")
                }
                , 0);
            return
        }
        const t = this.opts.rememberUpgrade && Xr.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0];
        this.readyState = "opening";
        const n = this.createTransport(t);
        n.open(),
            this.setTransport(n)
    }
    setTransport(t) {
        this.transport && this.transport.removeAllListeners(),
            this.transport = t,
            t.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", n => this._onClose("transport close", n))
    }
    onOpen() {
        this.readyState = "open",
            Xr.priorWebsocketSuccess = this.transport.name === "websocket",
            this.emitReserved("open"),
            this.flush()
    }
    _onPacket(t) {
        if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing")
            switch (this.emitReserved("packet", t),
                this.emitReserved("heartbeat"),
                t.type) {
                case "open":
                    this.onHandshake(JSON.parse(t.data));
                    break;
                case "ping":
                    this._sendPacket("pong"),
                        this.emitReserved("ping"),
                        this.emitReserved("pong"),
                        this._resetPingTimeout();
                    break;
                case "error":
                    const n = new Error("server error");
                    n.code = t.data,
                        this._onError(n);
                    break;
                case "message":
                    this.emitReserved("data", t.data),
                        this.emitReserved("message", t.data);
                    break
            }
    }
    onHandshake(t) {
        this.emitReserved("handshake", t),
            this.id = t.sid,
            this.transport.query.sid = t.sid,
            this._pingInterval = t.pingInterval,
            this._pingTimeout = t.pingTimeout,
            this._maxPayload = t.maxPayload,
            this.onOpen(),
        this.readyState !== "closed" && this._resetPingTimeout()
    }
    _resetPingTimeout() {
        this.clearTimeoutFn(this._pingTimeoutTimer);
        const t = this._pingInterval + this._pingTimeout;
        this._pingTimeoutTime = Date.now() + t,
            this._pingTimeoutTimer = this.setTimeoutFn( () => {
                    this._onClose("ping timeout")
                }
                , t),
        this.opts.autoUnref && this._pingTimeoutTimer.unref()
    }
    _onDrain() {
        this.writeBuffer.splice(0, this._prevBufferLen),
            this._prevBufferLen = 0,
            this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush()
    }
    flush() {
        if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
            const t = this._getWritablePackets();
            this.transport.send(t),
                this._prevBufferLen = t.length,
                this.emitReserved("flush")
        }
    }
    _getWritablePackets() {
        if (!(this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1))
            return this.writeBuffer;
        let n = 1;
        for (let s = 0; s < this.writeBuffer.length; s++) {
            const o = this.writeBuffer[s].data;
            if (o && (n += W_(o)),
            s > 0 && n > this._maxPayload)
                return this.writeBuffer.slice(0, s);
            n += 2
        }
        return this.writeBuffer
    }
    _hasPingExpired() {
        if (!this._pingTimeoutTime)
            return !0;
        const t = Date.now() > this._pingTimeoutTime;
        return t && (this._pingTimeoutTime = 0,
            Yu( () => {
                    this._onClose("ping timeout")
                }
                , this.setTimeoutFn)),
            t
    }
    write(t, n, s) {
        return this._sendPacket("message", t, n, s),
            this
    }
    send(t, n, s) {
        return this._sendPacket("message", t, n, s),
            this
    }
    _sendPacket(t, n, s, o) {
        if (typeof n == "function" && (o = n,
            n = void 0),
        typeof s == "function" && (o = s,
            s = null),
        this.readyState === "closing" || this.readyState === "closed")
            return;
        s = s || {},
            s.compress = s.compress !== !1;
        const u = {
            type: t,
            data: n,
            options: s
        };
        this.emitReserved("packetCreate", u),
            this.writeBuffer.push(u),
        o && this.once("flush", o),
            this.flush()
    }
    close() {
        const t = () => {
                this._onClose("forced close"),
                    this.transport.close()
            }
            , n = () => {
                this.off("upgrade", n),
                    this.off("upgradeError", n),
                    t()
            }
            , s = () => {
                this.once("upgrade", n),
                    this.once("upgradeError", n)
            }
        ;
        return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing",
            this.writeBuffer.length ? this.once("drain", () => {
                    this.upgrading ? s() : t()
                }
            ) : this.upgrading ? s() : t()),
            this
    }
    _onError(t) {
        if (Xr.priorWebsocketSuccess = !1,
        this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening")
            return this.transports.shift(),
                this._open();
        this.emitReserved("error", t),
            this._onClose("transport error", t)
    }
    _onClose(t, n) {
        if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
            if (this.clearTimeoutFn(this._pingTimeoutTimer),
                this.transport.removeAllListeners("close"),
                this.transport.close(),
                this.transport.removeAllListeners(),
            yh && (this._beforeunloadEventListener && removeEventListener("beforeunload", this._beforeunloadEventListener, !1),
                this._offlineEventListener)) {
                const s = wu.indexOf(this._offlineEventListener);
                s !== -1 && wu.splice(s, 1)
            }
            this.readyState = "closed",
                this.id = null,
                this.emitReserved("close", t, n),
                this.writeBuffer = [],
                this._prevBufferLen = 0
        }
    }
}
Xr.protocol = kS;
class uN extends Xr {
    constructor() {
        super(...arguments),
            this._upgrades = []
    }
    onOpen() {
        if (super.onOpen(),
        this.readyState === "open" && this.opts.upgrade)
            for (let t = 0; t < this._upgrades.length; t++)
                this._probe(this._upgrades[t])
    }
    _probe(t) {
        let n = this.createTransport(t)
            , s = !1;
        Xr.priorWebsocketSuccess = !1;
        const o = () => {
                s || (n.send([{
                    type: "ping",
                    data: "probe"
                }]),
                    n.once("packet", y => {
                            if (!s)
                                if (y.type === "pong" && y.data === "probe") {
                                    if (this.upgrading = !0,
                                        this.emitReserved("upgrading", n),
                                        !n)
                                        return;
                                    Xr.priorWebsocketSuccess = n.name === "websocket",
                                        this.transport.pause( () => {
                                                s || this.readyState !== "closed" && (m(),
                                                    this.setTransport(n),
                                                    n.send([{
                                                        type: "upgrade"
                                                    }]),
                                                    this.emitReserved("upgrade", n),
                                                    n = null,
                                                    this.upgrading = !1,
                                                    this.flush())
                                            }
                                        )
                                } else {
                                    const v = new Error("probe error");
                                    v.transport = n.name,
                                        this.emitReserved("upgradeError", v)
                                }
                        }
                    ))
            }
        ;
        function u() {
            s || (s = !0,
                m(),
                n.close(),
                n = null)
        }
        const l = y => {
                const v = new Error("probe error: " + y);
                v.transport = n.name,
                    u(),
                    this.emitReserved("upgradeError", v)
            }
        ;
        function d() {
            l("transport closed")
        }
        function f() {
            l("socket closed")
        }
        function p(y) {
            n && y.name !== n.name && u()
        }
        const m = () => {
                n.removeListener("open", o),
                    n.removeListener("error", l),
                    n.removeListener("close", d),
                    this.off("close", f),
                    this.off("upgrading", p)
            }
        ;
        n.once("open", o),
            n.once("error", l),
            n.once("close", d),
            this.once("close", f),
            this.once("upgrading", p),
            this._upgrades.indexOf("webtransport") !== -1 && t !== "webtransport" ? this.setTimeoutFn( () => {
                    s || n.open()
                }
                , 200) : n.open()
    }
    onHandshake(t) {
        this._upgrades = this._filterUpgrades(t.upgrades),
            super.onHandshake(t)
    }
    _filterUpgrades(t) {
        const n = [];
        for (let s = 0; s < t.length; s++)
            ~this.transports.indexOf(t[s]) && n.push(t[s]);
        return n
    }
}
let cN = class extends uN {
        constructor(t, n={}) {
            const s = typeof t == "object" ? t : n;
            (!s.transports || s.transports && typeof s.transports[0] == "string") && (s.transports = (s.transports || ["polling", "websocket", "webtransport"]).map(o => sN[o]).filter(o => !!o)),
                super(t, s)
        }
    }
;
function dN(e, t="", n) {
    let s = e;
    n = n || typeof location < "u" && location,
    e == null && (e = n.protocol + "//" + n.host),
    typeof e == "string" && (e.charAt(0) === "/" && (e.charAt(1) === "/" ? e = n.protocol + e : e = n.host + e),
    /^(https?|wss?):\/\//.test(e) || (typeof n < "u" ? e = n.protocol + "//" + e : e = "https://" + e),
        s = gh(e)),
    s.port || (/^(http|ws)$/.test(s.protocol) ? s.port = "80" : /^(http|ws)s$/.test(s.protocol) && (s.port = "443")),
        s.path = s.path || "/";
    const u = s.host.indexOf(":") !== -1 ? "[" + s.host + "]" : s.host;
    return s.id = s.protocol + "://" + u + ":" + s.port + t,
        s.href = s.protocol + "://" + u + (n && n.port === s.port ? "" : ":" + s.port),
        s
}
const fN = typeof ArrayBuffer == "function"
    , hN = e => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(e) : e.buffer instanceof ArrayBuffer
    , LS = Object.prototype.toString
    , pN = typeof Blob == "function" || typeof Blob < "u" && LS.call(Blob) === "[object BlobConstructor]"
    , mN = typeof File == "function" || typeof File < "u" && LS.call(File) === "[object FileConstructor]";
function mp(e) {
    return fN && (e instanceof ArrayBuffer || hN(e)) || pN && e instanceof Blob || mN && e instanceof File
}
function xu(e, t) {
    if (!e || typeof e != "object")
        return !1;
    if (Array.isArray(e)) {
        for (let n = 0, s = e.length; n < s; n++)
            if (xu(e[n]))
                return !0;
        return !1
    }
    if (mp(e))
        return !0;
    if (e.toJSON && typeof e.toJSON == "function" && arguments.length === 1)
        return xu(e.toJSON(), !0);
    for (const n in e)
        if (Object.prototype.hasOwnProperty.call(e, n) && xu(e[n]))
            return !0;
    return !1
}
function gN(e) {
    const t = []
        , n = e.data
        , s = e;
    return s.data = vh(n, t),
        s.attachments = t.length,
        {
            packet: s,
            buffers: t
        }
}
function vh(e, t) {
    if (!e)
        return e;
    if (mp(e)) {
        const n = {
            _placeholder: !0,
            num: t.length
        };
        return t.push(e),
            n
    } else if (Array.isArray(e)) {
        const n = new Array(e.length);
        for (let s = 0; s < e.length; s++)
            n[s] = vh(e[s], t);
        return n
    } else if (typeof e == "object" && !(e instanceof Date)) {
        const n = {};
        for (const s in e)
            Object.prototype.hasOwnProperty.call(e, s) && (n[s] = vh(e[s], t));
        return n
    }
    return e
}
function yN(e, t) {
    return e.data = wh(e.data, t),
        delete e.attachments,
        e
}
function wh(e, t) {
    if (!e)
        return e;
    if (e && e._placeholder === !0) {
        if (typeof e.num == "number" && e.num >= 0 && e.num < t.length)
            return t[e.num];
        throw new Error("illegal attachments")
    } else if (Array.isArray(e))
        for (let n = 0; n < e.length; n++)
            e[n] = wh(e[n], t);
    else if (typeof e == "object")
        for (const n in e)
            Object.prototype.hasOwnProperty.call(e, n) && (e[n] = wh(e[n], t));
    return e
}
const vN = ["connect", "connect_error", "disconnect", "disconnecting", "newListener", "removeListener"]
    , wN = 5;
var Me;
(function(e) {
        e[e.CONNECT = 0] = "CONNECT",
            e[e.DISCONNECT = 1] = "DISCONNECT",
            e[e.EVENT = 2] = "EVENT",
            e[e.ACK = 3] = "ACK",
            e[e.CONNECT_ERROR = 4] = "CONNECT_ERROR",
            e[e.BINARY_EVENT = 5] = "BINARY_EVENT",
            e[e.BINARY_ACK = 6] = "BINARY_ACK"
    }
)(Me || (Me = {}));
class xN {
    constructor(t) {
        this.replacer = t
    }
    encode(t) {
        return (t.type === Me.EVENT || t.type === Me.ACK) && xu(t) ? this.encodeAsBinary({
            type: t.type === Me.EVENT ? Me.BINARY_EVENT : Me.BINARY_ACK,
            nsp: t.nsp,
            data: t.data,
            id: t.id
        }) : [this.encodeAsString(t)]
    }
    encodeAsString(t) {
        let n = "" + t.type;
        return (t.type === Me.BINARY_EVENT || t.type === Me.BINARY_ACK) && (n += t.attachments + "-"),
        t.nsp && t.nsp !== "/" && (n += t.nsp + ","),
        t.id != null && (n += t.id),
        t.data != null && (n += JSON.stringify(t.data, this.replacer)),
            n
    }
    encodeAsBinary(t) {
        const n = gN(t)
            , s = this.encodeAsString(n.packet)
            , o = n.buffers;
        return o.unshift(s),
            o
    }
}
function a0(e) {
    return Object.prototype.toString.call(e) === "[object Object]"
}
class gp extends st {
    constructor(t) {
        super(),
            this.reviver = t
    }
    add(t) {
        let n;
        if (typeof t == "string") {
            if (this.reconstructor)
                throw new Error("got plaintext data when reconstructing a packet");
            n = this.decodeString(t);
            const s = n.type === Me.BINARY_EVENT;
            s || n.type === Me.BINARY_ACK ? (n.type = s ? Me.EVENT : Me.ACK,
                this.reconstructor = new SN(n),
            n.attachments === 0 && super.emitReserved("decoded", n)) : super.emitReserved("decoded", n)
        } else if (mp(t) || t.base64)
            if (this.reconstructor)
                n = this.reconstructor.takeBinaryData(t),
                n && (this.reconstructor = null,
                    super.emitReserved("decoded", n));
            else
                throw new Error("got binary data when not reconstructing a packet");
        else
            throw new Error("Unknown type: " + t)
    }
    decodeString(t) {
        let n = 0;
        const s = {
            type: Number(t.charAt(0))
        };
        if (Me[s.type] === void 0)
            throw new Error("unknown packet type " + s.type);
        if (s.type === Me.BINARY_EVENT || s.type === Me.BINARY_ACK) {
            const u = n + 1;
            for (; t.charAt(++n) !== "-" && n != t.length; )
                ;
            const l = t.substring(u, n);
            if (l != Number(l) || t.charAt(n) !== "-")
                throw new Error("Illegal attachments");
            s.attachments = Number(l)
        }
        if (t.charAt(n + 1) === "/") {
            const u = n + 1;
            for (; ++n && !(t.charAt(n) === "," || n === t.length); )
                ;
            s.nsp = t.substring(u, n)
        } else
            s.nsp = "/";
        const o = t.charAt(n + 1);
        if (o !== "" && Number(o) == o) {
            const u = n + 1;
            for (; ++n; ) {
                const l = t.charAt(n);
                if (l == null || Number(l) != l) {
                    --n;
                    break
                }
                if (n === t.length)
                    break
            }
            s.id = Number(t.substring(u, n + 1))
        }
        if (t.charAt(++n)) {
            const u = this.tryParse(t.substr(n));
            if (gp.isPayloadValid(s.type, u))
                s.data = u;
            else
                throw new Error("invalid payload")
        }
        return s
    }
    tryParse(t) {
        try {
            return JSON.parse(t, this.reviver)
        } catch {
            return !1
        }
    }
    static isPayloadValid(t, n) {
        switch (t) {
            case Me.CONNECT:
                return a0(n);
            case Me.DISCONNECT:
                return n === void 0;
            case Me.CONNECT_ERROR:
                return typeof n == "string" || a0(n);
            case Me.EVENT:
            case Me.BINARY_EVENT:
                return Array.isArray(n) && (typeof n[0] == "number" || typeof n[0] == "string" && vN.indexOf(n[0]) === -1);
            case Me.ACK:
            case Me.BINARY_ACK:
                return Array.isArray(n)
        }
    }
    destroy() {
        this.reconstructor && (this.reconstructor.finishedReconstruction(),
            this.reconstructor = null)
    }
}
class SN {
    constructor(t) {
        this.packet = t,
            this.buffers = [],
            this.reconPack = t
    }
    takeBinaryData(t) {
        if (this.buffers.push(t),
        this.buffers.length === this.reconPack.attachments) {
            const n = yN(this.reconPack, this.buffers);
            return this.finishedReconstruction(),
                n
        }
        return null
    }
    finishedReconstruction() {
        this.reconPack = null,
            this.buffers = []
    }
}
const bN = Object.freeze(Object.defineProperty({
    __proto__: null,
    Decoder: gp,
    Encoder: xN,
    get PacketType() {
        return Me
    },
    protocol: wN
}, Symbol.toStringTag, {
    value: "Module"
}));
function Sn(e, t, n) {
    return e.on(t, n),
        function() {
            e.off(t, n)
        }
}
const EN = Object.freeze({
    connect: 1,
    connect_error: 1,
    disconnect: 1,
    disconnecting: 1,
    newListener: 1,
    removeListener: 1
});
class MS extends st {
    constructor(t, n, s) {
        super(),
            this.connected = !1,
            this.recovered = !1,
            this.receiveBuffer = [],
            this.sendBuffer = [],
            this._queue = [],
            this._queueSeq = 0,
            this.ids = 0,
            this.acks = {},
            this.flags = {},
            this.io = t,
            this.nsp = n,
        s && s.auth && (this.auth = s.auth),
            this._opts = Object.assign({}, s),
        this.io._autoConnect && this.open()
    }
    get disconnected() {
        return !this.connected
    }
    subEvents() {
        if (this.subs)
            return;
        const t = this.io;
        this.subs = [Sn(t, "open", this.onopen.bind(this)), Sn(t, "packet", this.onpacket.bind(this)), Sn(t, "error", this.onerror.bind(this)), Sn(t, "close", this.onclose.bind(this))]
    }
    get active() {
        return !!this.subs
    }
    connect() {
        return this.connected ? this : (this.subEvents(),
        this.io._reconnecting || this.io.open(),
        this.io._readyState === "open" && this.onopen(),
            this)
    }
    open() {
        return this.connect()
    }
    send(...t) {
        return t.unshift("message"),
            this.emit.apply(this, t),
            this
    }
    emit(t, ...n) {
        var s, o, u;
        if (EN.hasOwnProperty(t))
            throw new Error('"' + t.toString() + '" is a reserved event name');
        if (n.unshift(t),
        this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)
            return this._addToQueue(n),
                this;
        const l = {
            type: Me.EVENT,
            data: n
        };
        if (l.options = {},
            l.options.compress = this.flags.compress !== !1,
        typeof n[n.length - 1] == "function") {
            const m = this.ids++
                , y = n.pop();
            this._registerAckCallback(m, y),
                l.id = m
        }
        const d = (o = (s = this.io.engine) === null || s === void 0 ? void 0 : s.transport) === null || o === void 0 ? void 0 : o.writable
            , f = this.connected && !(!((u = this.io.engine) === null || u === void 0) && u._hasPingExpired());
        return this.flags.volatile && !d || (f ? (this.notifyOutgoingListeners(l),
            this.packet(l)) : this.sendBuffer.push(l)),
            this.flags = {},
            this
    }
    _registerAckCallback(t, n) {
        var s;
        const o = (s = this.flags.timeout) !== null && s !== void 0 ? s : this._opts.ackTimeout;
        if (o === void 0) {
            this.acks[t] = n;
            return
        }
        const u = this.io.setTimeoutFn( () => {
                    delete this.acks[t];
                    for (let d = 0; d < this.sendBuffer.length; d++)
                        this.sendBuffer[d].id === t && this.sendBuffer.splice(d, 1);
                    n.call(this, new Error("operation has timed out"))
                }
                , o)
            , l = (...d) => {
                this.io.clearTimeoutFn(u),
                    n.apply(this, d)
            }
        ;
        l.withError = !0,
            this.acks[t] = l
    }
    emitWithAck(t, ...n) {
        return new Promise( (s, o) => {
                const u = (l, d) => l ? o(l) : s(d);
                u.withError = !0,
                    n.push(u),
                    this.emit(t, ...n)
            }
        )
    }
    _addToQueue(t) {
        let n;
        typeof t[t.length - 1] == "function" && (n = t.pop());
        const s = {
            id: this._queueSeq++,
            tryCount: 0,
            pending: !1,
            args: t,
            flags: Object.assign({
                fromQueue: !0
            }, this.flags)
        };
        t.push( (o, ...u) => s !== this._queue[0] ? void 0 : (o !== null ? s.tryCount > this._opts.retries && (this._queue.shift(),
        n && n(o)) : (this._queue.shift(),
        n && n(null, ...u)),
            s.pending = !1,
            this._drainQueue())),
            this._queue.push(s),
            this._drainQueue()
    }
    _drainQueue(t=!1) {
        if (!this.connected || this._queue.length === 0)
            return;
        const n = this._queue[0];
        n.pending && !t || (n.pending = !0,
            n.tryCount++,
            this.flags = n.flags,
            this.emit.apply(this, n.args))
    }
    packet(t) {
        t.nsp = this.nsp,
            this.io._packet(t)
    }
    onopen() {
        typeof this.auth == "function" ? this.auth(t => {
                this._sendConnectPacket(t)
            }
        ) : this._sendConnectPacket(this.auth)
    }
    _sendConnectPacket(t) {
        this.packet({
            type: Me.CONNECT,
            data: this._pid ? Object.assign({
                pid: this._pid,
                offset: this._lastOffset
            }, t) : t
        })
    }
    onerror(t) {
        this.connected || this.emitReserved("connect_error", t)
    }
    onclose(t, n) {
        this.connected = !1,
            delete this.id,
            this.emitReserved("disconnect", t, n),
            this._clearAcks()
    }
    _clearAcks() {
        Object.keys(this.acks).forEach(t => {
                if (!this.sendBuffer.some(s => String(s.id) === t)) {
                    const s = this.acks[t];
                    delete this.acks[t],
                    s.withError && s.call(this, new Error("socket has been disconnected"))
                }
            }
        )
    }
    onpacket(t) {
        if (t.nsp === this.nsp)
            switch (t.type) {
                case Me.CONNECT:
                    t.data && t.data.sid ? this.onconnect(t.data.sid, t.data.pid) : this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
                    break;
                case Me.EVENT:
                case Me.BINARY_EVENT:
                    this.onevent(t);
                    break;
                case Me.ACK:
                case Me.BINARY_ACK:
                    this.onack(t);
                    break;
                case Me.DISCONNECT:
                    this.ondisconnect();
                    break;
                case Me.CONNECT_ERROR:
                    this.destroy();
                    const s = new Error(t.data.message);
                    s.data = t.data.data,
                        this.emitReserved("connect_error", s);
                    break
            }
    }
    onevent(t) {
        const n = t.data || [];
        t.id != null && n.push(this.ack(t.id)),
            this.connected ? this.emitEvent(n) : this.receiveBuffer.push(Object.freeze(n))
    }
    emitEvent(t) {
        if (this._anyListeners && this._anyListeners.length) {
            const n = this._anyListeners.slice();
            for (const s of n)
                s.apply(this, t)
        }
        super.emit.apply(this, t),
        this._pid && t.length && typeof t[t.length - 1] == "string" && (this._lastOffset = t[t.length - 1])
    }
    ack(t) {
        const n = this;
        let s = !1;
        return function(...o) {
            s || (s = !0,
                n.packet({
                    type: Me.ACK,
                    id: t,
                    data: o
                }))
        }
    }
    onack(t) {
        const n = this.acks[t.id];
        typeof n == "function" && (delete this.acks[t.id],
        n.withError && t.data.unshift(null),
            n.apply(this, t.data))
    }
    onconnect(t, n) {
        this.id = t,
            this.recovered = n && this._pid === n,
            this._pid = n,
            this.connected = !0,
            this.emitBuffered(),
            this.emitReserved("connect"),
            this._drainQueue(!0)
    }
    emitBuffered() {
        this.receiveBuffer.forEach(t => this.emitEvent(t)),
            this.receiveBuffer = [],
            this.sendBuffer.forEach(t => {
                    this.notifyOutgoingListeners(t),
                        this.packet(t)
                }
            ),
            this.sendBuffer = []
    }
    ondisconnect() {
        this.destroy(),
            this.onclose("io server disconnect")
    }
    destroy() {
        this.subs && (this.subs.forEach(t => t()),
            this.subs = void 0),
            this.io._destroy(this)
    }
    disconnect() {
        return this.connected && this.packet({
            type: Me.DISCONNECT
        }),
            this.destroy(),
        this.connected && this.onclose("io client disconnect"),
            this
    }
    close() {
        return this.disconnect()
    }
    compress(t) {
        return this.flags.compress = t,
            this
    }
    get volatile() {
        return this.flags.volatile = !0,
            this
    }
    timeout(t) {
        return this.flags.timeout = t,
            this
    }
    onAny(t) {
        return this._anyListeners = this._anyListeners || [],
            this._anyListeners.push(t),
            this
    }
    prependAny(t) {
        return this._anyListeners = this._anyListeners || [],
            this._anyListeners.unshift(t),
            this
    }
    offAny(t) {
        if (!this._anyListeners)
            return this;
        if (t) {
            const n = this._anyListeners;
            for (let s = 0; s < n.length; s++)
                if (t === n[s])
                    return n.splice(s, 1),
                        this
        } else
            this._anyListeners = [];
        return this
    }
    listenersAny() {
        return this._anyListeners || []
    }
    onAnyOutgoing(t) {
        return this._anyOutgoingListeners = this._anyOutgoingListeners || [],
            this._anyOutgoingListeners.push(t),
            this
    }
    prependAnyOutgoing(t) {
        return this._anyOutgoingListeners = this._anyOutgoingListeners || [],
            this._anyOutgoingListeners.unshift(t),
            this
    }
    offAnyOutgoing(t) {
        if (!this._anyOutgoingListeners)
            return this;
        if (t) {
            const n = this._anyOutgoingListeners;
            for (let s = 0; s < n.length; s++)
                if (t === n[s])
                    return n.splice(s, 1),
                        this
        } else
            this._anyOutgoingListeners = [];
        return this
    }
    listenersAnyOutgoing() {
        return this._anyOutgoingListeners || []
    }
    notifyOutgoingListeners(t) {
        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
            const n = this._anyOutgoingListeners.slice();
            for (const s of n)
                s.apply(this, t.data)
        }
    }
}
function Zi(e) {
    e = e || {},
        this.ms = e.min || 100,
        this.max = e.max || 1e4,
        this.factor = e.factor || 2,
        this.jitter = e.jitter > 0 && e.jitter <= 1 ? e.jitter : 0,
        this.attempts = 0
}
Zi.prototype.duration = function() {
    var e = this.ms * Math.pow(this.factor, this.attempts++);
    if (this.jitter) {
        var t = Math.random()
            , n = Math.floor(t * this.jitter * e);
        e = (Math.floor(t * 10) & 1) == 0 ? e - n : e + n
    }
    return Math.min(e, this.max) | 0
}
;
Zi.prototype.reset = function() {
    this.attempts = 0
}
;
Zi.prototype.setMin = function(e) {
    this.ms = e
}
;
Zi.prototype.setMax = function(e) {
    this.max = e
}
;
Zi.prototype.setJitter = function(e) {
    this.jitter = e
}
;
class xh extends st {
    constructor(t, n) {
        var s;
        super(),
            this.nsps = {},
            this.subs = [],
        t && typeof t == "object" && (n = t,
            t = void 0),
            n = n || {},
            n.path = n.path || "/socket.io",
            this.opts = n,
            Ju(this, n),
            this.reconnection(n.reconnection !== !1),
            this.reconnectionAttempts(n.reconnectionAttempts || 1 / 0),
            this.reconnectionDelay(n.reconnectionDelay || 1e3),
            this.reconnectionDelayMax(n.reconnectionDelayMax || 5e3),
            this.randomizationFactor((s = n.randomizationFactor) !== null && s !== void 0 ? s : .5),
            this.backoff = new Zi({
                min: this.reconnectionDelay(),
                max: this.reconnectionDelayMax(),
                jitter: this.randomizationFactor()
            }),
            this.timeout(n.timeout == null ? 2e4 : n.timeout),
            this._readyState = "closed",
            this.uri = t;
        const o = n.parser || bN;
        this.encoder = new o.Encoder,
            this.decoder = new o.Decoder,
            this._autoConnect = n.autoConnect !== !1,
        this._autoConnect && this.open()
    }
    reconnection(t) {
        return arguments.length ? (this._reconnection = !!t,
        t || (this.skipReconnect = !0),
            this) : this._reconnection
    }
    reconnectionAttempts(t) {
        return t === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = t,
            this)
    }
    reconnectionDelay(t) {
        var n;
        return t === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = t,
        (n = this.backoff) === null || n === void 0 || n.setMin(t),
            this)
    }
    randomizationFactor(t) {
        var n;
        return t === void 0 ? this._randomizationFactor : (this._randomizationFactor = t,
        (n = this.backoff) === null || n === void 0 || n.setJitter(t),
            this)
    }
    reconnectionDelayMax(t) {
        var n;
        return t === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = t,
        (n = this.backoff) === null || n === void 0 || n.setMax(t),
            this)
    }
    timeout(t) {
        return arguments.length ? (this._timeout = t,
            this) : this._timeout
    }
    maybeReconnectOnOpen() {
        !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect()
    }
    open(t) {
        if (~this._readyState.indexOf("open"))
            return this;
        this.engine = new cN(this.uri,this.opts);
        const n = this.engine
            , s = this;
        this._readyState = "opening",
            this.skipReconnect = !1;
        const o = Sn(n, "open", function() {
            s.onopen(),
            t && t()
        })
            , u = d => {
            this.cleanup(),
                this._readyState = "closed",
                this.emitReserved("error", d),
                t ? t(d) : this.maybeReconnectOnOpen()
        }
            , l = Sn(n, "error", u);
        if (this._timeout !== !1) {
            const d = this._timeout
                , f = this.setTimeoutFn( () => {
                    o(),
                        u(new Error("timeout")),
                        n.close()
                }
                , d);
            this.opts.autoUnref && f.unref(),
                this.subs.push( () => {
                        this.clearTimeoutFn(f)
                    }
                )
        }
        return this.subs.push(o),
            this.subs.push(l),
            this
    }
    connect(t) {
        return this.open(t)
    }
    onopen() {
        this.cleanup(),
            this._readyState = "open",
            this.emitReserved("open");
        const t = this.engine;
        this.subs.push(Sn(t, "ping", this.onping.bind(this)), Sn(t, "data", this.ondata.bind(this)), Sn(t, "error", this.onerror.bind(this)), Sn(t, "close", this.onclose.bind(this)), Sn(this.decoder, "decoded", this.ondecoded.bind(this)))
    }
    onping() {
        this.emitReserved("ping")
    }
    ondata(t) {
        try {
            this.decoder.add(t)
        } catch (n) {
            this.onclose("parse error", n)
        }
    }
    ondecoded(t) {
        Yu( () => {
                this.emitReserved("packet", t)
            }
            , this.setTimeoutFn)
    }
    onerror(t) {
        this.emitReserved("error", t)
    }
    socket(t, n) {
        let s = this.nsps[t];
        return s ? this._autoConnect && !s.active && s.connect() : (s = new MS(this,t,n),
            this.nsps[t] = s),
            s
    }
    _destroy(t) {
        const n = Object.keys(this.nsps);
        for (const s of n)
            if (this.nsps[s].active)
                return;
        this._close()
    }
    _packet(t) {
        const n = this.encoder.encode(t);
        for (let s = 0; s < n.length; s++)
            this.engine.write(n[s], t.options)
    }
    cleanup() {
        this.subs.forEach(t => t()),
            this.subs.length = 0,
            this.decoder.destroy()
    }
    _close() {
        this.skipReconnect = !0,
            this._reconnecting = !1,
            this.onclose("forced close")
    }
    disconnect() {
        return this._close()
    }
    onclose(t, n) {
        var s;
        this.cleanup(),
        (s = this.engine) === null || s === void 0 || s.close(),
            this.backoff.reset(),
            this._readyState = "closed",
            this.emitReserved("close", t, n),
        this._reconnection && !this.skipReconnect && this.reconnect()
    }
    reconnect() {
        if (this._reconnecting || this.skipReconnect)
            return this;
        const t = this;
        if (this.backoff.attempts >= this._reconnectionAttempts)
            this.backoff.reset(),
                this.emitReserved("reconnect_failed"),
                this._reconnecting = !1;
        else {
            const n = this.backoff.duration();
            this._reconnecting = !0;
            const s = this.setTimeoutFn( () => {
                    t.skipReconnect || (this.emitReserved("reconnect_attempt", t.backoff.attempts),
                    !t.skipReconnect && t.open(o => {
                            o ? (t._reconnecting = !1,
                                t.reconnect(),
                                this.emitReserved("reconnect_error", o)) : t.onreconnect()
                        }
                    ))
                }
                , n);
            this.opts.autoUnref && s.unref(),
                this.subs.push( () => {
                        this.clearTimeoutFn(s)
                    }
                )
        }
    }
    onreconnect() {
        const t = this.backoff.attempts;
        this._reconnecting = !1,
            this.backoff.reset(),
            this.emitReserved("reconnect", t)
    }
}
const Ko = {};
function Su(e, t) {
    typeof e == "object" && (t = e,
        e = void 0),
        t = t || {};
    const n = dN(e, t.path || "/socket.io")
        , s = n.source
        , o = n.id
        , u = n.path
        , l = Ko[o] && u in Ko[o].nsps
        , d = t.forceNew || t["force new connection"] || t.multiplex === !1 || l;
    let f;
    return d ? f = new xh(s,t) : (Ko[o] || (Ko[o] = new xh(s,t)),
        f = Ko[o]),
    n.query && !t.query && (t.query = n.queryKey),
        f.socket(n.path, t)
}
Object.assign(Su, {
    Manager: xh,
    Socket: MS,
    io: Su,
    connect: Su
});
function l0(e, t) {
    var n;
    const s = Su(e.serverUrl, {
        path: e.mountPath,
        transports: e.transports,
        query: {
            app_id: e.appId,
            token: (n = e.token) !== null && n !== void 0 ? n : dp()
        }
    });
    return s.on("connect", async () => {
            var o;
            return console.log("connect", s.id),
                (o = t.connect) === null || o === void 0 ? void 0 : o.call(t)
        }
    ),
        s.on("update_model", async o => {
                var u;
                return (u = t.update_model) === null || u === void 0 ? void 0 : u.call(t, o)
            }
        ),
        s.on("error", async o => {
                var u;
                return (u = t.error) === null || u === void 0 ? void 0 : u.call(t, o)
            }
        ),
        s.on("connect_error", async o => {
                var u;
                return console.error("connect_error", o),
                    (u = t.error) === null || u === void 0 ? void 0 : u.call(t, o)
            }
        ),
        s
}
function CN({config: e}) {
    let t = {
        ...e
    };
    const n = {}
        , s = {
        connect: async () => {
            const S = [];
            Object.keys(n).forEach(E => {
                    f(E);
                    const w = y(E);
                    w == null || w.forEach( ({connect: x}) => {
                            const T = async () => x == null ? void 0 : x();
                            S.push(T())
                        }
                    )
                }
            ),
                await Promise.all(S)
        }
        ,
        update_model: async S => {
            const w = y(S.room).map(x => {
                    var T;
                    return (T = x.update_model) === null || T === void 0 ? void 0 : T.call(x, S)
                }
            );
            await Promise.all(w)
        }
        ,
        error: async S => {
            console.error("error", S);
            const E = Object.values(n).flat().map(w => {
                    var x;
                    return (x = w.error) === null || x === void 0 ? void 0 : x.call(w, S)
                }
            );
            await Promise.all(E)
        }
    };
    let o = l0(e, s);
    function u() {
        l()
    }
    function l() {
        o && o.disconnect()
    }
    function d(S) {
        u(),
            t = {
                ...t,
                ...S
            },
            o = l0(t, s)
    }
    function f(S) {
        o.emit("join", S)
    }
    function p(S) {
        o.emit("leave", S)
    }
    async function m(S, E) {
        var w;
        const x = JSON.stringify(E);
        return (w = s.update_model) === null || w === void 0 ? void 0 : w.call(s, {
            room: S,
            data: x
        })
    }
    function y(S) {
        return n[S]
    }
    return {
        socket: o,
        subscribeToRoom: (S, E) => (n[S] || (f(S),
                n[S] = []),
                n[S].push(E),
                () => {
                    var w, x;
                    n[S] = (x = (w = n[S]) === null || w === void 0 ? void 0 : w.filter(T => T !== E)) !== null && x !== void 0 ? x : [],
                    n[S].length === 0 && p(S)
                }
        ),
        updateConfig: d,
        updateModel: m,
        disconnect: l
    }
}
function PN(e) {
    const {serverUrl: t="https://base44.app", appId: n, token: s, serviceToken: o, requiresAuth: u=!1, appBaseUrl: l, options: d, functionsVersion: f, headers: p} = e
        , y = CN({
        config: {
            serverUrl: t,
            mountPath: "/ws-user-apps/socket.io/",
            transports: ["websocket"],
            appId: n,
            token: s
        }
    })
        , v = {
        ...p,
        "X-App-Id": String(n)
    }
        , S = f ? {
        ...v,
        "Base44-Functions-Version": f
    } : v
        , E = Xo({
        baseURL: `${t}/api`,
        headers: v,
        token: s,
        onError: d == null ? void 0 : d.onError
    })
        , w = Xo({
        baseURL: `${t}/api`,
        headers: S,
        token: s,
        interceptResponses: !1,
        onError: d == null ? void 0 : d.onError
    })
        , x = Xo({
        baseURL: `${t}/api`,
        headers: v,
        token: o,
        onError: d == null ? void 0 : d.onError
    })
        , T = Xo({
        baseURL: `${t}/api`,
        headers: S,
        token: o,
        interceptResponses: !1
    })
        , k = {
        entities: Jv(E, n),
        integrations: Zv(E, n),
        auth: k_(E, w, n, {
            appBaseUrl: l
        }),
        functions: e0(w, n),
        agents: t0({
            axios: E,
            socket: y,
            appId: n,
            serverUrl: t,
            token: s
        }),
        appLogs: n0(E, n),
        cleanup: () => {
            y.disconnect()
        }
    }
        , R = {
        entities: Jv(x, n),
        integrations: Zv(x, n),
        sso: R_(x, n, s),
        connectors: A_(x, n),
        functions: e0(T, n),
        agents: t0({
            axios: x,
            socket: y,
            appId: n,
            serverUrl: t,
            token: s
        }),
        appLogs: n0(x, n),
        cleanup: () => {
            y.disconnect()
        }
    };
    if (typeof window < "u") {
        const D = s || dp();
        D && k.auth.setToken(D)
    }
    return u && typeof window < "u" && setTimeout(async () => {
            try {
                await k.auth.isAuthenticated() || k.auth.redirectToLogin(window.location.href)
            } catch (D) {
                console.error("Authentication check failed:", D),
                    k.auth.redirectToLogin(window.location.href)
            }
        }
        , 0),
        {
            ...k,
            setToken(D) {
                k.auth.setToken(D),
                    y.updateConfig({
                        token: D
                    })
            },
            getConfig() {
                return {
                    serverUrl: t,
                    appId: n,
                    requiresAuth: u
                }
            },
            get asServiceRole() {
                if (!o)
                    throw new Error("Service token is required to use asServiceRole. Please provide a serviceToken when creating the client.");
                return R
            }
        }
}
const jS = typeof window > "u"
    , TN = jS ? {
        localStorage: new Map
    } : window
    , ra = TN.localStorage
    , kN = e => e.replace(/([A-Z])/g, "_$1").toLowerCase()
    , gi = (e, {defaultValue: t=void 0, removeFromUrl: n=!1}={}) => {
        if (jS)
            return t;
        const s = `base44_${kN(e)}`
            , o = new URLSearchParams(window.location.search)
            , u = o.get(e);
        if (n) {
            o.delete(e);
            const d = `${window.location.pathname}${o.toString() ? `?${o.toString()}` : ""}${window.location.hash}`;
            window.history.replaceState({}, document.title, d)
        }
        if (u)
            return ra.setItem(s, u),
                u;
        if (t)
            return ra.setItem(s, t),
                t;
        const l = ra.getItem(s);
        return l || null
    }
    , RN = () => (gi("clear_access_token") === "true" && (ra.removeItem("base44_access_token"),
        ra.removeItem("token")),
        {
            appId: gi("app_id", {
                defaultValue: "69355685b7ba1c4a22697f76"
            }),
            serverUrl: gi("server_url", {
                defaultValue: "https://base44.app"
            }),
            token: gi("access_token", {
                removeFromUrl: !0
            }),
            fromUrl: gi("from_url", {
                defaultValue: window.location.href
            }),
            functionsVersion: gi("functions_version")
        })
    , xi = {
        ...RN()
    }
    , {appId: AN, serverUrl: _N, token: NN, functionsVersion: ON} = xi
    , Kr = PN({
        appId: AN,
        serverUrl: _N,
        token: NN,
        functionsVersion: ON,
        requiresAuth: !1
    })
    , DS = P.createContext()
    , LN = ({children: e}) => {
        const [t,n] = P.useState(null)
            , [s,o] = P.useState(!1)
            , [u,l] = P.useState(!0)
            , [d,f] = P.useState(!0)
            , [p,m] = P.useState(null)
            , [y,v] = P.useState(null);
        P.useEffect( () => {
                S()
            }
            , []);
        const S = async () => {
                var T, k;
                try {
                    f(!0),
                        m(null);
                    const R = Xo({
                        baseURL: `${xi.serverUrl}/api/apps/public`,
                        headers: {
                            "X-App-Id": xi.appId
                        },
                        token: xi.token,
                        interceptResponses: !0
                    });
                    try {
                        const _ = await R.get(`/prod/public-settings/by-id/${xi.appId}`);
                        v(_),
                            xi.token ? await E() : (l(!1),
                                o(!1)),
                            f(!1)
                    } catch (_) {
                        if (console.error("App state check failed:", _),
                        _.status === 403 && ((k = (T = _.data) == null ? void 0 : T.extra_data) != null && k.reason)) {
                            const D = _.data.extra_data.reason;
                            m(D === "auth_required" ? {
                                type: "auth_required",
                                message: "Authentication required"
                            } : D === "user_not_registered" ? {
                                type: "user_not_registered",
                                message: "User not registered for this app"
                            } : {
                                type: D,
                                message: _.message
                            })
                        } else
                            m({
                                type: "unknown",
                                message: _.message || "Failed to load app"
                            });
                        f(!1),
                            l(!1)
                    }
                } catch (R) {
                    console.error("Unexpected error:", R),
                        m({
                            type: "unknown",
                            message: R.message || "An unexpected error occurred"
                        }),
                        f(!1),
                        l(!1)
                }
            }
            , E = async () => {
                try {
                    l(!0);
                    const T = await Kr.auth.me();
                    n(T),
                        o(!0),
                        l(!1)
                } catch (T) {
                    console.error("User auth check failed:", T),
                        l(!1),
                        o(!1),
                    (T.status === 401 || T.status === 403) && m({
                        type: "auth_required",
                        message: "Authentication required"
                    })
                }
            }
            , w = (T=!0) => {
                n(null),
                    o(!1),
                    T ? Kr.auth.logout(window.location.href) : Kr.auth.logout()
            }
            , x = () => {
                Kr.auth.redirectToLogin(window.location.href)
            }
        ;
        return b.jsx(DS.Provider, {
            value: {
                user: t,
                isAuthenticated: s,
                isLoadingAuth: u,
                isLoadingPublicSettings: d,
                authError: p,
                appPublicSettings: y,
                logout: w,
                navigateToLogin: x,
                checkAppState: S
            },
            children: e
        })
    }
    , IS = () => {
        const e = P.useContext(DS);
        if (!e)
            throw new Error("useAuth must be used within an AuthProvider");
        return e
    }
;
function u0(e, [t,n]) {
    return Math.min(n, Math.max(t, e))
}
function rt(e, t, {checkForDefaultPrevented: n=!0}={}) {
    return function(o) {
        if (e == null || e(o),
        n === !1 || !o.defaultPrevented)
            return t == null ? void 0 : t(o)
    }
}
function yp(e, t=[]) {
    let n = [];
    function s(u, l) {
        const d = P.createContext(l)
            , f = n.length;
        n = [...n, l];
        const p = y => {
                var T;
                const {scope: v, children: S, ...E} = y
                    , w = ((T = v == null ? void 0 : v[e]) == null ? void 0 : T[f]) || d
                    , x = P.useMemo( () => E, Object.values(E));
                return b.jsx(w.Provider, {
                    value: x,
                    children: S
                })
            }
        ;
        p.displayName = u + "Provider";
        function m(y, v) {
            var w;
            const S = ((w = v == null ? void 0 : v[e]) == null ? void 0 : w[f]) || d
                , E = P.useContext(S);
            if (E)
                return E;
            if (l !== void 0)
                return l;
            throw new Error(`\`${y}\` must be used within \`${u}\``)
        }
        return [p, m]
    }
    const o = () => {
            const u = n.map(l => P.createContext(l));
            return function(d) {
                const f = (d == null ? void 0 : d[e]) || u;
                return P.useMemo( () => ({
                    [`__scope${e}`]: {
                        ...d,
                        [e]: f
                    }
                }), [d, f])
            }
        }
    ;
    return o.scopeName = e,
        [s, MN(o, ...t)]
}
function MN(...e) {
    const t = e[0];
    if (e.length === 1)
        return t;
    const n = () => {
            const s = e.map(o => ({
                useScope: o(),
                scopeName: o.scopeName
            }));
            return function(u) {
                const l = s.reduce( (d, {useScope: f, scopeName: p}) => {
                        const y = f(u)[`__scope${p}`];
                        return {
                            ...d,
                            ...y
                        }
                    }
                    , {});
                return P.useMemo( () => ({
                    [`__scope${t.scopeName}`]: l
                }), [l])
            }
        }
    ;
    return n.scopeName = t.scopeName,
        n
}
function c0(e, t) {
    if (typeof e == "function")
        return e(t);
    e != null && (e.current = t)
}
function FS(...e) {
    return t => {
        let n = !1;
        const s = e.map(o => {
                const u = c0(o, t);
                return !n && typeof u == "function" && (n = !0),
                    u
            }
        );
        if (n)
            return () => {
                for (let o = 0; o < s.length; o++) {
                    const u = s[o];
                    typeof u == "function" ? u() : c0(e[o], null)
                }
            }
    }
}
function wt(...e) {
    return P.useCallback(FS(...e), e)
}
function ma(e) {
    const t = DN(e)
        , n = P.forwardRef( (s, o) => {
            const {children: u, ...l} = s
                , d = P.Children.toArray(u)
                , f = d.find(FN);
            if (f) {
                const p = f.props.children
                    , m = d.map(y => y === f ? P.Children.count(p) > 1 ? P.Children.only(null) : P.isValidElement(p) ? p.props.children : null : y);
                return b.jsx(t, {
                    ...l,
                    ref: o,
                    children: P.isValidElement(p) ? P.cloneElement(p, void 0, m) : null
                })
            }
            return b.jsx(t, {
                ...l,
                ref: o,
                children: u
            })
        }
    );
    return n.displayName = `${e}.Slot`,
        n
}
var jN = ma("Slot");
function DN(e) {
    const t = P.forwardRef( (n, s) => {
            const {children: o, ...u} = n;
            if (P.isValidElement(o)) {
                const l = VN(o)
                    , d = BN(u, o.props);
                return o.type !== P.Fragment && (d.ref = s ? FS(s, l) : l),
                    P.cloneElement(o, d)
            }
            return P.Children.count(o) > 1 ? P.Children.only(null) : null
        }
    );
    return t.displayName = `${e}.SlotClone`,
        t
}
var IN = Symbol("radix.slottable");
function FN(e) {
    return P.isValidElement(e) && typeof e.type == "function" && "__radixId"in e.type && e.type.__radixId === IN
}
function BN(e, t) {
    const n = {
        ...t
    };
    for (const s in t) {
        const o = e[s]
            , u = t[s];
        /^on[A-Z]/.test(s) ? o && u ? n[s] = (...d) => {
                const f = u(...d);
                return o(...d),
                    f
            }
            : o && (n[s] = o) : s === "style" ? n[s] = {
            ...o,
            ...u
        } : s === "className" && (n[s] = [o, u].filter(Boolean).join(" "))
    }
    return {
        ...e,
        ...n
    }
}
function VN(e) {
    var s, o;
    let t = (s = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : s.get
        , n = t && "isReactWarning"in t && t.isReactWarning;
    return n ? e.ref : (t = (o = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : o.get,
        n = t && "isReactWarning"in t && t.isReactWarning,
        n ? e.props.ref : e.props.ref || e.ref)
}
function UN(e) {
    const t = e + "CollectionProvider"
        , [n,s] = yp(t)
        , [o,u] = n(t, {
            collectionRef: {
                current: null
            },
            itemMap: new Map
        })
        , l = w => {
            const {scope: x, children: T} = w
                , k = Lr.useRef(null)
                , R = Lr.useRef(new Map).current;
            return b.jsx(o, {
                scope: x,
                itemMap: R,
                collectionRef: k,
                children: T
            })
        }
    ;
    l.displayName = t;
    const d = e + "CollectionSlot"
        , f = ma(d)
        , p = Lr.forwardRef( (w, x) => {
            const {scope: T, children: k} = w
                , R = u(d, T)
                , _ = wt(x, R.collectionRef);
            return b.jsx(f, {
                ref: _,
                children: k
            })
        }
    );
    p.displayName = d;
    const m = e + "CollectionItemSlot"
        , y = "data-radix-collection-item"
        , v = ma(m)
        , S = Lr.forwardRef( (w, x) => {
            const {scope: T, children: k, ...R} = w
                , _ = Lr.useRef(null)
                , D = wt(x, _)
                , H = u(m, T);
            return Lr.useEffect( () => (H.itemMap.set(_, {
                ref: _,
                ...R
            }),
                () => void H.itemMap.delete(_))),
                b.jsx(v, {
                    [y]: "",
                    ref: D,
                    children: k
                })
        }
    );
    S.displayName = m;
    function E(w) {
        const x = u(e + "CollectionConsumer", w);
        return Lr.useCallback( () => {
                const k = x.collectionRef.current;
                if (!k)
                    return [];
                const R = Array.from(k.querySelectorAll(`[${y}]`));
                return Array.from(x.itemMap.values()).sort( (H, $) => R.indexOf(H.ref.current) - R.indexOf($.ref.current))
            }
            , [x.collectionRef, x.itemMap])
    }
    return [{
        Provider: l,
        Slot: p,
        ItemSlot: S
    }, E, s]
}
var zN = P.createContext(void 0);
function $N(e) {
    const t = P.useContext(zN);
    return e || t || "ltr"
}
var WN = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "select", "span", "svg", "ul"]
    , tt = WN.reduce( (e, t) => {
        const n = ma(`Primitive.${t}`)
            , s = P.forwardRef( (o, u) => {
                const {asChild: l, ...d} = o
                    , f = l ? n : t;
                return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0),
                    b.jsx(f, {
                        ...d,
                        ref: u
                    })
            }
        );
        return s.displayName = `Primitive.${t}`,
            {
                ...e,
                [t]: s
            }
    }
    , {});
function HN(e, t) {
    e && Aa.flushSync( () => e.dispatchEvent(t))
}
function Is(e) {
    const t = P.useRef(e);
    return P.useEffect( () => {
            t.current = e
        }
    ),
        P.useMemo( () => (...n) => {
                var s;
                return (s = t.current) == null ? void 0 : s.call(t, ...n)
            }
            , [])
}
function qN(e, t=globalThis == null ? void 0 : globalThis.document) {
    const n = Is(e);
    P.useEffect( () => {
            const s = o => {
                    o.key === "Escape" && n(o)
                }
            ;
            return t.addEventListener("keydown", s, {
                capture: !0
            }),
                () => t.removeEventListener("keydown", s, {
                    capture: !0
                })
        }
        , [n, t])
}
var KN = "DismissableLayer", Sh = "dismissableLayer.update", QN = "dismissableLayer.pointerDownOutside", GN = "dismissableLayer.focusOutside", d0, BS = P.createContext({
    layers: new Set,
    layersWithOutsidePointerEventsDisabled: new Set,
    branches: new Set
}), VS = P.forwardRef( (e, t) => {
        const {disableOutsidePointerEvents: n=!1, onEscapeKeyDown: s, onPointerDownOutside: o, onFocusOutside: u, onInteractOutside: l, onDismiss: d, ...f} = e
            , p = P.useContext(BS)
            , [m,y] = P.useState(null)
            , v = (m == null ? void 0 : m.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document)
            , [,S] = P.useState({})
            , E = wt(t, $ => y($))
            , w = Array.from(p.layers)
            , [x] = [...p.layersWithOutsidePointerEventsDisabled].slice(-1)
            , T = w.indexOf(x)
            , k = m ? w.indexOf(m) : -1
            , R = p.layersWithOutsidePointerEventsDisabled.size > 0
            , _ = k >= T
            , D = JN($ => {
                const O = $.target
                    , W = [...p.branches].some(q => q.contains(O));
                !_ || W || (o == null || o($),
                l == null || l($),
                $.defaultPrevented || d == null || d())
            }
            , v)
            , H = ZN($ => {
                const O = $.target;
                [...p.branches].some(q => q.contains(O)) || (u == null || u($),
                l == null || l($),
                $.defaultPrevented || d == null || d())
            }
            , v);
        return qN($ => {
                k === p.layers.size - 1 && (s == null || s($),
                !$.defaultPrevented && d && ($.preventDefault(),
                    d()))
            }
            , v),
            P.useEffect( () => {
                    if (m)
                        return n && (p.layersWithOutsidePointerEventsDisabled.size === 0 && (d0 = v.body.style.pointerEvents,
                            v.body.style.pointerEvents = "none"),
                            p.layersWithOutsidePointerEventsDisabled.add(m)),
                            p.layers.add(m),
                            f0(),
                            () => {
                                n && p.layersWithOutsidePointerEventsDisabled.size === 1 && (v.body.style.pointerEvents = d0)
                            }
                }
                , [m, v, n, p]),
            P.useEffect( () => () => {
                    m && (p.layers.delete(m),
                        p.layersWithOutsidePointerEventsDisabled.delete(m),
                        f0())
                }
                , [m, p]),
            P.useEffect( () => {
                    const $ = () => S({});
                    return document.addEventListener(Sh, $),
                        () => document.removeEventListener(Sh, $)
                }
                , []),
            b.jsx(tt.div, {
                ...f,
                ref: E,
                style: {
                    pointerEvents: R ? _ ? "auto" : "none" : void 0,
                    ...e.style
                },
                onFocusCapture: rt(e.onFocusCapture, H.onFocusCapture),
                onBlurCapture: rt(e.onBlurCapture, H.onBlurCapture),
                onPointerDownCapture: rt(e.onPointerDownCapture, D.onPointerDownCapture)
            })
    }
);
VS.displayName = KN;
var XN = "DismissableLayerBranch"
    , YN = P.forwardRef( (e, t) => {
        const n = P.useContext(BS)
            , s = P.useRef(null)
            , o = wt(t, s);
        return P.useEffect( () => {
                const u = s.current;
                if (u)
                    return n.branches.add(u),
                        () => {
                            n.branches.delete(u)
                        }
            }
            , [n.branches]),
            b.jsx(tt.div, {
                ...e,
                ref: o
            })
    }
);
YN.displayName = XN;
function JN(e, t=globalThis == null ? void 0 : globalThis.document) {
    const n = Is(e)
        , s = P.useRef(!1)
        , o = P.useRef( () => {}
    );
    return P.useEffect( () => {
            const u = d => {
                if (d.target && !s.current) {
                    let f = function() {
                        US(QN, n, p, {
                            discrete: !0
                        })
                    };
                    const p = {
                        originalEvent: d
                    };
                    d.pointerType === "touch" ? (t.removeEventListener("click", o.current),
                        o.current = f,
                        t.addEventListener("click", o.current, {
                            once: !0
                        })) : f()
                } else
                    t.removeEventListener("click", o.current);
                s.current = !1
            }
                , l = window.setTimeout( () => {
                    t.addEventListener("pointerdown", u)
                }
                , 0);
            return () => {
                window.clearTimeout(l),
                    t.removeEventListener("pointerdown", u),
                    t.removeEventListener("click", o.current)
            }
        }
        , [t, n]),
        {
            onPointerDownCapture: () => s.current = !0
        }
}
function ZN(e, t=globalThis == null ? void 0 : globalThis.document) {
    const n = Is(e)
        , s = P.useRef(!1);
    return P.useEffect( () => {
            const o = u => {
                    u.target && !s.current && US(GN, n, {
                        originalEvent: u
                    }, {
                        discrete: !1
                    })
                }
            ;
            return t.addEventListener("focusin", o),
                () => t.removeEventListener("focusin", o)
        }
        , [t, n]),
        {
            onFocusCapture: () => s.current = !0,
            onBlurCapture: () => s.current = !1
        }
}
function f0() {
    const e = new CustomEvent(Sh);
    document.dispatchEvent(e)
}
function US(e, t, n, {discrete: s}) {
    const o = n.originalEvent.target
        , u = new CustomEvent(e,{
        bubbles: !1,
        cancelable: !0,
        detail: n
    });
    t && o.addEventListener(e, t, {
        once: !0
    }),
        s ? HN(o, u) : o.dispatchEvent(u)
}
var bf = 0;
function eO() {
    P.useEffect( () => {
            const e = document.querySelectorAll("[data-radix-focus-guard]");
            return document.body.insertAdjacentElement("afterbegin", e[0] ?? h0()),
                document.body.insertAdjacentElement("beforeend", e[1] ?? h0()),
                bf++,
                () => {
                    bf === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach(t => t.remove()),
                        bf--
                }
        }
        , [])
}
function h0() {
    const e = document.createElement("span");
    return e.setAttribute("data-radix-focus-guard", ""),
        e.tabIndex = 0,
        e.style.outline = "none",
        e.style.opacity = "0",
        e.style.position = "fixed",
        e.style.pointerEvents = "none",
        e
}
var Ef = "focusScope.autoFocusOnMount"
    , Cf = "focusScope.autoFocusOnUnmount"
    , p0 = {
    bubbles: !1,
    cancelable: !0
}
    , tO = "FocusScope"
    , zS = P.forwardRef( (e, t) => {
        const {loop: n=!1, trapped: s=!1, onMountAutoFocus: o, onUnmountAutoFocus: u, ...l} = e
            , [d,f] = P.useState(null)
            , p = Is(o)
            , m = Is(u)
            , y = P.useRef(null)
            , v = wt(t, w => f(w))
            , S = P.useRef({
            paused: !1,
            pause() {
                this.paused = !0
            },
            resume() {
                this.paused = !1
            }
        }).current;
        P.useEffect( () => {
                if (s) {
                    let w = function(R) {
                        if (S.paused || !d)
                            return;
                        const _ = R.target;
                        d.contains(_) ? y.current = _ : jr(y.current, {
                            select: !0
                        })
                    }
                        , x = function(R) {
                        if (S.paused || !d)
                            return;
                        const _ = R.relatedTarget;
                        _ !== null && (d.contains(_) || jr(y.current, {
                            select: !0
                        }))
                    }
                        , T = function(R) {
                        if (document.activeElement === document.body)
                            for (const D of R)
                                D.removedNodes.length > 0 && jr(d)
                    };
                    document.addEventListener("focusin", w),
                        document.addEventListener("focusout", x);
                    const k = new MutationObserver(T);
                    return d && k.observe(d, {
                        childList: !0,
                        subtree: !0
                    }),
                        () => {
                            document.removeEventListener("focusin", w),
                                document.removeEventListener("focusout", x),
                                k.disconnect()
                        }
                }
            }
            , [s, d, S.paused]),
            P.useEffect( () => {
                    if (d) {
                        g0.add(S);
                        const w = document.activeElement;
                        if (!d.contains(w)) {
                            const T = new CustomEvent(Ef,p0);
                            d.addEventListener(Ef, p),
                                d.dispatchEvent(T),
                            T.defaultPrevented || (nO(aO($S(d)), {
                                select: !0
                            }),
                            document.activeElement === w && jr(d))
                        }
                        return () => {
                            d.removeEventListener(Ef, p),
                                setTimeout( () => {
                                        const T = new CustomEvent(Cf,p0);
                                        d.addEventListener(Cf, m),
                                            d.dispatchEvent(T),
                                        T.defaultPrevented || jr(w ?? document.body, {
                                            select: !0
                                        }),
                                            d.removeEventListener(Cf, m),
                                            g0.remove(S)
                                    }
                                    , 0)
                        }
                    }
                }
                , [d, p, m, S]);
        const E = P.useCallback(w => {
                if (!n && !s || S.paused)
                    return;
                const x = w.key === "Tab" && !w.altKey && !w.ctrlKey && !w.metaKey
                    , T = document.activeElement;
                if (x && T) {
                    const k = w.currentTarget
                        , [R,_] = rO(k);
                    R && _ ? !w.shiftKey && T === _ ? (w.preventDefault(),
                    n && jr(R, {
                        select: !0
                    })) : w.shiftKey && T === R && (w.preventDefault(),
                    n && jr(_, {
                        select: !0
                    })) : T === k && w.preventDefault()
                }
            }
            , [n, s, S.paused]);
        return b.jsx(tt.div, {
            tabIndex: -1,
            ...l,
            ref: v,
            onKeyDown: E
        })
    }
);
zS.displayName = tO;
function nO(e, {select: t=!1}={}) {
    const n = document.activeElement;
    for (const s of e)
        if (jr(s, {
            select: t
        }),
        document.activeElement !== n)
            return
}
function rO(e) {
    const t = $S(e)
        , n = m0(t, e)
        , s = m0(t.reverse(), e);
    return [n, s]
}
function $S(e) {
    const t = []
        , n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
        acceptNode: s => {
            const o = s.tagName === "INPUT" && s.type === "hidden";
            return s.disabled || s.hidden || o ? NodeFilter.FILTER_SKIP : s.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
        }
    });
    for (; n.nextNode(); )
        t.push(n.currentNode);
    return t
}
function m0(e, t) {
    for (const n of e)
        if (!sO(n, {
            upTo: t
        }))
            return n
}
function sO(e, {upTo: t}) {
    if (getComputedStyle(e).visibility === "hidden")
        return !0;
    for (; e; ) {
        if (t !== void 0 && e === t)
            return !1;
        if (getComputedStyle(e).display === "none")
            return !0;
        e = e.parentElement
    }
    return !1
}
function iO(e) {
    return e instanceof HTMLInputElement && "select"in e
}
function jr(e, {select: t=!1}={}) {
    if (e && e.focus) {
        const n = document.activeElement;
        e.focus({
            preventScroll: !0
        }),
        e !== n && iO(e) && t && e.select()
    }
}
var g0 = oO();
function oO() {
    let e = [];
    return {
        add(t) {
            const n = e[0];
            t !== n && (n == null || n.pause()),
                e = y0(e, t),
                e.unshift(t)
        },
        remove(t) {
            var n;
            e = y0(e, t),
            (n = e[0]) == null || n.resume()
        }
    }
}
function y0(e, t) {
    const n = [...e]
        , s = n.indexOf(t);
    return s !== -1 && n.splice(s, 1),
        n
}
function aO(e) {
    return e.filter(t => t.tagName !== "A")
}
var zt = globalThis != null && globalThis.document ? P.useLayoutEffect : () => {}
    , lO = Jh[" useId ".trim().toString()] || ( () => {}
)
    , uO = 0;
function vp(e) {
    const [t,n] = P.useState(lO());
    return zt( () => {
            n(s => s ?? String(uO++))
        }
        , [e]),
        t ? `radix-${t}` : ""
}
const cO = ["top", "right", "bottom", "left"]
    , Yr = Math.min
    , Kt = Math.max
    , Lu = Math.round
    , su = Math.floor
    , Bn = e => ({
    x: e,
    y: e
})
    , dO = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
}
    , fO = {
    start: "end",
    end: "start"
};
function bh(e, t, n) {
    return Kt(e, Yr(t, n))
}
function ar(e, t) {
    return typeof e == "function" ? e(t) : e
}
function lr(e) {
    return e.split("-")[0]
}
function eo(e) {
    return e.split("-")[1]
}
function wp(e) {
    return e === "x" ? "y" : "x"
}
function xp(e) {
    return e === "y" ? "height" : "width"
}
const hO = new Set(["top", "bottom"]);
function Dn(e) {
    return hO.has(lr(e)) ? "y" : "x"
}
function Sp(e) {
    return wp(Dn(e))
}
function pO(e, t, n) {
    n === void 0 && (n = !1);
    const s = eo(e)
        , o = Sp(e)
        , u = xp(o);
    let l = o === "x" ? s === (n ? "end" : "start") ? "right" : "left" : s === "start" ? "bottom" : "top";
    return t.reference[u] > t.floating[u] && (l = Mu(l)),
        [l, Mu(l)]
}
function mO(e) {
    const t = Mu(e);
    return [Eh(e), t, Eh(t)]
}
function Eh(e) {
    return e.replace(/start|end/g, t => fO[t])
}
const v0 = ["left", "right"]
    , w0 = ["right", "left"]
    , gO = ["top", "bottom"]
    , yO = ["bottom", "top"];
function vO(e, t, n) {
    switch (e) {
        case "top":
        case "bottom":
            return n ? t ? w0 : v0 : t ? v0 : w0;
        case "left":
        case "right":
            return t ? gO : yO;
        default:
            return []
    }
}
function wO(e, t, n, s) {
    const o = eo(e);
    let u = vO(lr(e), n === "start", s);
    return o && (u = u.map(l => l + "-" + o),
    t && (u = u.concat(u.map(Eh)))),
        u
}
function Mu(e) {
    return e.replace(/left|right|bottom|top/g, t => dO[t])
}
function xO(e) {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...e
    }
}
function WS(e) {
    return typeof e != "number" ? xO(e) : {
        top: e,
        right: e,
        bottom: e,
        left: e
    }
}
function ju(e) {
    const {x: t, y: n, width: s, height: o} = e;
    return {
        width: s,
        height: o,
        top: n,
        left: t,
        right: t + s,
        bottom: n + o,
        x: t,
        y: n
    }
}
function x0(e, t, n) {
    let {reference: s, floating: o} = e;
    const u = Dn(t)
        , l = Sp(t)
        , d = xp(l)
        , f = lr(t)
        , p = u === "y"
        , m = s.x + s.width / 2 - o.width / 2
        , y = s.y + s.height / 2 - o.height / 2
        , v = s[d] / 2 - o[d] / 2;
    let S;
    switch (f) {
        case "top":
            S = {
                x: m,
                y: s.y - o.height
            };
            break;
        case "bottom":
            S = {
                x: m,
                y: s.y + s.height
            };
            break;
        case "right":
            S = {
                x: s.x + s.width,
                y
            };
            break;
        case "left":
            S = {
                x: s.x - o.width,
                y
            };
            break;
        default:
            S = {
                x: s.x,
                y: s.y
            }
    }
    switch (eo(t)) {
        case "start":
            S[l] -= v * (n && p ? -1 : 1);
            break;
        case "end":
            S[l] += v * (n && p ? -1 : 1);
            break
    }
    return S
}
const SO = async (e, t, n) => {
        const {placement: s="bottom", strategy: o="absolute", middleware: u=[], platform: l} = n
            , d = u.filter(Boolean)
            , f = await (l.isRTL == null ? void 0 : l.isRTL(t));
        let p = await l.getElementRects({
            reference: e,
            floating: t,
            strategy: o
        })
            , {x: m, y} = x0(p, s, f)
            , v = s
            , S = {}
            , E = 0;
        for (let w = 0; w < d.length; w++) {
            const {name: x, fn: T} = d[w]
                , {x: k, y: R, data: _, reset: D} = await T({
                x: m,
                y,
                initialPlacement: s,
                placement: v,
                strategy: o,
                middlewareData: S,
                rects: p,
                platform: l,
                elements: {
                    reference: e,
                    floating: t
                }
            });
            m = k ?? m,
                y = R ?? y,
                S = {
                    ...S,
                    [x]: {
                        ...S[x],
                        ..._
                    }
                },
            D && E <= 50 && (E++,
            typeof D == "object" && (D.placement && (v = D.placement),
            D.rects && (p = D.rects === !0 ? await l.getElementRects({
                reference: e,
                floating: t,
                strategy: o
            }) : D.rects),
                {x: m, y} = x0(p, v, f)),
                w = -1)
        }
        return {
            x: m,
            y,
            placement: v,
            strategy: o,
            middlewareData: S
        }
    }
;
async function ga(e, t) {
    var n;
    t === void 0 && (t = {});
    const {x: s, y: o, platform: u, rects: l, elements: d, strategy: f} = e
        , {boundary: p="clippingAncestors", rootBoundary: m="viewport", elementContext: y="floating", altBoundary: v=!1, padding: S=0} = ar(t, e)
        , E = WS(S)
        , x = d[v ? y === "floating" ? "reference" : "floating" : y]
        , T = ju(await u.getClippingRect({
        element: (n = await (u.isElement == null ? void 0 : u.isElement(x))) == null || n ? x : x.contextElement || await (u.getDocumentElement == null ? void 0 : u.getDocumentElement(d.floating)),
        boundary: p,
        rootBoundary: m,
        strategy: f
    }))
        , k = y === "floating" ? {
        x: s,
        y: o,
        width: l.floating.width,
        height: l.floating.height
    } : l.reference
        , R = await (u.getOffsetParent == null ? void 0 : u.getOffsetParent(d.floating))
        , _ = await (u.isElement == null ? void 0 : u.isElement(R)) ? await (u.getScale == null ? void 0 : u.getScale(R)) || {
        x: 1,
        y: 1
    } : {
        x: 1,
        y: 1
    }
        , D = ju(u.convertOffsetParentRelativeRectToViewportRelativeRect ? await u.convertOffsetParentRelativeRectToViewportRelativeRect({
        elements: d,
        rect: k,
        offsetParent: R,
        strategy: f
    }) : k);
    return {
        top: (T.top - D.top + E.top) / _.y,
        bottom: (D.bottom - T.bottom + E.bottom) / _.y,
        left: (T.left - D.left + E.left) / _.x,
        right: (D.right - T.right + E.right) / _.x
    }
}
const bO = e => ({
    name: "arrow",
    options: e,
    async fn(t) {
        const {x: n, y: s, placement: o, rects: u, platform: l, elements: d, middlewareData: f} = t
            , {element: p, padding: m=0} = ar(e, t) || {};
        if (p == null)
            return {};
        const y = WS(m)
            , v = {
            x: n,
            y: s
        }
            , S = Sp(o)
            , E = xp(S)
            , w = await l.getDimensions(p)
            , x = S === "y"
            , T = x ? "top" : "left"
            , k = x ? "bottom" : "right"
            , R = x ? "clientHeight" : "clientWidth"
            , _ = u.reference[E] + u.reference[S] - v[S] - u.floating[E]
            , D = v[S] - u.reference[S]
            , H = await (l.getOffsetParent == null ? void 0 : l.getOffsetParent(p));
        let $ = H ? H[R] : 0;
        (!$ || !await (l.isElement == null ? void 0 : l.isElement(H))) && ($ = d.floating[R] || u.floating[E]);
        const O = _ / 2 - D / 2
            , W = $ / 2 - w[E] / 2 - 1
            , q = Yr(y[T], W)
            , X = Yr(y[k], W)
            , z = q
            , J = $ - w[E] - X
            , ae = $ / 2 - w[E] / 2 + O
            , ie = bh(z, ae, J)
            , ne = !f.arrow && eo(o) != null && ae !== ie && u.reference[E] / 2 - (ae < z ? q : X) - w[E] / 2 < 0
            , re = ne ? ae < z ? ae - z : ae - J : 0;
        return {
            [S]: v[S] + re,
            data: {
                [S]: ie,
                centerOffset: ae - ie - re,
                ...ne && {
                    alignmentOffset: re
                }
            },
            reset: ne
        }
    }
})
    , EO = function(e) {
    return e === void 0 && (e = {}),
        {
            name: "flip",
            options: e,
            async fn(t) {
                var n, s;
                const {placement: o, middlewareData: u, rects: l, initialPlacement: d, platform: f, elements: p} = t
                    , {mainAxis: m=!0, crossAxis: y=!0, fallbackPlacements: v, fallbackStrategy: S="bestFit", fallbackAxisSideDirection: E="none", flipAlignment: w=!0, ...x} = ar(e, t);
                if ((n = u.arrow) != null && n.alignmentOffset)
                    return {};
                const T = lr(o)
                    , k = Dn(d)
                    , R = lr(d) === d
                    , _ = await (f.isRTL == null ? void 0 : f.isRTL(p.floating))
                    , D = v || (R || !w ? [Mu(d)] : mO(d))
                    , H = E !== "none";
                !v && H && D.push(...wO(d, w, E, _));
                const $ = [d, ...D]
                    , O = await ga(t, x)
                    , W = [];
                let q = ((s = u.flip) == null ? void 0 : s.overflows) || [];
                if (m && W.push(O[T]),
                    y) {
                    const ae = pO(o, l, _);
                    W.push(O[ae[0]], O[ae[1]])
                }
                if (q = [...q, {
                    placement: o,
                    overflows: W
                }],
                    !W.every(ae => ae <= 0)) {
                    var X, z;
                    const ae = (((X = u.flip) == null ? void 0 : X.index) || 0) + 1
                        , ie = $[ae];
                    if (ie && (!(y === "alignment" ? k !== Dn(ie) : !1) || q.every(I => Dn(I.placement) === k ? I.overflows[0] > 0 : !0)))
                        return {
                            data: {
                                index: ae,
                                overflows: q
                            },
                            reset: {
                                placement: ie
                            }
                        };
                    let ne = (z = q.filter(re => re.overflows[0] <= 0).sort( (re, I) => re.overflows[1] - I.overflows[1])[0]) == null ? void 0 : z.placement;
                    if (!ne)
                        switch (S) {
                            case "bestFit":
                            {
                                var J;
                                const re = (J = q.filter(I => {
                                        if (H) {
                                            const se = Dn(I.placement);
                                            return se === k || se === "y"
                                        }
                                        return !0
                                    }
                                ).map(I => [I.placement, I.overflows.filter(se => se > 0).reduce( (se, ee) => se + ee, 0)]).sort( (I, se) => I[1] - se[1])[0]) == null ? void 0 : J[0];
                                re && (ne = re);
                                break
                            }
                            case "initialPlacement":
                                ne = d;
                                break
                        }
                    if (o !== ne)
                        return {
                            reset: {
                                placement: ne
                            }
                        }
                }
                return {}
            }
        }
};
function S0(e, t) {
    return {
        top: e.top - t.height,
        right: e.right - t.width,
        bottom: e.bottom - t.height,
        left: e.left - t.width
    }
}
function b0(e) {
    return cO.some(t => e[t] >= 0)
}
const CO = function(e) {
    return e === void 0 && (e = {}),
        {
            name: "hide",
            options: e,
            async fn(t) {
                const {rects: n} = t
                    , {strategy: s="referenceHidden", ...o} = ar(e, t);
                switch (s) {
                    case "referenceHidden":
                    {
                        const u = await ga(t, {
                            ...o,
                            elementContext: "reference"
                        })
                            , l = S0(u, n.reference);
                        return {
                            data: {
                                referenceHiddenOffsets: l,
                                referenceHidden: b0(l)
                            }
                        }
                    }
                    case "escaped":
                    {
                        const u = await ga(t, {
                            ...o,
                            altBoundary: !0
                        })
                            , l = S0(u, n.floating);
                        return {
                            data: {
                                escapedOffsets: l,
                                escaped: b0(l)
                            }
                        }
                    }
                    default:
                        return {}
                }
            }
        }
}
    , HS = new Set(["left", "top"]);
async function PO(e, t) {
    const {placement: n, platform: s, elements: o} = e
        , u = await (s.isRTL == null ? void 0 : s.isRTL(o.floating))
        , l = lr(n)
        , d = eo(n)
        , f = Dn(n) === "y"
        , p = HS.has(l) ? -1 : 1
        , m = u && f ? -1 : 1
        , y = ar(t, e);
    let {mainAxis: v, crossAxis: S, alignmentAxis: E} = typeof y == "number" ? {
        mainAxis: y,
        crossAxis: 0,
        alignmentAxis: null
    } : {
        mainAxis: y.mainAxis || 0,
        crossAxis: y.crossAxis || 0,
        alignmentAxis: y.alignmentAxis
    };
    return d && typeof E == "number" && (S = d === "end" ? E * -1 : E),
        f ? {
            x: S * m,
            y: v * p
        } : {
            x: v * p,
            y: S * m
        }
}
const TO = function(e) {
    return e === void 0 && (e = 0),
        {
            name: "offset",
            options: e,
            async fn(t) {
                var n, s;
                const {x: o, y: u, placement: l, middlewareData: d} = t
                    , f = await PO(t, e);
                return l === ((n = d.offset) == null ? void 0 : n.placement) && (s = d.arrow) != null && s.alignmentOffset ? {} : {
                    x: o + f.x,
                    y: u + f.y,
                    data: {
                        ...f,
                        placement: l
                    }
                }
            }
        }
}
    , kO = function(e) {
    return e === void 0 && (e = {}),
        {
            name: "shift",
            options: e,
            async fn(t) {
                const {x: n, y: s, placement: o} = t
                    , {mainAxis: u=!0, crossAxis: l=!1, limiter: d={
                    fn: x => {
                        let {x: T, y: k} = x;
                        return {
                            x: T,
                            y: k
                        }
                    }
                }, ...f} = ar(e, t)
                    , p = {
                    x: n,
                    y: s
                }
                    , m = await ga(t, f)
                    , y = Dn(lr(o))
                    , v = wp(y);
                let S = p[v]
                    , E = p[y];
                if (u) {
                    const x = v === "y" ? "top" : "left"
                        , T = v === "y" ? "bottom" : "right"
                        , k = S + m[x]
                        , R = S - m[T];
                    S = bh(k, S, R)
                }
                if (l) {
                    const x = y === "y" ? "top" : "left"
                        , T = y === "y" ? "bottom" : "right"
                        , k = E + m[x]
                        , R = E - m[T];
                    E = bh(k, E, R)
                }
                const w = d.fn({
                    ...t,
                    [v]: S,
                    [y]: E
                });
                return {
                    ...w,
                    data: {
                        x: w.x - n,
                        y: w.y - s,
                        enabled: {
                            [v]: u,
                            [y]: l
                        }
                    }
                }
            }
        }
}
    , RO = function(e) {
    return e === void 0 && (e = {}),
        {
            options: e,
            fn(t) {
                const {x: n, y: s, placement: o, rects: u, middlewareData: l} = t
                    , {offset: d=0, mainAxis: f=!0, crossAxis: p=!0} = ar(e, t)
                    , m = {
                    x: n,
                    y: s
                }
                    , y = Dn(o)
                    , v = wp(y);
                let S = m[v]
                    , E = m[y];
                const w = ar(d, t)
                    , x = typeof w == "number" ? {
                    mainAxis: w,
                    crossAxis: 0
                } : {
                    mainAxis: 0,
                    crossAxis: 0,
                    ...w
                };
                if (f) {
                    const R = v === "y" ? "height" : "width"
                        , _ = u.reference[v] - u.floating[R] + x.mainAxis
                        , D = u.reference[v] + u.reference[R] - x.mainAxis;
                    S < _ ? S = _ : S > D && (S = D)
                }
                if (p) {
                    var T, k;
                    const R = v === "y" ? "width" : "height"
                        , _ = HS.has(lr(o))
                        , D = u.reference[y] - u.floating[R] + (_ && ((T = l.offset) == null ? void 0 : T[y]) || 0) + (_ ? 0 : x.crossAxis)
                        , H = u.reference[y] + u.reference[R] + (_ ? 0 : ((k = l.offset) == null ? void 0 : k[y]) || 0) - (_ ? x.crossAxis : 0);
                    E < D ? E = D : E > H && (E = H)
                }
                return {
                    [v]: S,
                    [y]: E
                }
            }
        }
}
    , AO = function(e) {
    return e === void 0 && (e = {}),
        {
            name: "size",
            options: e,
            async fn(t) {
                var n, s;
                const {placement: o, rects: u, platform: l, elements: d} = t
                    , {apply: f= () => {}
                    , ...p} = ar(e, t)
                    , m = await ga(t, p)
                    , y = lr(o)
                    , v = eo(o)
                    , S = Dn(o) === "y"
                    , {width: E, height: w} = u.floating;
                let x, T;
                y === "top" || y === "bottom" ? (x = y,
                    T = v === (await (l.isRTL == null ? void 0 : l.isRTL(d.floating)) ? "start" : "end") ? "left" : "right") : (T = y,
                    x = v === "end" ? "top" : "bottom");
                const k = w - m.top - m.bottom
                    , R = E - m.left - m.right
                    , _ = Yr(w - m[x], k)
                    , D = Yr(E - m[T], R)
                    , H = !t.middlewareData.shift;
                let $ = _
                    , O = D;
                if ((n = t.middlewareData.shift) != null && n.enabled.x && (O = R),
                (s = t.middlewareData.shift) != null && s.enabled.y && ($ = k),
                H && !v) {
                    const q = Kt(m.left, 0)
                        , X = Kt(m.right, 0)
                        , z = Kt(m.top, 0)
                        , J = Kt(m.bottom, 0);
                    S ? O = E - 2 * (q !== 0 || X !== 0 ? q + X : Kt(m.left, m.right)) : $ = w - 2 * (z !== 0 || J !== 0 ? z + J : Kt(m.top, m.bottom))
                }
                await f({
                    ...t,
                    availableWidth: O,
                    availableHeight: $
                });
                const W = await l.getDimensions(d.floating);
                return E !== W.width || w !== W.height ? {
                    reset: {
                        rects: !0
                    }
                } : {}
            }
        }
};
function Zu() {
    return typeof window < "u"
}
function to(e) {
    return qS(e) ? (e.nodeName || "").toLowerCase() : "#document"
}
function Qt(e) {
    var t;
    return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window
}
function Wn(e) {
    var t;
    return (t = (qS(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement
}
function qS(e) {
    return Zu() ? e instanceof Node || e instanceof Qt(e).Node : !1
}
function En(e) {
    return Zu() ? e instanceof Element || e instanceof Qt(e).Element : !1
}
function $n(e) {
    return Zu() ? e instanceof HTMLElement || e instanceof Qt(e).HTMLElement : !1
}
function E0(e) {
    return !Zu() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof Qt(e).ShadowRoot
}
const _O = new Set(["inline", "contents"]);
function ja(e) {
    const {overflow: t, overflowX: n, overflowY: s, display: o} = Cn(e);
    return /auto|scroll|overlay|hidden|clip/.test(t + s + n) && !_O.has(o)
}
const NO = new Set(["table", "td", "th"]);
function OO(e) {
    return NO.has(to(e))
}
const LO = [":popover-open", ":modal"];
function ec(e) {
    return LO.some(t => {
            try {
                return e.matches(t)
            } catch {
                return !1
            }
        }
    )
}
const MO = ["transform", "translate", "scale", "rotate", "perspective"]
    , jO = ["transform", "translate", "scale", "rotate", "perspective", "filter"]
    , DO = ["paint", "layout", "strict", "content"];
function bp(e) {
    const t = Ep()
        , n = En(e) ? Cn(e) : e;
    return MO.some(s => n[s] ? n[s] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || jO.some(s => (n.willChange || "").includes(s)) || DO.some(s => (n.contain || "").includes(s))
}
function IO(e) {
    let t = Jr(e);
    for (; $n(t) && !$i(t); ) {
        if (bp(t))
            return t;
        if (ec(t))
            return null;
        t = Jr(t)
    }
    return null
}
function Ep() {
    return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none")
}
const FO = new Set(["html", "body", "#document"]);
function $i(e) {
    return FO.has(to(e))
}
function Cn(e) {
    return Qt(e).getComputedStyle(e)
}
function tc(e) {
    return En(e) ? {
        scrollLeft: e.scrollLeft,
        scrollTop: e.scrollTop
    } : {
        scrollLeft: e.scrollX,
        scrollTop: e.scrollY
    }
}
function Jr(e) {
    if (to(e) === "html")
        return e;
    const t = e.assignedSlot || e.parentNode || E0(e) && e.host || Wn(e);
    return E0(t) ? t.host : t
}
function KS(e) {
    const t = Jr(e);
    return $i(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : $n(t) && ja(t) ? t : KS(t)
}
function ya(e, t, n) {
    var s;
    t === void 0 && (t = []),
    n === void 0 && (n = !0);
    const o = KS(e)
        , u = o === ((s = e.ownerDocument) == null ? void 0 : s.body)
        , l = Qt(o);
    if (u) {
        const d = Ch(l);
        return t.concat(l, l.visualViewport || [], ja(o) ? o : [], d && n ? ya(d) : [])
    }
    return t.concat(o, ya(o, [], n))
}
function Ch(e) {
    return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null
}
function QS(e) {
    const t = Cn(e);
    let n = parseFloat(t.width) || 0
        , s = parseFloat(t.height) || 0;
    const o = $n(e)
        , u = o ? e.offsetWidth : n
        , l = o ? e.offsetHeight : s
        , d = Lu(n) !== u || Lu(s) !== l;
    return d && (n = u,
        s = l),
        {
            width: n,
            height: s,
            $: d
        }
}
function Cp(e) {
    return En(e) ? e : e.contextElement
}
function ki(e) {
    const t = Cp(e);
    if (!$n(t))
        return Bn(1);
    const n = t.getBoundingClientRect()
        , {width: s, height: o, $: u} = QS(t);
    let l = (u ? Lu(n.width) : n.width) / s
        , d = (u ? Lu(n.height) : n.height) / o;
    return (!l || !Number.isFinite(l)) && (l = 1),
    (!d || !Number.isFinite(d)) && (d = 1),
        {
            x: l,
            y: d
        }
}
const BO = Bn(0);
function GS(e) {
    const t = Qt(e);
    return !Ep() || !t.visualViewport ? BO : {
        x: t.visualViewport.offsetLeft,
        y: t.visualViewport.offsetTop
    }
}
function VO(e, t, n) {
    return t === void 0 && (t = !1),
        !n || t && n !== Qt(e) ? !1 : t
}
function Fs(e, t, n, s) {
    t === void 0 && (t = !1),
    n === void 0 && (n = !1);
    const o = e.getBoundingClientRect()
        , u = Cp(e);
    let l = Bn(1);
    t && (s ? En(s) && (l = ki(s)) : l = ki(e));
    const d = VO(u, n, s) ? GS(u) : Bn(0);
    let f = (o.left + d.x) / l.x
        , p = (o.top + d.y) / l.y
        , m = o.width / l.x
        , y = o.height / l.y;
    if (u) {
        const v = Qt(u)
            , S = s && En(s) ? Qt(s) : s;
        let E = v
            , w = Ch(E);
        for (; w && s && S !== E; ) {
            const x = ki(w)
                , T = w.getBoundingClientRect()
                , k = Cn(w)
                , R = T.left + (w.clientLeft + parseFloat(k.paddingLeft)) * x.x
                , _ = T.top + (w.clientTop + parseFloat(k.paddingTop)) * x.y;
            f *= x.x,
                p *= x.y,
                m *= x.x,
                y *= x.y,
                f += R,
                p += _,
                E = Qt(w),
                w = Ch(E)
        }
    }
    return ju({
        width: m,
        height: y,
        x: f,
        y: p
    })
}
function nc(e, t) {
    const n = tc(e).scrollLeft;
    return t ? t.left + n : Fs(Wn(e)).left + n
}
function XS(e, t) {
    const n = e.getBoundingClientRect()
        , s = n.left + t.scrollLeft - nc(e, n)
        , o = n.top + t.scrollTop;
    return {
        x: s,
        y: o
    }
}
function UO(e) {
    let {elements: t, rect: n, offsetParent: s, strategy: o} = e;
    const u = o === "fixed"
        , l = Wn(s)
        , d = t ? ec(t.floating) : !1;
    if (s === l || d && u)
        return n;
    let f = {
        scrollLeft: 0,
        scrollTop: 0
    }
        , p = Bn(1);
    const m = Bn(0)
        , y = $n(s);
    if ((y || !y && !u) && ((to(s) !== "body" || ja(l)) && (f = tc(s)),
        $n(s))) {
        const S = Fs(s);
        p = ki(s),
            m.x = S.x + s.clientLeft,
            m.y = S.y + s.clientTop
    }
    const v = l && !y && !u ? XS(l, f) : Bn(0);
    return {
        width: n.width * p.x,
        height: n.height * p.y,
        x: n.x * p.x - f.scrollLeft * p.x + m.x + v.x,
        y: n.y * p.y - f.scrollTop * p.y + m.y + v.y
    }
}
function zO(e) {
    return Array.from(e.getClientRects())
}
function $O(e) {
    const t = Wn(e)
        , n = tc(e)
        , s = e.ownerDocument.body
        , o = Kt(t.scrollWidth, t.clientWidth, s.scrollWidth, s.clientWidth)
        , u = Kt(t.scrollHeight, t.clientHeight, s.scrollHeight, s.clientHeight);
    let l = -n.scrollLeft + nc(e);
    const d = -n.scrollTop;
    return Cn(s).direction === "rtl" && (l += Kt(t.clientWidth, s.clientWidth) - o),
        {
            width: o,
            height: u,
            x: l,
            y: d
        }
}
const C0 = 25;
function WO(e, t) {
    const n = Qt(e)
        , s = Wn(e)
        , o = n.visualViewport;
    let u = s.clientWidth
        , l = s.clientHeight
        , d = 0
        , f = 0;
    if (o) {
        u = o.width,
            l = o.height;
        const m = Ep();
        (!m || m && t === "fixed") && (d = o.offsetLeft,
            f = o.offsetTop)
    }
    const p = nc(s);
    if (p <= 0) {
        const m = s.ownerDocument
            , y = m.body
            , v = getComputedStyle(y)
            , S = m.compatMode === "CSS1Compat" && parseFloat(v.marginLeft) + parseFloat(v.marginRight) || 0
            , E = Math.abs(s.clientWidth - y.clientWidth - S);
        E <= C0 && (u -= E)
    } else
        p <= C0 && (u += p);
    return {
        width: u,
        height: l,
        x: d,
        y: f
    }
}
const HO = new Set(["absolute", "fixed"]);
function qO(e, t) {
    const n = Fs(e, !0, t === "fixed")
        , s = n.top + e.clientTop
        , o = n.left + e.clientLeft
        , u = $n(e) ? ki(e) : Bn(1)
        , l = e.clientWidth * u.x
        , d = e.clientHeight * u.y
        , f = o * u.x
        , p = s * u.y;
    return {
        width: l,
        height: d,
        x: f,
        y: p
    }
}
function P0(e, t, n) {
    let s;
    if (t === "viewport")
        s = WO(e, n);
    else if (t === "document")
        s = $O(Wn(e));
    else if (En(t))
        s = qO(t, n);
    else {
        const o = GS(e);
        s = {
            x: t.x - o.x,
            y: t.y - o.y,
            width: t.width,
            height: t.height
        }
    }
    return ju(s)
}
function YS(e, t) {
    const n = Jr(e);
    return n === t || !En(n) || $i(n) ? !1 : Cn(n).position === "fixed" || YS(n, t)
}
function KO(e, t) {
    const n = t.get(e);
    if (n)
        return n;
    let s = ya(e, [], !1).filter(d => En(d) && to(d) !== "body")
        , o = null;
    const u = Cn(e).position === "fixed";
    let l = u ? Jr(e) : e;
    for (; En(l) && !$i(l); ) {
        const d = Cn(l)
            , f = bp(l);
        !f && d.position === "fixed" && (o = null),
            (u ? !f && !o : !f && d.position === "static" && !!o && HO.has(o.position) || ja(l) && !f && YS(e, l)) ? s = s.filter(m => m !== l) : o = d,
            l = Jr(l)
    }
    return t.set(e, s),
        s
}
function QO(e) {
    let {element: t, boundary: n, rootBoundary: s, strategy: o} = e;
    const l = [...n === "clippingAncestors" ? ec(t) ? [] : KO(t, this._c) : [].concat(n), s]
        , d = l[0]
        , f = l.reduce( (p, m) => {
            const y = P0(t, m, o);
            return p.top = Kt(y.top, p.top),
                p.right = Yr(y.right, p.right),
                p.bottom = Yr(y.bottom, p.bottom),
                p.left = Kt(y.left, p.left),
                p
        }
        , P0(t, d, o));
    return {
        width: f.right - f.left,
        height: f.bottom - f.top,
        x: f.left,
        y: f.top
    }
}
function GO(e) {
    const {width: t, height: n} = QS(e);
    return {
        width: t,
        height: n
    }
}
function XO(e, t, n) {
    const s = $n(t)
        , o = Wn(t)
        , u = n === "fixed"
        , l = Fs(e, !0, u, t);
    let d = {
        scrollLeft: 0,
        scrollTop: 0
    };
    const f = Bn(0);
    function p() {
        f.x = nc(o)
    }
    if (s || !s && !u)
        if ((to(t) !== "body" || ja(o)) && (d = tc(t)),
            s) {
            const S = Fs(t, !0, u, t);
            f.x = S.x + t.clientLeft,
                f.y = S.y + t.clientTop
        } else
            o && p();
    u && !s && o && p();
    const m = o && !s && !u ? XS(o, d) : Bn(0)
        , y = l.left + d.scrollLeft - f.x - m.x
        , v = l.top + d.scrollTop - f.y - m.y;
    return {
        x: y,
        y: v,
        width: l.width,
        height: l.height
    }
}
function Pf(e) {
    return Cn(e).position === "static"
}
function T0(e, t) {
    if (!$n(e) || Cn(e).position === "fixed")
        return null;
    if (t)
        return t(e);
    let n = e.offsetParent;
    return Wn(e) === n && (n = n.ownerDocument.body),
        n
}
function JS(e, t) {
    const n = Qt(e);
    if (ec(e))
        return n;
    if (!$n(e)) {
        let o = Jr(e);
        for (; o && !$i(o); ) {
            if (En(o) && !Pf(o))
                return o;
            o = Jr(o)
        }
        return n
    }
    let s = T0(e, t);
    for (; s && OO(s) && Pf(s); )
        s = T0(s, t);
    return s && $i(s) && Pf(s) && !bp(s) ? n : s || IO(e) || n
}
const YO = async function(e) {
    const t = this.getOffsetParent || JS
        , n = this.getDimensions
        , s = await n(e.floating);
    return {
        reference: XO(e.reference, await t(e.floating), e.strategy),
        floating: {
            x: 0,
            y: 0,
            width: s.width,
            height: s.height
        }
    }
};
function JO(e) {
    return Cn(e).direction === "rtl"
}
const ZO = {
    convertOffsetParentRelativeRectToViewportRelativeRect: UO,
    getDocumentElement: Wn,
    getClippingRect: QO,
    getOffsetParent: JS,
    getElementRects: YO,
    getClientRects: zO,
    getDimensions: GO,
    getScale: ki,
    isElement: En,
    isRTL: JO
};
function ZS(e, t) {
    return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height
}
function eL(e, t) {
    let n = null, s;
    const o = Wn(e);
    function u() {
        var d;
        clearTimeout(s),
        (d = n) == null || d.disconnect(),
            n = null
    }
    function l(d, f) {
        d === void 0 && (d = !1),
        f === void 0 && (f = 1),
            u();
        const p = e.getBoundingClientRect()
            , {left: m, top: y, width: v, height: S} = p;
        if (d || t(),
        !v || !S)
            return;
        const E = su(y)
            , w = su(o.clientWidth - (m + v))
            , x = su(o.clientHeight - (y + S))
            , T = su(m)
            , R = {
            rootMargin: -E + "px " + -w + "px " + -x + "px " + -T + "px",
            threshold: Kt(0, Yr(1, f)) || 1
        };
        let _ = !0;
        function D(H) {
            const $ = H[0].intersectionRatio;
            if ($ !== f) {
                if (!_)
                    return l();
                $ ? l(!1, $) : s = setTimeout( () => {
                        l(!1, 1e-7)
                    }
                    , 1e3)
            }
            $ === 1 && !ZS(p, e.getBoundingClientRect()) && l(),
                _ = !1
        }
        try {
            n = new IntersectionObserver(D,{
                ...R,
                root: o.ownerDocument
            })
        } catch {
            n = new IntersectionObserver(D,R)
        }
        n.observe(e)
    }
    return l(!0),
        u
}
function tL(e, t, n, s) {
    s === void 0 && (s = {});
    const {ancestorScroll: o=!0, ancestorResize: u=!0, elementResize: l=typeof ResizeObserver == "function", layoutShift: d=typeof IntersectionObserver == "function", animationFrame: f=!1} = s
        , p = Cp(e)
        , m = o || u ? [...p ? ya(p) : [], ...ya(t)] : [];
    m.forEach(T => {
            o && T.addEventListener("scroll", n, {
                passive: !0
            }),
            u && T.addEventListener("resize", n)
        }
    );
    const y = p && d ? eL(p, n) : null;
    let v = -1
        , S = null;
    l && (S = new ResizeObserver(T => {
            let[k] = T;
            k && k.target === p && S && (S.unobserve(t),
                cancelAnimationFrame(v),
                v = requestAnimationFrame( () => {
                        var R;
                        (R = S) == null || R.observe(t)
                    }
                )),
                n()
        }
    ),
    p && !f && S.observe(p),
        S.observe(t));
    let E, w = f ? Fs(e) : null;
    f && x();
    function x() {
        const T = Fs(e);
        w && !ZS(w, T) && n(),
            w = T,
            E = requestAnimationFrame(x)
    }
    return n(),
        () => {
            var T;
            m.forEach(k => {
                    o && k.removeEventListener("scroll", n),
                    u && k.removeEventListener("resize", n)
                }
            ),
            y == null || y(),
            (T = S) == null || T.disconnect(),
                S = null,
            f && cancelAnimationFrame(E)
        }
}
const nL = TO
    , rL = kO
    , sL = EO
    , iL = AO
    , oL = CO
    , k0 = bO
    , aL = RO
    , lL = (e, t, n) => {
        const s = new Map
            , o = {
            platform: ZO,
            ...n
        }
            , u = {
            ...o.platform,
            _c: s
        };
        return SO(e, t, {
            ...o,
            platform: u
        })
    }
;
var uL = typeof document < "u"
    , cL = function() {}
    , bu = uL ? P.useLayoutEffect : cL;
function Du(e, t) {
    if (e === t)
        return !0;
    if (typeof e != typeof t)
        return !1;
    if (typeof e == "function" && e.toString() === t.toString())
        return !0;
    let n, s, o;
    if (e && t && typeof e == "object") {
        if (Array.isArray(e)) {
            if (n = e.length,
            n !== t.length)
                return !1;
            for (s = n; s-- !== 0; )
                if (!Du(e[s], t[s]))
                    return !1;
            return !0
        }
        if (o = Object.keys(e),
            n = o.length,
        n !== Object.keys(t).length)
            return !1;
        for (s = n; s-- !== 0; )
            if (!{}.hasOwnProperty.call(t, o[s]))
                return !1;
        for (s = n; s-- !== 0; ) {
            const u = o[s];
            if (!(u === "_owner" && e.$$typeof) && !Du(e[u], t[u]))
                return !1
        }
        return !0
    }
    return e !== e && t !== t
}
function eb(e) {
    return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1
}
function R0(e, t) {
    const n = eb(e);
    return Math.round(t * n) / n
}
function Tf(e) {
    const t = P.useRef(e);
    return bu( () => {
            t.current = e
        }
    ),
        t
}
function dL(e) {
    e === void 0 && (e = {});
    const {placement: t="bottom", strategy: n="absolute", middleware: s=[], platform: o, elements: {reference: u, floating: l}={}, transform: d=!0, whileElementsMounted: f, open: p} = e
        , [m,y] = P.useState({
        x: 0,
        y: 0,
        strategy: n,
        placement: t,
        middlewareData: {},
        isPositioned: !1
    })
        , [v,S] = P.useState(s);
    Du(v, s) || S(s);
    const [E,w] = P.useState(null)
        , [x,T] = P.useState(null)
        , k = P.useCallback(I => {
            I !== H.current && (H.current = I,
                w(I))
        }
        , [])
        , R = P.useCallback(I => {
            I !== $.current && ($.current = I,
                T(I))
        }
        , [])
        , _ = u || E
        , D = l || x
        , H = P.useRef(null)
        , $ = P.useRef(null)
        , O = P.useRef(m)
        , W = f != null
        , q = Tf(f)
        , X = Tf(o)
        , z = Tf(p)
        , J = P.useCallback( () => {
            if (!H.current || !$.current)
                return;
            const I = {
                placement: t,
                strategy: n,
                middleware: v
            };
            X.current && (I.platform = X.current),
                lL(H.current, $.current, I).then(se => {
                        const ee = {
                            ...se,
                            isPositioned: z.current !== !1
                        };
                        ae.current && !Du(O.current, ee) && (O.current = ee,
                            Aa.flushSync( () => {
                                    y(ee)
                                }
                            ))
                    }
                )
        }
        , [v, t, n, X, z]);
    bu( () => {
            p === !1 && O.current.isPositioned && (O.current.isPositioned = !1,
                y(I => ({
                    ...I,
                    isPositioned: !1
                })))
        }
        , [p]);
    const ae = P.useRef(!1);
    bu( () => (ae.current = !0,
            () => {
                ae.current = !1
            }
    ), []),
        bu( () => {
                if (_ && (H.current = _),
                D && ($.current = D),
                _ && D) {
                    if (q.current)
                        return q.current(_, D, J);
                    J()
                }
            }
            , [_, D, J, q, W]);
    const ie = P.useMemo( () => ({
        reference: H,
        floating: $,
        setReference: k,
        setFloating: R
    }), [k, R])
        , ne = P.useMemo( () => ({
        reference: _,
        floating: D
    }), [_, D])
        , re = P.useMemo( () => {
            const I = {
                position: n,
                left: 0,
                top: 0
            };
            if (!ne.floating)
                return I;
            const se = R0(ne.floating, m.x)
                , ee = R0(ne.floating, m.y);
            return d ? {
                ...I,
                transform: "translate(" + se + "px, " + ee + "px)",
                ...eb(ne.floating) >= 1.5 && {
                    willChange: "transform"
                }
            } : {
                position: n,
                left: se,
                top: ee
            }
        }
        , [n, d, ne.floating, m.x, m.y]);
    return P.useMemo( () => ({
        ...m,
        update: J,
        refs: ie,
        elements: ne,
        floatingStyles: re
    }), [m, J, ie, ne, re])
}
const fL = e => {
    function t(n) {
        return {}.hasOwnProperty.call(n, "current")
    }
    return {
        name: "arrow",
        options: e,
        fn(n) {
            const {element: s, padding: o} = typeof e == "function" ? e(n) : e;
            return s && t(s) ? s.current != null ? k0({
                element: s.current,
                padding: o
            }).fn(n) : {} : s ? k0({
                element: s,
                padding: o
            }).fn(n) : {}
        }
    }
}
    , hL = (e, t) => ({
    ...nL(e),
    options: [e, t]
})
    , pL = (e, t) => ({
    ...rL(e),
    options: [e, t]
})
    , mL = (e, t) => ({
    ...aL(e),
    options: [e, t]
})
    , gL = (e, t) => ({
    ...sL(e),
    options: [e, t]
})
    , yL = (e, t) => ({
    ...iL(e),
    options: [e, t]
})
    , vL = (e, t) => ({
    ...oL(e),
    options: [e, t]
})
    , wL = (e, t) => ({
    ...fL(e),
    options: [e, t]
});
var xL = "Arrow"
    , tb = P.forwardRef( (e, t) => {
        const {children: n, width: s=10, height: o=5, ...u} = e;
        return b.jsx(tt.svg, {
            ...u,
            ref: t,
            width: s,
            height: o,
            viewBox: "0 0 30 10",
            preserveAspectRatio: "none",
            children: e.asChild ? n : b.jsx("polygon", {
                points: "0,0 30,0 15,10"
            })
        })
    }
);
tb.displayName = xL;
var SL = tb;
function bL(e) {
    const [t,n] = P.useState(void 0);
    return zt( () => {
            if (e) {
                n({
                    width: e.offsetWidth,
                    height: e.offsetHeight
                });
                const s = new ResizeObserver(o => {
                        if (!Array.isArray(o) || !o.length)
                            return;
                        const u = o[0];
                        let l, d;
                        if ("borderBoxSize"in u) {
                            const f = u.borderBoxSize
                                , p = Array.isArray(f) ? f[0] : f;
                            l = p.inlineSize,
                                d = p.blockSize
                        } else
                            l = e.offsetWidth,
                                d = e.offsetHeight;
                        n({
                            width: l,
                            height: d
                        })
                    }
                );
                return s.observe(e, {
                    box: "border-box"
                }),
                    () => s.unobserve(e)
            } else
                n(void 0)
        }
        , [e]),
        t
}
var Pp = "Popper"
    , [nb,rb] = yp(Pp)
    , [EL,sb] = nb(Pp)
    , ib = e => {
        const {__scopePopper: t, children: n} = e
            , [s,o] = P.useState(null);
        return b.jsx(EL, {
            scope: t,
            anchor: s,
            onAnchorChange: o,
            children: n
        })
    }
;
ib.displayName = Pp;
var ob = "PopperAnchor"
    , ab = P.forwardRef( (e, t) => {
        const {__scopePopper: n, virtualRef: s, ...o} = e
            , u = sb(ob, n)
            , l = P.useRef(null)
            , d = wt(t, l)
            , f = P.useRef(null);
        return P.useEffect( () => {
                const p = f.current;
                f.current = (s == null ? void 0 : s.current) || l.current,
                p !== f.current && u.onAnchorChange(f.current)
            }
        ),
            s ? null : b.jsx(tt.div, {
                ...o,
                ref: d
            })
    }
);
ab.displayName = ob;
var Tp = "PopperContent"
    , [CL,PL] = nb(Tp)
    , lb = P.forwardRef( (e, t) => {
        var Z, ye, Ce, Pe, _e, Ne;
        const {__scopePopper: n, side: s="bottom", sideOffset: o=0, align: u="center", alignOffset: l=0, arrowPadding: d=0, avoidCollisions: f=!0, collisionBoundary: p=[], collisionPadding: m=0, sticky: y="partial", hideWhenDetached: v=!1, updatePositionStrategy: S="optimized", onPlaced: E, ...w} = e
            , x = sb(Tp, n)
            , [T,k] = P.useState(null)
            , R = wt(t, ut => k(ut))
            , [_,D] = P.useState(null)
            , H = bL(_)
            , $ = (H == null ? void 0 : H.width) ?? 0
            , O = (H == null ? void 0 : H.height) ?? 0
            , W = s + (u !== "center" ? "-" + u : "")
            , q = typeof m == "number" ? m : {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0,
            ...m
        }
            , X = Array.isArray(p) ? p : [p]
            , z = X.length > 0
            , J = {
            padding: q,
            boundary: X.filter(kL),
            altBoundary: z
        }
            , {refs: ae, floatingStyles: ie, placement: ne, isPositioned: re, middlewareData: I} = dL({
            strategy: "fixed",
            placement: W,
            whileElementsMounted: (...ut) => tL(...ut, {
                animationFrame: S === "always"
            }),
            elements: {
                reference: x.anchor
            },
            middleware: [hL({
                mainAxis: o + O,
                alignmentAxis: l
            }), f && pL({
                mainAxis: !0,
                crossAxis: !1,
                limiter: y === "partial" ? mL() : void 0,
                ...J
            }), f && gL({
                ...J
            }), yL({
                ...J,
                apply: ({elements: ut, rects: Nt, availableWidth: cr, availableHeight: dr}) => {
                    const {width: Hn, height: Ua} = Nt.reference
                        , fr = ut.floating.style;
                    fr.setProperty("--radix-popper-available-width", `${cr}px`),
                        fr.setProperty("--radix-popper-available-height", `${dr}px`),
                        fr.setProperty("--radix-popper-anchor-width", `${Hn}px`),
                        fr.setProperty("--radix-popper-anchor-height", `${Ua}px`)
                }
            }), _ && wL({
                element: _,
                padding: d
            }), RL({
                arrowWidth: $,
                arrowHeight: O
            }), v && vL({
                strategy: "referenceHidden",
                ...J
            })]
        })
            , [se,ee] = db(ne)
            , j = Is(E);
        zt( () => {
                re && (j == null || j())
            }
            , [re, j]);
        const K = (Z = I.arrow) == null ? void 0 : Z.x
            , ce = (ye = I.arrow) == null ? void 0 : ye.y
            , de = ((Ce = I.arrow) == null ? void 0 : Ce.centerOffset) !== 0
            , [be,Te] = P.useState();
        return zt( () => {
                T && Te(window.getComputedStyle(T).zIndex)
            }
            , [T]),
            b.jsx("div", {
                ref: ae.setFloating,
                "data-radix-popper-content-wrapper": "",
                style: {
                    ...ie,
                    transform: re ? ie.transform : "translate(0, -200%)",
                    minWidth: "max-content",
                    zIndex: be,
                    "--radix-popper-transform-origin": [(Pe = I.transformOrigin) == null ? void 0 : Pe.x, (_e = I.transformOrigin) == null ? void 0 : _e.y].join(" "),
                    ...((Ne = I.hide) == null ? void 0 : Ne.referenceHidden) && {
                        visibility: "hidden",
                        pointerEvents: "none"
                    }
                },
                dir: e.dir,
                children: b.jsx(CL, {
                    scope: n,
                    placedSide: se,
                    onArrowChange: D,
                    arrowX: K,
                    arrowY: ce,
                    shouldHideArrow: de,
                    children: b.jsx(tt.div, {
                        "data-side": se,
                        "data-align": ee,
                        ...w,
                        ref: R,
                        style: {
                            ...w.style,
                            animation: re ? void 0 : "none"
                        }
                    })
                })
            })
    }
);
lb.displayName = Tp;
var ub = "PopperArrow"
    , TL = {
    top: "bottom",
    right: "left",
    bottom: "top",
    left: "right"
}
    , cb = P.forwardRef(function(t, n) {
    const {__scopePopper: s, ...o} = t
        , u = PL(ub, s)
        , l = TL[u.placedSide];
    return b.jsx("span", {
        ref: u.onArrowChange,
        style: {
            position: "absolute",
            left: u.arrowX,
            top: u.arrowY,
            [l]: 0,
            transformOrigin: {
                top: "",
                right: "0 0",
                bottom: "center 0",
                left: "100% 0"
            }[u.placedSide],
            transform: {
                top: "translateY(100%)",
                right: "translateY(50%) rotate(90deg) translateX(-50%)",
                bottom: "rotate(180deg)",
                left: "translateY(50%) rotate(-90deg) translateX(50%)"
            }[u.placedSide],
            visibility: u.shouldHideArrow ? "hidden" : void 0
        },
        children: b.jsx(SL, {
            ...o,
            ref: n,
            style: {
                ...o.style,
                display: "block"
            }
        })
    })
});
cb.displayName = ub;
function kL(e) {
    return e !== null
}
var RL = e => ({
    name: "transformOrigin",
    options: e,
    fn(t) {
        var x, T, k;
        const {placement: n, rects: s, middlewareData: o} = t
            , l = ((x = o.arrow) == null ? void 0 : x.centerOffset) !== 0
            , d = l ? 0 : e.arrowWidth
            , f = l ? 0 : e.arrowHeight
            , [p,m] = db(n)
            , y = {
            start: "0%",
            center: "50%",
            end: "100%"
        }[m]
            , v = (((T = o.arrow) == null ? void 0 : T.x) ?? 0) + d / 2
            , S = (((k = o.arrow) == null ? void 0 : k.y) ?? 0) + f / 2;
        let E = ""
            , w = "";
        return p === "bottom" ? (E = l ? y : `${v}px`,
            w = `${-f}px`) : p === "top" ? (E = l ? y : `${v}px`,
            w = `${s.floating.height + f}px`) : p === "right" ? (E = `${-f}px`,
            w = l ? y : `${S}px`) : p === "left" && (E = `${s.floating.width + f}px`,
            w = l ? y : `${S}px`),
            {
                data: {
                    x: E,
                    y: w
                }
            }
    }
});
function db(e) {
    const [t,n="center"] = e.split("-");
    return [t, n]
}
var AL = ib
    , _L = ab
    , NL = lb
    , OL = cb
    , LL = "Portal"
    , fb = P.forwardRef( (e, t) => {
        var d;
        const {container: n, ...s} = e
            , [o,u] = P.useState(!1);
        zt( () => u(!0), []);
        const l = n || o && ((d = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : d.body);
        return l ? Uk.createPortal(b.jsx(tt.div, {
            ...s,
            ref: t
        }), l) : null
    }
);
fb.displayName = LL;
var ML = Jh[" useInsertionEffect ".trim().toString()] || zt;
function A0({prop: e, defaultProp: t, onChange: n= () => {}
                , caller: s}) {
    const [o,u,l] = jL({
        defaultProp: t,
        onChange: n
    })
        , d = e !== void 0
        , f = d ? e : o;
    {
        const m = P.useRef(e !== void 0);
        P.useEffect( () => {
                const y = m.current;
                y !== d && console.warn(`${s} is changing from ${y ? "controlled" : "uncontrolled"} to ${d ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`),
                    m.current = d
            }
            , [d, s])
    }
    const p = P.useCallback(m => {
            var y;
            if (d) {
                const v = DL(m) ? m(e) : m;
                v !== e && ((y = l.current) == null || y.call(l, v))
            } else
                u(m)
        }
        , [d, e, u, l]);
    return [f, p]
}
function jL({defaultProp: e, onChange: t}) {
    const [n,s] = P.useState(e)
        , o = P.useRef(n)
        , u = P.useRef(t);
    return ML( () => {
            u.current = t
        }
        , [t]),
        P.useEffect( () => {
                var l;
                o.current !== n && ((l = u.current) == null || l.call(u, n),
                    o.current = n)
            }
            , [n, o]),
        [n, s, u]
}
function DL(e) {
    return typeof e == "function"
}
function IL(e) {
    const t = P.useRef({
        value: e,
        previous: e
    });
    return P.useMemo( () => (t.current.value !== e && (t.current.previous = t.current.value,
        t.current.value = e),
        t.current.previous), [e])
}
var hb = Object.freeze({
    position: "absolute",
    border: 0,
    width: 1,
    height: 1,
    padding: 0,
    margin: -1,
    overflow: "hidden",
    clip: "rect(0, 0, 0, 0)",
    whiteSpace: "nowrap",
    wordWrap: "normal"
})
    , FL = "VisuallyHidden"
    , BL = P.forwardRef( (e, t) => b.jsx(tt.span, {
    ...e,
    ref: t,
    style: {
        ...hb,
        ...e.style
    }
}));
BL.displayName = FL;
var VL = function(e) {
    if (typeof document > "u")
        return null;
    var t = Array.isArray(e) ? e[0] : e;
    return t.ownerDocument.body
}
    , yi = new WeakMap
    , iu = new WeakMap
    , ou = {}
    , kf = 0
    , pb = function(e) {
    return e && (e.host || pb(e.parentNode))
}
    , UL = function(e, t) {
    return t.map(function(n) {
        if (e.contains(n))
            return n;
        var s = pb(n);
        return s && e.contains(s) ? s : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"),
            null)
    }).filter(function(n) {
        return !!n
    })
}
    , zL = function(e, t, n, s) {
    var o = UL(t, Array.isArray(e) ? e : [e]);
    ou[n] || (ou[n] = new WeakMap);
    var u = ou[n]
        , l = []
        , d = new Set
        , f = new Set(o)
        , p = function(y) {
        !y || d.has(y) || (d.add(y),
            p(y.parentNode))
    };
    o.forEach(p);
    var m = function(y) {
        !y || f.has(y) || Array.prototype.forEach.call(y.children, function(v) {
            if (d.has(v))
                m(v);
            else
                try {
                    var S = v.getAttribute(s)
                        , E = S !== null && S !== "false"
                        , w = (yi.get(v) || 0) + 1
                        , x = (u.get(v) || 0) + 1;
                    yi.set(v, w),
                        u.set(v, x),
                        l.push(v),
                    w === 1 && E && iu.set(v, !0),
                    x === 1 && v.setAttribute(n, "true"),
                    E || v.setAttribute(s, "true")
                } catch (T) {
                    console.error("aria-hidden: cannot operate on ", v, T)
                }
        })
    };
    return m(t),
        d.clear(),
        kf++,
        function() {
            l.forEach(function(y) {
                var v = yi.get(y) - 1
                    , S = u.get(y) - 1;
                yi.set(y, v),
                    u.set(y, S),
                v || (iu.has(y) || y.removeAttribute(s),
                    iu.delete(y)),
                S || y.removeAttribute(n)
            }),
                kf--,
            kf || (yi = new WeakMap,
                yi = new WeakMap,
                iu = new WeakMap,
                ou = {})
        }
}
    , $L = function(e, t, n) {
    n === void 0 && (n = "data-aria-hidden");
    var s = Array.from(Array.isArray(e) ? e : [e])
        , o = VL(e);
    return o ? (s.push.apply(s, Array.from(o.querySelectorAll("[aria-live], script"))),
        zL(s, o, n, "aria-hidden")) : function() {
        return null
    }
}
    , jn = function() {
    return jn = Object.assign || function(t) {
        for (var n, s = 1, o = arguments.length; s < o; s++) {
            n = arguments[s];
            for (var u in n)
                Object.prototype.hasOwnProperty.call(n, u) && (t[u] = n[u])
        }
        return t
    }
        ,
        jn.apply(this, arguments)
};
function mb(e, t) {
    var n = {};
    for (var s in e)
        Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
    if (e != null && typeof Object.getOwnPropertySymbols == "function")
        for (var o = 0, s = Object.getOwnPropertySymbols(e); o < s.length; o++)
            t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]]);
    return n
}
function WL(e, t, n) {
    if (n || arguments.length === 2)
        for (var s = 0, o = t.length, u; s < o; s++)
            (u || !(s in t)) && (u || (u = Array.prototype.slice.call(t, 0, s)),
                u[s] = t[s]);
    return e.concat(u || Array.prototype.slice.call(t))
}
var Eu = "right-scroll-bar-position"
    , Cu = "width-before-scroll-bar"
    , HL = "with-scroll-bars-hidden"
    , qL = "--removed-body-scroll-bar-size";
function Rf(e, t) {
    return typeof e == "function" ? e(t) : e && (e.current = t),
        e
}
function KL(e, t) {
    var n = P.useState(function() {
        return {
            value: e,
            callback: t,
            facade: {
                get current() {
                    return n.value
                },
                set current(s) {
                    var o = n.value;
                    o !== s && (n.value = s,
                        n.callback(s, o))
                }
            }
        }
    })[0];
    return n.callback = t,
        n.facade
}
var QL = typeof window < "u" ? P.useLayoutEffect : P.useEffect
    , _0 = new WeakMap;
function GL(e, t) {
    var n = KL(null, function(s) {
        return e.forEach(function(o) {
            return Rf(o, s)
        })
    });
    return QL(function() {
        var s = _0.get(n);
        if (s) {
            var o = new Set(s)
                , u = new Set(e)
                , l = n.current;
            o.forEach(function(d) {
                u.has(d) || Rf(d, null)
            }),
                u.forEach(function(d) {
                    o.has(d) || Rf(d, l)
                })
        }
        _0.set(n, e)
    }, [e]),
        n
}
function XL(e) {
    return e
}
function YL(e, t) {
    t === void 0 && (t = XL);
    var n = []
        , s = !1
        , o = {
        read: function() {
            if (s)
                throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
            return n.length ? n[n.length - 1] : e
        },
        useMedium: function(u) {
            var l = t(u, s);
            return n.push(l),
                function() {
                    n = n.filter(function(d) {
                        return d !== l
                    })
                }
        },
        assignSyncMedium: function(u) {
            for (s = !0; n.length; ) {
                var l = n;
                n = [],
                    l.forEach(u)
            }
            n = {
                push: function(d) {
                    return u(d)
                },
                filter: function() {
                    return n
                }
            }
        },
        assignMedium: function(u) {
            s = !0;
            var l = [];
            if (n.length) {
                var d = n;
                n = [],
                    d.forEach(u),
                    l = n
            }
            var f = function() {
                var m = l;
                l = [],
                    m.forEach(u)
            }
                , p = function() {
                return Promise.resolve().then(f)
            };
            p(),
                n = {
                    push: function(m) {
                        l.push(m),
                            p()
                    },
                    filter: function(m) {
                        return l = l.filter(m),
                            n
                    }
                }
        }
    };
    return o
}
function JL(e) {
    e === void 0 && (e = {});
    var t = YL(null);
    return t.options = jn({
        async: !0,
        ssr: !1
    }, e),
        t
}
var gb = function(e) {
    var t = e.sideCar
        , n = mb(e, ["sideCar"]);
    if (!t)
        throw new Error("Sidecar: please provide `sideCar` property to import the right car");
    var s = t.read();
    if (!s)
        throw new Error("Sidecar medium not found");
    return P.createElement(s, jn({}, n))
};
gb.isSideCarExport = !0;
function ZL(e, t) {
    return e.useMedium(t),
        gb
}
var yb = JL()
    , Af = function() {}
    , rc = P.forwardRef(function(e, t) {
    var n = P.useRef(null)
        , s = P.useState({
        onScrollCapture: Af,
        onWheelCapture: Af,
        onTouchMoveCapture: Af
    })
        , o = s[0]
        , u = s[1]
        , l = e.forwardProps
        , d = e.children
        , f = e.className
        , p = e.removeScrollBar
        , m = e.enabled
        , y = e.shards
        , v = e.sideCar
        , S = e.noRelative
        , E = e.noIsolation
        , w = e.inert
        , x = e.allowPinchZoom
        , T = e.as
        , k = T === void 0 ? "div" : T
        , R = e.gapMode
        , _ = mb(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"])
        , D = v
        , H = GL([n, t])
        , $ = jn(jn({}, _), o);
    return P.createElement(P.Fragment, null, m && P.createElement(D, {
        sideCar: yb,
        removeScrollBar: p,
        shards: y,
        noRelative: S,
        noIsolation: E,
        inert: w,
        setCallbacks: u,
        allowPinchZoom: !!x,
        lockRef: n,
        gapMode: R
    }), l ? P.cloneElement(P.Children.only(d), jn(jn({}, $), {
        ref: H
    })) : P.createElement(k, jn({}, $, {
        className: f,
        ref: H
    }), d))
});
rc.defaultProps = {
    enabled: !0,
    removeScrollBar: !0,
    inert: !1
};
rc.classNames = {
    fullWidth: Cu,
    zeroRight: Eu
};
var eM = function() {
    if (typeof __webpack_nonce__ < "u")
        return __webpack_nonce__
};
function tM() {
    if (!document)
        return null;
    var e = document.createElement("style");
    e.type = "text/css";
    var t = eM();
    return t && e.setAttribute("nonce", t),
        e
}
function nM(e, t) {
    e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t))
}
function rM(e) {
    var t = document.head || document.getElementsByTagName("head")[0];
    t.appendChild(e)
}
var sM = function() {
    var e = 0
        , t = null;
    return {
        add: function(n) {
            e == 0 && (t = tM()) && (nM(t, n),
                rM(t)),
                e++
        },
        remove: function() {
            e--,
            !e && t && (t.parentNode && t.parentNode.removeChild(t),
                t = null)
        }
    }
}
    , iM = function() {
    var e = sM();
    return function(t, n) {
        P.useEffect(function() {
            return e.add(t),
                function() {
                    e.remove()
                }
        }, [t && n])
    }
}
    , vb = function() {
    var e = iM()
        , t = function(n) {
        var s = n.styles
            , o = n.dynamic;
        return e(s, o),
            null
    };
    return t
}
    , oM = {
    left: 0,
    top: 0,
    right: 0,
    gap: 0
}
    , _f = function(e) {
    return parseInt(e || "", 10) || 0
}
    , aM = function(e) {
    var t = window.getComputedStyle(document.body)
        , n = t[e === "padding" ? "paddingLeft" : "marginLeft"]
        , s = t[e === "padding" ? "paddingTop" : "marginTop"]
        , o = t[e === "padding" ? "paddingRight" : "marginRight"];
    return [_f(n), _f(s), _f(o)]
}
    , lM = function(e) {
    if (e === void 0 && (e = "margin"),
    typeof window > "u")
        return oM;
    var t = aM(e)
        , n = document.documentElement.clientWidth
        , s = window.innerWidth;
    return {
        left: t[0],
        top: t[1],
        right: t[2],
        gap: Math.max(0, s - n + t[2] - t[0])
    }
}
    , uM = vb()
    , Ri = "data-scroll-locked"
    , cM = function(e, t, n, s) {
    var o = e.left
        , u = e.top
        , l = e.right
        , d = e.gap;
    return n === void 0 && (n = "margin"),
        `
  .`.concat(HL, ` {
   overflow: hidden `).concat(s, `;
   padding-right: `).concat(d, "px ").concat(s, `;
  }
  body[`).concat(Ri, `] {
    overflow: hidden `).concat(s, `;
    overscroll-behavior: contain;
    `).concat([t && "position: relative ".concat(s, ";"), n === "margin" && `
    padding-left: `.concat(o, `px;
    padding-top: `).concat(u, `px;
    padding-right: `).concat(l, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(d, "px ").concat(s, `;
    `), n === "padding" && "padding-right: ".concat(d, "px ").concat(s, ";")].filter(Boolean).join(""), `
  }
  
  .`).concat(Eu, ` {
    right: `).concat(d, "px ").concat(s, `;
  }
  
  .`).concat(Cu, ` {
    margin-right: `).concat(d, "px ").concat(s, `;
  }
  
  .`).concat(Eu, " .").concat(Eu, ` {
    right: 0 `).concat(s, `;
  }
  
  .`).concat(Cu, " .").concat(Cu, ` {
    margin-right: 0 `).concat(s, `;
  }
  
  body[`).concat(Ri, `] {
    `).concat(qL, ": ").concat(d, `px;
  }
`)
}
    , N0 = function() {
    var e = parseInt(document.body.getAttribute(Ri) || "0", 10);
    return isFinite(e) ? e : 0
}
    , dM = function() {
    P.useEffect(function() {
        return document.body.setAttribute(Ri, (N0() + 1).toString()),
            function() {
                var e = N0() - 1;
                e <= 0 ? document.body.removeAttribute(Ri) : document.body.setAttribute(Ri, e.toString())
            }
    }, [])
}
    , fM = function(e) {
    var t = e.noRelative
        , n = e.noImportant
        , s = e.gapMode
        , o = s === void 0 ? "margin" : s;
    dM();
    var u = P.useMemo(function() {
        return lM(o)
    }, [o]);
    return P.createElement(uM, {
        styles: cM(u, !t, o, n ? "" : "!important")
    })
}
    , Ph = !1;
if (typeof window < "u")
    try {
        var au = Object.defineProperty({}, "passive", {
            get: function() {
                return Ph = !0,
                    !0
            }
        });
        window.addEventListener("test", au, au),
            window.removeEventListener("test", au, au)
    } catch {
        Ph = !1
    }
var vi = Ph ? {
    passive: !1
} : !1
    , hM = function(e) {
    return e.tagName === "TEXTAREA"
}
    , wb = function(e, t) {
    if (!(e instanceof Element))
        return !1;
    var n = window.getComputedStyle(e);
    return n[t] !== "hidden" && !(n.overflowY === n.overflowX && !hM(e) && n[t] === "visible")
}
    , pM = function(e) {
    return wb(e, "overflowY")
}
    , mM = function(e) {
    return wb(e, "overflowX")
}
    , O0 = function(e, t) {
    var n = t.ownerDocument
        , s = t;
    do {
        typeof ShadowRoot < "u" && s instanceof ShadowRoot && (s = s.host);
        var o = xb(e, s);
        if (o) {
            var u = Sb(e, s)
                , l = u[1]
                , d = u[2];
            if (l > d)
                return !0
        }
        s = s.parentNode
    } while (s && s !== n.body);
    return !1
}
    , gM = function(e) {
    var t = e.scrollTop
        , n = e.scrollHeight
        , s = e.clientHeight;
    return [t, n, s]
}
    , yM = function(e) {
    var t = e.scrollLeft
        , n = e.scrollWidth
        , s = e.clientWidth;
    return [t, n, s]
}
    , xb = function(e, t) {
    return e === "v" ? pM(t) : mM(t)
}
    , Sb = function(e, t) {
    return e === "v" ? gM(t) : yM(t)
}
    , vM = function(e, t) {
    return e === "h" && t === "rtl" ? -1 : 1
}
    , wM = function(e, t, n, s, o) {
    var u = vM(e, window.getComputedStyle(t).direction)
        , l = u * s
        , d = n.target
        , f = t.contains(d)
        , p = !1
        , m = l > 0
        , y = 0
        , v = 0;
    do {
        if (!d)
            break;
        var S = Sb(e, d)
            , E = S[0]
            , w = S[1]
            , x = S[2]
            , T = w - x - u * E;
        (E || T) && xb(e, d) && (y += T,
            v += E);
        var k = d.parentNode;
        d = k && k.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? k.host : k
    } while (!f && d !== document.body || f && (t.contains(d) || t === d));
    return (m && Math.abs(y) < 1 || !m && Math.abs(v) < 1) && (p = !0),
        p
}
    , lu = function(e) {
    return "changedTouches"in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0]
}
    , L0 = function(e) {
    return [e.deltaX, e.deltaY]
}
    , M0 = function(e) {
    return e && "current"in e ? e.current : e
}
    , xM = function(e, t) {
    return e[0] === t[0] && e[1] === t[1]
}
    , SM = function(e) {
    return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`)
}
    , bM = 0
    , wi = [];
function EM(e) {
    var t = P.useRef([])
        , n = P.useRef([0, 0])
        , s = P.useRef()
        , o = P.useState(bM++)[0]
        , u = P.useState(vb)[0]
        , l = P.useRef(e);
    P.useEffect(function() {
        l.current = e
    }, [e]),
        P.useEffect(function() {
            if (e.inert) {
                document.body.classList.add("block-interactivity-".concat(o));
                var w = WL([e.lockRef.current], (e.shards || []).map(M0), !0).filter(Boolean);
                return w.forEach(function(x) {
                    return x.classList.add("allow-interactivity-".concat(o))
                }),
                    function() {
                        document.body.classList.remove("block-interactivity-".concat(o)),
                            w.forEach(function(x) {
                                return x.classList.remove("allow-interactivity-".concat(o))
                            })
                    }
            }
        }, [e.inert, e.lockRef.current, e.shards]);
    var d = P.useCallback(function(w, x) {
        if ("touches"in w && w.touches.length === 2 || w.type === "wheel" && w.ctrlKey)
            return !l.current.allowPinchZoom;
        var T = lu(w), k = n.current, R = "deltaX"in w ? w.deltaX : k[0] - T[0], _ = "deltaY"in w ? w.deltaY : k[1] - T[1], D, H = w.target, $ = Math.abs(R) > Math.abs(_) ? "h" : "v";
        if ("touches"in w && $ === "h" && H.type === "range")
            return !1;
        var O = O0($, H);
        if (!O)
            return !0;
        if (O ? D = $ : (D = $ === "v" ? "h" : "v",
            O = O0($, H)),
            !O)
            return !1;
        if (!s.current && "changedTouches"in w && (R || _) && (s.current = D),
            !D)
            return !0;
        var W = s.current || D;
        return wM(W, x, w, W === "h" ? R : _)
    }, [])
        , f = P.useCallback(function(w) {
        var x = w;
        if (!(!wi.length || wi[wi.length - 1] !== u)) {
            var T = "deltaY"in x ? L0(x) : lu(x)
                , k = t.current.filter(function(D) {
                return D.name === x.type && (D.target === x.target || x.target === D.shadowParent) && xM(D.delta, T)
            })[0];
            if (k && k.should) {
                x.cancelable && x.preventDefault();
                return
            }
            if (!k) {
                var R = (l.current.shards || []).map(M0).filter(Boolean).filter(function(D) {
                    return D.contains(x.target)
                })
                    , _ = R.length > 0 ? d(x, R[0]) : !l.current.noIsolation;
                _ && x.cancelable && x.preventDefault()
            }
        }
    }, [])
        , p = P.useCallback(function(w, x, T, k) {
        var R = {
            name: w,
            delta: x,
            target: T,
            should: k,
            shadowParent: CM(T)
        };
        t.current.push(R),
            setTimeout(function() {
                t.current = t.current.filter(function(_) {
                    return _ !== R
                })
            }, 1)
    }, [])
        , m = P.useCallback(function(w) {
        n.current = lu(w),
            s.current = void 0
    }, [])
        , y = P.useCallback(function(w) {
        p(w.type, L0(w), w.target, d(w, e.lockRef.current))
    }, [])
        , v = P.useCallback(function(w) {
        p(w.type, lu(w), w.target, d(w, e.lockRef.current))
    }, []);
    P.useEffect(function() {
        return wi.push(u),
            e.setCallbacks({
                onScrollCapture: y,
                onWheelCapture: y,
                onTouchMoveCapture: v
            }),
            document.addEventListener("wheel", f, vi),
            document.addEventListener("touchmove", f, vi),
            document.addEventListener("touchstart", m, vi),
            function() {
                wi = wi.filter(function(w) {
                    return w !== u
                }),
                    document.removeEventListener("wheel", f, vi),
                    document.removeEventListener("touchmove", f, vi),
                    document.removeEventListener("touchstart", m, vi)
            }
    }, []);
    var S = e.removeScrollBar
        , E = e.inert;
    return P.createElement(P.Fragment, null, E ? P.createElement(u, {
        styles: SM(o)
    }) : null, S ? P.createElement(fM, {
        noRelative: e.noRelative,
        gapMode: e.gapMode
    }) : null)
}
function CM(e) {
    for (var t = null; e !== null; )
        e instanceof ShadowRoot && (t = e.host,
            e = e.host),
            e = e.parentNode;
    return t
}
const PM = ZL(yb, EM);
var bb = P.forwardRef(function(e, t) {
    return P.createElement(rc, jn({}, e, {
        ref: t,
        sideCar: PM
    }))
});
bb.classNames = rc.classNames;
var TM = [" ", "Enter", "ArrowUp", "ArrowDown"]
    , kM = [" ", "Enter"]
    , Bs = "Select"
    , [sc,ic,RM] = UN(Bs)
    , [no] = yp(Bs, [RM, rb])
    , oc = rb()
    , [AM,ts] = no(Bs)
    , [_M,NM] = no(Bs)
    , Eb = e => {
        const {__scopeSelect: t, children: n, open: s, defaultOpen: o, onOpenChange: u, value: l, defaultValue: d, onValueChange: f, dir: p, name: m, autoComplete: y, disabled: v, required: S, form: E} = e
            , w = oc(t)
            , [x,T] = P.useState(null)
            , [k,R] = P.useState(null)
            , [_,D] = P.useState(!1)
            , H = $N(p)
            , [$,O] = A0({
            prop: s,
            defaultProp: o ?? !1,
            onChange: u,
            caller: Bs
        })
            , [W,q] = A0({
            prop: l,
            defaultProp: d,
            onChange: f,
            caller: Bs
        })
            , X = P.useRef(null)
            , z = x ? E || !!x.closest("form") : !0
            , [J,ae] = P.useState(new Set)
            , ie = Array.from(J).map(ne => ne.props.value).join(";");
        return b.jsx(AL, {
            ...w,
            children: b.jsxs(AM, {
                required: S,
                scope: t,
                trigger: x,
                onTriggerChange: T,
                valueNode: k,
                onValueNodeChange: R,
                valueNodeHasChildren: _,
                onValueNodeHasChildrenChange: D,
                contentId: vp(),
                value: W,
                onValueChange: q,
                open: $,
                onOpenChange: O,
                dir: H,
                triggerPointerDownPosRef: X,
                disabled: v,
                children: [b.jsx(sc.Provider, {
                    scope: t,
                    children: b.jsx(_M, {
                        scope: e.__scopeSelect,
                        onNativeOptionAdd: P.useCallback(ne => {
                                ae(re => new Set(re).add(ne))
                            }
                            , []),
                        onNativeOptionRemove: P.useCallback(ne => {
                                ae(re => {
                                        const I = new Set(re);
                                        return I.delete(ne),
                                            I
                                    }
                                )
                            }
                            , []),
                        children: n
                    })
                }), z ? b.jsxs(Kb, {
                    "aria-hidden": !0,
                    required: S,
                    tabIndex: -1,
                    name: m,
                    autoComplete: y,
                    value: W,
                    onChange: ne => q(ne.target.value),
                    disabled: v,
                    form: E,
                    children: [W === void 0 ? b.jsx("option", {
                        value: ""
                    }) : null, Array.from(J)]
                }, ie) : null]
            })
        })
    }
;
Eb.displayName = Bs;
var Cb = "SelectTrigger"
    , Pb = P.forwardRef( (e, t) => {
        const {__scopeSelect: n, disabled: s=!1, ...o} = e
            , u = oc(n)
            , l = ts(Cb, n)
            , d = l.disabled || s
            , f = wt(t, l.onTriggerChange)
            , p = ic(n)
            , m = P.useRef("touch")
            , [y,v,S] = Gb(w => {
                    const x = p().filter(R => !R.disabled)
                        , T = x.find(R => R.value === l.value)
                        , k = Xb(x, w, T);
                    k !== void 0 && l.onValueChange(k.value)
                }
            )
            , E = w => {
                d || (l.onOpenChange(!0),
                    S()),
                w && (l.triggerPointerDownPosRef.current = {
                    x: Math.round(w.pageX),
                    y: Math.round(w.pageY)
                })
            }
        ;
        return b.jsx(_L, {
            asChild: !0,
            ...u,
            children: b.jsx(tt.button, {
                type: "button",
                role: "combobox",
                "aria-controls": l.contentId,
                "aria-expanded": l.open,
                "aria-required": l.required,
                "aria-autocomplete": "none",
                dir: l.dir,
                "data-state": l.open ? "open" : "closed",
                disabled: d,
                "data-disabled": d ? "" : void 0,
                "data-placeholder": Qb(l.value) ? "" : void 0,
                ...o,
                ref: f,
                onClick: rt(o.onClick, w => {
                        w.currentTarget.focus(),
                        m.current !== "mouse" && E(w)
                    }
                ),
                onPointerDown: rt(o.onPointerDown, w => {
                        m.current = w.pointerType;
                        const x = w.target;
                        x.hasPointerCapture(w.pointerId) && x.releasePointerCapture(w.pointerId),
                        w.button === 0 && w.ctrlKey === !1 && w.pointerType === "mouse" && (E(w),
                            w.preventDefault())
                    }
                ),
                onKeyDown: rt(o.onKeyDown, w => {
                        const x = y.current !== "";
                        !(w.ctrlKey || w.altKey || w.metaKey) && w.key.length === 1 && v(w.key),
                        !(x && w.key === " ") && TM.includes(w.key) && (E(),
                            w.preventDefault())
                    }
                )
            })
        })
    }
);
Pb.displayName = Cb;
var Tb = "SelectValue"
    , kb = P.forwardRef( (e, t) => {
        const {__scopeSelect: n, className: s, style: o, children: u, placeholder: l="", ...d} = e
            , f = ts(Tb, n)
            , {onValueNodeHasChildrenChange: p} = f
            , m = u !== void 0
            , y = wt(t, f.onValueNodeChange);
        return zt( () => {
                p(m)
            }
            , [p, m]),
            b.jsx(tt.span, {
                ...d,
                ref: y,
                style: {
                    pointerEvents: "none"
                },
                children: Qb(f.value) ? b.jsx(b.Fragment, {
                    children: l
                }) : u
            })
    }
);
kb.displayName = Tb;
var OM = "SelectIcon"
    , Rb = P.forwardRef( (e, t) => {
        const {__scopeSelect: n, children: s, ...o} = e;
        return b.jsx(tt.span, {
            "aria-hidden": !0,
            ...o,
            ref: t,
            children: s || ""
        })
    }
);
Rb.displayName = OM;
var LM = "SelectPortal"
    , Ab = e => b.jsx(fb, {
    asChild: !0,
    ...e
});
Ab.displayName = LM;
var Vs = "SelectContent"
    , _b = P.forwardRef( (e, t) => {
        const n = ts(Vs, e.__scopeSelect)
            , [s,o] = P.useState();
        if (zt( () => {
                o(new DocumentFragment)
            }
            , []),
            !n.open) {
            const u = s;
            return u ? Aa.createPortal(b.jsx(Nb, {
                scope: e.__scopeSelect,
                children: b.jsx(sc.Slot, {
                    scope: e.__scopeSelect,
                    children: b.jsx("div", {
                        children: e.children
                    })
                })
            }), u) : null
        }
        return b.jsx(Ob, {
            ...e,
            ref: t
        })
    }
);
_b.displayName = Vs;
var yn = 10
    , [Nb,ns] = no(Vs)
    , MM = "SelectContentImpl"
    , jM = ma("SelectContent.RemoveScroll")
    , Ob = P.forwardRef( (e, t) => {
        const {__scopeSelect: n, position: s="item-aligned", onCloseAutoFocus: o, onEscapeKeyDown: u, onPointerDownOutside: l, side: d, sideOffset: f, align: p, alignOffset: m, arrowPadding: y, collisionBoundary: v, collisionPadding: S, sticky: E, hideWhenDetached: w, avoidCollisions: x, ...T} = e
            , k = ts(Vs, n)
            , [R,_] = P.useState(null)
            , [D,H] = P.useState(null)
            , $ = wt(t, Z => _(Z))
            , [O,W] = P.useState(null)
            , [q,X] = P.useState(null)
            , z = ic(n)
            , [J,ae] = P.useState(!1)
            , ie = P.useRef(!1);
        P.useEffect( () => {
                if (R)
                    return $L(R)
            }
            , [R]),
            eO();
        const ne = P.useCallback(Z => {
                const [ye,...Ce] = z().map(Ne => Ne.ref.current)
                    , [Pe] = Ce.slice(-1)
                    , _e = document.activeElement;
                for (const Ne of Z)
                    if (Ne === _e || (Ne == null || Ne.scrollIntoView({
                        block: "nearest"
                    }),
                    Ne === ye && D && (D.scrollTop = 0),
                    Ne === Pe && D && (D.scrollTop = D.scrollHeight),
                    Ne == null || Ne.focus(),
                    document.activeElement !== _e))
                        return
            }
            , [z, D])
            , re = P.useCallback( () => ne([O, R]), [ne, O, R]);
        P.useEffect( () => {
                J && re()
            }
            , [J, re]);
        const {onOpenChange: I, triggerPointerDownPosRef: se} = k;
        P.useEffect( () => {
                if (R) {
                    let Z = {
                        x: 0,
                        y: 0
                    };
                    const ye = Pe => {
                            var _e, Ne;
                            Z = {
                                x: Math.abs(Math.round(Pe.pageX) - (((_e = se.current) == null ? void 0 : _e.x) ?? 0)),
                                y: Math.abs(Math.round(Pe.pageY) - (((Ne = se.current) == null ? void 0 : Ne.y) ?? 0))
                            }
                        }
                        , Ce = Pe => {
                            Z.x <= 10 && Z.y <= 10 ? Pe.preventDefault() : R.contains(Pe.target) || I(!1),
                                document.removeEventListener("pointermove", ye),
                                se.current = null
                        }
                    ;
                    return se.current !== null && (document.addEventListener("pointermove", ye),
                        document.addEventListener("pointerup", Ce, {
                            capture: !0,
                            once: !0
                        })),
                        () => {
                            document.removeEventListener("pointermove", ye),
                                document.removeEventListener("pointerup", Ce, {
                                    capture: !0
                                })
                        }
                }
            }
            , [R, I, se]),
            P.useEffect( () => {
                    const Z = () => I(!1);
                    return window.addEventListener("blur", Z),
                        window.addEventListener("resize", Z),
                        () => {
                            window.removeEventListener("blur", Z),
                                window.removeEventListener("resize", Z)
                        }
                }
                , [I]);
        const [ee,j] = Gb(Z => {
                const ye = z().filter(_e => !_e.disabled)
                    , Ce = ye.find(_e => _e.ref.current === document.activeElement)
                    , Pe = Xb(ye, Z, Ce);
                Pe && setTimeout( () => Pe.ref.current.focus())
            }
        )
            , K = P.useCallback( (Z, ye, Ce) => {
                const Pe = !ie.current && !Ce;
                (k.value !== void 0 && k.value === ye || Pe) && (W(Z),
                Pe && (ie.current = !0))
            }
            , [k.value])
            , ce = P.useCallback( () => R == null ? void 0 : R.focus(), [R])
            , de = P.useCallback( (Z, ye, Ce) => {
                const Pe = !ie.current && !Ce;
                (k.value !== void 0 && k.value === ye || Pe) && X(Z)
            }
            , [k.value])
            , be = s === "popper" ? Th : Lb
            , Te = be === Th ? {
            side: d,
            sideOffset: f,
            align: p,
            alignOffset: m,
            arrowPadding: y,
            collisionBoundary: v,
            collisionPadding: S,
            sticky: E,
            hideWhenDetached: w,
            avoidCollisions: x
        } : {};
        return b.jsx(Nb, {
            scope: n,
            content: R,
            viewport: D,
            onViewportChange: H,
            itemRefCallback: K,
            selectedItem: O,
            onItemLeave: ce,
            itemTextRefCallback: de,
            focusSelectedItem: re,
            selectedItemText: q,
            position: s,
            isPositioned: J,
            searchRef: ee,
            children: b.jsx(bb, {
                as: jM,
                allowPinchZoom: !0,
                children: b.jsx(zS, {
                    asChild: !0,
                    trapped: k.open,
                    onMountAutoFocus: Z => {
                        Z.preventDefault()
                    }
                    ,
                    onUnmountAutoFocus: rt(o, Z => {
                            var ye;
                            (ye = k.trigger) == null || ye.focus({
                                preventScroll: !0
                            }),
                                Z.preventDefault()
                        }
                    ),
                    children: b.jsx(VS, {
                        asChild: !0,
                        disableOutsidePointerEvents: !0,
                        onEscapeKeyDown: u,
                        onPointerDownOutside: l,
                        onFocusOutside: Z => Z.preventDefault(),
                        onDismiss: () => k.onOpenChange(!1),
                        children: b.jsx(be, {
                            role: "listbox",
                            id: k.contentId,
                            "data-state": k.open ? "open" : "closed",
                            dir: k.dir,
                            onContextMenu: Z => Z.preventDefault(),
                            ...T,
                            ...Te,
                            onPlaced: () => ae(!0),
                            ref: $,
                            style: {
                                display: "flex",
                                flexDirection: "column",
                                outline: "none",
                                ...T.style
                            },
                            onKeyDown: rt(T.onKeyDown, Z => {
                                    const ye = Z.ctrlKey || Z.altKey || Z.metaKey;
                                    if (Z.key === "Tab" && Z.preventDefault(),
                                    !ye && Z.key.length === 1 && j(Z.key),
                                        ["ArrowUp", "ArrowDown", "Home", "End"].includes(Z.key)) {
                                        let Pe = z().filter(_e => !_e.disabled).map(_e => _e.ref.current);
                                        if (["ArrowUp", "End"].includes(Z.key) && (Pe = Pe.slice().reverse()),
                                            ["ArrowUp", "ArrowDown"].includes(Z.key)) {
                                            const _e = Z.target
                                                , Ne = Pe.indexOf(_e);
                                            Pe = Pe.slice(Ne + 1)
                                        }
                                        setTimeout( () => ne(Pe)),
                                            Z.preventDefault()
                                    }
                                }
                            )
                        })
                    })
                })
            })
        })
    }
);
Ob.displayName = MM;
var DM = "SelectItemAlignedPosition"
    , Lb = P.forwardRef( (e, t) => {
        const {__scopeSelect: n, onPlaced: s, ...o} = e
            , u = ts(Vs, n)
            , l = ns(Vs, n)
            , [d,f] = P.useState(null)
            , [p,m] = P.useState(null)
            , y = wt(t, $ => m($))
            , v = ic(n)
            , S = P.useRef(!1)
            , E = P.useRef(!0)
            , {viewport: w, selectedItem: x, selectedItemText: T, focusSelectedItem: k} = l
            , R = P.useCallback( () => {
                if (u.trigger && u.valueNode && d && p && w && x && T) {
                    const $ = u.trigger.getBoundingClientRect()
                        , O = p.getBoundingClientRect()
                        , W = u.valueNode.getBoundingClientRect()
                        , q = T.getBoundingClientRect();
                    if (u.dir !== "rtl") {
                        const _e = q.left - O.left
                            , Ne = W.left - _e
                            , ut = $.left - Ne
                            , Nt = $.width + ut
                            , cr = Math.max(Nt, O.width)
                            , dr = window.innerWidth - yn
                            , Hn = u0(Ne, [yn, Math.max(yn, dr - cr)]);
                        d.style.minWidth = Nt + "px",
                            d.style.left = Hn + "px"
                    } else {
                        const _e = O.right - q.right
                            , Ne = window.innerWidth - W.right - _e
                            , ut = window.innerWidth - $.right - Ne
                            , Nt = $.width + ut
                            , cr = Math.max(Nt, O.width)
                            , dr = window.innerWidth - yn
                            , Hn = u0(Ne, [yn, Math.max(yn, dr - cr)]);
                        d.style.minWidth = Nt + "px",
                            d.style.right = Hn + "px"
                    }
                    const X = v()
                        , z = window.innerHeight - yn * 2
                        , J = w.scrollHeight
                        , ae = window.getComputedStyle(p)
                        , ie = parseInt(ae.borderTopWidth, 10)
                        , ne = parseInt(ae.paddingTop, 10)
                        , re = parseInt(ae.borderBottomWidth, 10)
                        , I = parseInt(ae.paddingBottom, 10)
                        , se = ie + ne + J + I + re
                        , ee = Math.min(x.offsetHeight * 5, se)
                        , j = window.getComputedStyle(w)
                        , K = parseInt(j.paddingTop, 10)
                        , ce = parseInt(j.paddingBottom, 10)
                        , de = $.top + $.height / 2 - yn
                        , be = z - de
                        , Te = x.offsetHeight / 2
                        , Z = x.offsetTop + Te
                        , ye = ie + ne + Z
                        , Ce = se - ye;
                    if (ye <= de) {
                        const _e = X.length > 0 && x === X[X.length - 1].ref.current;
                        d.style.bottom = "0px";
                        const Ne = p.clientHeight - w.offsetTop - w.offsetHeight
                            , ut = Math.max(be, Te + (_e ? ce : 0) + Ne + re)
                            , Nt = ye + ut;
                        d.style.height = Nt + "px"
                    } else {
                        const _e = X.length > 0 && x === X[0].ref.current;
                        d.style.top = "0px";
                        const ut = Math.max(de, ie + w.offsetTop + (_e ? K : 0) + Te) + Ce;
                        d.style.height = ut + "px",
                            w.scrollTop = ye - de + w.offsetTop
                    }
                    d.style.margin = `${yn}px 0`,
                        d.style.minHeight = ee + "px",
                        d.style.maxHeight = z + "px",
                    s == null || s(),
                        requestAnimationFrame( () => S.current = !0)
                }
            }
            , [v, u.trigger, u.valueNode, d, p, w, x, T, u.dir, s]);
        zt( () => R(), [R]);
        const [_,D] = P.useState();
        zt( () => {
                p && D(window.getComputedStyle(p).zIndex)
            }
            , [p]);
        const H = P.useCallback($ => {
                $ && E.current === !0 && (R(),
                k == null || k(),
                    E.current = !1)
            }
            , [R, k]);
        return b.jsx(FM, {
            scope: n,
            contentWrapper: d,
            shouldExpandOnScrollRef: S,
            onScrollButtonChange: H,
            children: b.jsx("div", {
                ref: f,
                style: {
                    display: "flex",
                    flexDirection: "column",
                    position: "fixed",
                    zIndex: _
                },
                children: b.jsx(tt.div, {
                    ...o,
                    ref: y,
                    style: {
                        boxSizing: "border-box",
                        maxHeight: "100%",
                        ...o.style
                    }
                })
            })
        })
    }
);
Lb.displayName = DM;
var IM = "SelectPopperPosition"
    , Th = P.forwardRef( (e, t) => {
        const {__scopeSelect: n, align: s="start", collisionPadding: o=yn, ...u} = e
            , l = oc(n);
        return b.jsx(NL, {
            ...l,
            ...u,
            ref: t,
            align: s,
            collisionPadding: o,
            style: {
                boxSizing: "border-box",
                ...u.style,
                "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
                "--radix-select-content-available-width": "var(--radix-popper-available-width)",
                "--radix-select-content-available-height": "var(--radix-popper-available-height)",
                "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
                "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
            }
        })
    }
);
Th.displayName = IM;
var [FM,kp] = no(Vs, {})
    , kh = "SelectViewport"
    , Mb = P.forwardRef( (e, t) => {
        const {__scopeSelect: n, nonce: s, ...o} = e
            , u = ns(kh, n)
            , l = kp(kh, n)
            , d = wt(t, u.onViewportChange)
            , f = P.useRef(0);
        return b.jsxs(b.Fragment, {
            children: [b.jsx("style", {
                dangerouslySetInnerHTML: {
                    __html: "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}"
                },
                nonce: s
            }), b.jsx(sc.Slot, {
                scope: n,
                children: b.jsx(tt.div, {
                    "data-radix-select-viewport": "",
                    role: "presentation",
                    ...o,
                    ref: d,
                    style: {
                        position: "relative",
                        flex: 1,
                        overflow: "hidden auto",
                        ...o.style
                    },
                    onScroll: rt(o.onScroll, p => {
                            const m = p.currentTarget
                                , {contentWrapper: y, shouldExpandOnScrollRef: v} = l;
                            if (v != null && v.current && y) {
                                const S = Math.abs(f.current - m.scrollTop);
                                if (S > 0) {
                                    const E = window.innerHeight - yn * 2
                                        , w = parseFloat(y.style.minHeight)
                                        , x = parseFloat(y.style.height)
                                        , T = Math.max(w, x);
                                    if (T < E) {
                                        const k = T + S
                                            , R = Math.min(E, k)
                                            , _ = k - R;
                                        y.style.height = R + "px",
                                        y.style.bottom === "0px" && (m.scrollTop = _ > 0 ? _ : 0,
                                            y.style.justifyContent = "flex-end")
                                    }
                                }
                            }
                            f.current = m.scrollTop
                        }
                    )
                })
            })]
        })
    }
);
Mb.displayName = kh;
var jb = "SelectGroup"
    , [BM,VM] = no(jb)
    , UM = P.forwardRef( (e, t) => {
        const {__scopeSelect: n, ...s} = e
            , o = vp();
        return b.jsx(BM, {
            scope: n,
            id: o,
            children: b.jsx(tt.div, {
                role: "group",
                "aria-labelledby": o,
                ...s,
                ref: t
            })
        })
    }
);
UM.displayName = jb;
var Db = "SelectLabel"
    , Ib = P.forwardRef( (e, t) => {
        const {__scopeSelect: n, ...s} = e
            , o = VM(Db, n);
        return b.jsx(tt.div, {
            id: o.id,
            ...s,
            ref: t
        })
    }
);
Ib.displayName = Db;
var Iu = "SelectItem"
    , [zM,Fb] = no(Iu)
    , Bb = P.forwardRef( (e, t) => {
        const {__scopeSelect: n, value: s, disabled: o=!1, textValue: u, ...l} = e
            , d = ts(Iu, n)
            , f = ns(Iu, n)
            , p = d.value === s
            , [m,y] = P.useState(u ?? "")
            , [v,S] = P.useState(!1)
            , E = wt(t, k => {
                    var R;
                    return (R = f.itemRefCallback) == null ? void 0 : R.call(f, k, s, o)
                }
            )
            , w = vp()
            , x = P.useRef("touch")
            , T = () => {
                o || (d.onValueChange(s),
                    d.onOpenChange(!1))
            }
        ;
        if (s === "")
            throw new Error("A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.");
        return b.jsx(zM, {
            scope: n,
            value: s,
            disabled: o,
            textId: w,
            isSelected: p,
            onItemTextChange: P.useCallback(k => {
                    y(R => R || ((k == null ? void 0 : k.textContent) ?? "").trim())
                }
                , []),
            children: b.jsx(sc.ItemSlot, {
                scope: n,
                value: s,
                disabled: o,
                textValue: m,
                children: b.jsx(tt.div, {
                    role: "option",
                    "aria-labelledby": w,
                    "data-highlighted": v ? "" : void 0,
                    "aria-selected": p && v,
                    "data-state": p ? "checked" : "unchecked",
                    "aria-disabled": o || void 0,
                    "data-disabled": o ? "" : void 0,
                    tabIndex: o ? void 0 : -1,
                    ...l,
                    ref: E,
                    onFocus: rt(l.onFocus, () => S(!0)),
                    onBlur: rt(l.onBlur, () => S(!1)),
                    onClick: rt(l.onClick, () => {
                            x.current !== "mouse" && T()
                        }
                    ),
                    onPointerUp: rt(l.onPointerUp, () => {
                            x.current === "mouse" && T()
                        }
                    ),
                    onPointerDown: rt(l.onPointerDown, k => {
                            x.current = k.pointerType
                        }
                    ),
                    onPointerMove: rt(l.onPointerMove, k => {
                            var R;
                            x.current = k.pointerType,
                                o ? (R = f.onItemLeave) == null || R.call(f) : x.current === "mouse" && k.currentTarget.focus({
                                    preventScroll: !0
                                })
                        }
                    ),
                    onPointerLeave: rt(l.onPointerLeave, k => {
                            var R;
                            k.currentTarget === document.activeElement && ((R = f.onItemLeave) == null || R.call(f))
                        }
                    ),
                    onKeyDown: rt(l.onKeyDown, k => {
                            var _;
                            ((_ = f.searchRef) == null ? void 0 : _.current) !== "" && k.key === " " || (kM.includes(k.key) && T(),
                            k.key === " " && k.preventDefault())
                        }
                    )
                })
            })
        })
    }
);
Bb.displayName = Iu;
var Jo = "SelectItemText"
    , Vb = P.forwardRef( (e, t) => {
        const {__scopeSelect: n, className: s, style: o, ...u} = e
            , l = ts(Jo, n)
            , d = ns(Jo, n)
            , f = Fb(Jo, n)
            , p = NM(Jo, n)
            , [m,y] = P.useState(null)
            , v = wt(t, T => y(T), f.onItemTextChange, T => {
                var k;
                return (k = d.itemTextRefCallback) == null ? void 0 : k.call(d, T, f.value, f.disabled)
            }
        )
            , S = m == null ? void 0 : m.textContent
            , E = P.useMemo( () => b.jsx("option", {
            value: f.value,
            disabled: f.disabled,
            children: S
        }, f.value), [f.disabled, f.value, S])
            , {onNativeOptionAdd: w, onNativeOptionRemove: x} = p;
        return zt( () => (w(E),
            () => x(E)), [w, x, E]),
            b.jsxs(b.Fragment, {
                children: [b.jsx(tt.span, {
                    id: f.textId,
                    ...u,
                    ref: v
                }), f.isSelected && l.valueNode && !l.valueNodeHasChildren ? Aa.createPortal(u.children, l.valueNode) : null]
            })
    }
);
Vb.displayName = Jo;
var Ub = "SelectItemIndicator"
    , zb = P.forwardRef( (e, t) => {
        const {__scopeSelect: n, ...s} = e;
        return Fb(Ub, n).isSelected ? b.jsx(tt.span, {
            "aria-hidden": !0,
            ...s,
            ref: t
        }) : null
    }
);
zb.displayName = Ub;
var Rh = "SelectScrollUpButton"
    , $b = P.forwardRef( (e, t) => {
        const n = ns(Rh, e.__scopeSelect)
            , s = kp(Rh, e.__scopeSelect)
            , [o,u] = P.useState(!1)
            , l = wt(t, s.onScrollButtonChange);
        return zt( () => {
                if (n.viewport && n.isPositioned) {
                    let d = function() {
                        const p = f.scrollTop > 0;
                        u(p)
                    };
                    const f = n.viewport;
                    return d(),
                        f.addEventListener("scroll", d),
                        () => f.removeEventListener("scroll", d)
                }
            }
            , [n.viewport, n.isPositioned]),
            o ? b.jsx(Hb, {
                ...e,
                ref: l,
                onAutoScroll: () => {
                    const {viewport: d, selectedItem: f} = n;
                    d && f && (d.scrollTop = d.scrollTop - f.offsetHeight)
                }
            }) : null
    }
);
$b.displayName = Rh;
var Ah = "SelectScrollDownButton"
    , Wb = P.forwardRef( (e, t) => {
        const n = ns(Ah, e.__scopeSelect)
            , s = kp(Ah, e.__scopeSelect)
            , [o,u] = P.useState(!1)
            , l = wt(t, s.onScrollButtonChange);
        return zt( () => {
                if (n.viewport && n.isPositioned) {
                    let d = function() {
                        const p = f.scrollHeight - f.clientHeight
                            , m = Math.ceil(f.scrollTop) < p;
                        u(m)
                    };
                    const f = n.viewport;
                    return d(),
                        f.addEventListener("scroll", d),
                        () => f.removeEventListener("scroll", d)
                }
            }
            , [n.viewport, n.isPositioned]),
            o ? b.jsx(Hb, {
                ...e,
                ref: l,
                onAutoScroll: () => {
                    const {viewport: d, selectedItem: f} = n;
                    d && f && (d.scrollTop = d.scrollTop + f.offsetHeight)
                }
            }) : null
    }
);
Wb.displayName = Ah;
var Hb = P.forwardRef( (e, t) => {
        const {__scopeSelect: n, onAutoScroll: s, ...o} = e
            , u = ns("SelectScrollButton", n)
            , l = P.useRef(null)
            , d = ic(n)
            , f = P.useCallback( () => {
                l.current !== null && (window.clearInterval(l.current),
                    l.current = null)
            }
            , []);
        return P.useEffect( () => () => f(), [f]),
            zt( () => {
                    var m;
                    const p = d().find(y => y.ref.current === document.activeElement);
                    (m = p == null ? void 0 : p.ref.current) == null || m.scrollIntoView({
                        block: "nearest"
                    })
                }
                , [d]),
            b.jsx(tt.div, {
                "aria-hidden": !0,
                ...o,
                ref: t,
                style: {
                    flexShrink: 0,
                    ...o.style
                },
                onPointerDown: rt(o.onPointerDown, () => {
                        l.current === null && (l.current = window.setInterval(s, 50))
                    }
                ),
                onPointerMove: rt(o.onPointerMove, () => {
                        var p;
                        (p = u.onItemLeave) == null || p.call(u),
                        l.current === null && (l.current = window.setInterval(s, 50))
                    }
                ),
                onPointerLeave: rt(o.onPointerLeave, () => {
                        f()
                    }
                )
            })
    }
)
    , $M = "SelectSeparator"
    , qb = P.forwardRef( (e, t) => {
        const {__scopeSelect: n, ...s} = e;
        return b.jsx(tt.div, {
            "aria-hidden": !0,
            ...s,
            ref: t
        })
    }
);
qb.displayName = $M;
var _h = "SelectArrow"
    , WM = P.forwardRef( (e, t) => {
        const {__scopeSelect: n, ...s} = e
            , o = oc(n)
            , u = ts(_h, n)
            , l = ns(_h, n);
        return u.open && l.position === "popper" ? b.jsx(OL, {
            ...o,
            ...s,
            ref: t
        }) : null
    }
);
WM.displayName = _h;
var HM = "SelectBubbleInput"
    , Kb = P.forwardRef( ({__scopeSelect: e, value: t, ...n}, s) => {
        const o = P.useRef(null)
            , u = wt(s, o)
            , l = IL(t);
        return P.useEffect( () => {
                const d = o.current;
                if (!d)
                    return;
                const f = window.HTMLSelectElement.prototype
                    , m = Object.getOwnPropertyDescriptor(f, "value").set;
                if (l !== t && m) {
                    const y = new Event("change",{
                        bubbles: !0
                    });
                    m.call(d, t),
                        d.dispatchEvent(y)
                }
            }
            , [l, t]),
            b.jsx(tt.select, {
                ...n,
                style: {
                    ...hb,
                    ...n.style
                },
                ref: u,
                defaultValue: t
            })
    }
);
Kb.displayName = HM;
function Qb(e) {
    return e === "" || e === void 0
}
function Gb(e) {
    const t = Is(e)
        , n = P.useRef("")
        , s = P.useRef(0)
        , o = P.useCallback(l => {
            const d = n.current + l;
            t(d),
                (function f(p) {
                        n.current = p,
                            window.clearTimeout(s.current),
                        p !== "" && (s.current = window.setTimeout( () => f(""), 1e3))
                    }
                )(d)
        }
        , [t])
        , u = P.useCallback( () => {
            n.current = "",
                window.clearTimeout(s.current)
        }
        , []);
    return P.useEffect( () => () => window.clearTimeout(s.current), []),
        [n, o, u]
}
function Xb(e, t, n) {
    const o = t.length > 1 && Array.from(t).every(p => p === t[0]) ? t[0] : t
        , u = n ? e.indexOf(n) : -1;
    let l = qM(e, Math.max(u, 0));
    o.length === 1 && (l = l.filter(p => p !== n));
    const f = l.find(p => p.textValue.toLowerCase().startsWith(o.toLowerCase()));
    return f !== n ? f : void 0
}
function qM(e, t) {
    return e.map( (n, s) => e[(t + s) % e.length])
}
var KM = Eb
    , Yb = Pb
    , QM = kb
    , GM = Rb
    , XM = Ab
    , Jb = _b
    , YM = Mb
    , Zb = Ib
    , e1 = Bb
    , JM = Vb
    , ZM = zb
    , t1 = $b
    , n1 = Wb
    , r1 = qb;
const s1 = KM
    , i1 = QM
    , Rp = P.forwardRef( ({className: e, children: t, ...n}, s) => b.jsxs(Yb, {
    ref: s,
    className: Ze("flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background data-[placeholder]:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1", e),
    ...n,
    children: [t, b.jsx(GM, {
        asChild: !0,
        children: b.jsx(cx, {
            className: "h-4 w-4 opacity-50"
        })
    })]
}));
Rp.displayName = Yb.displayName;
const o1 = P.forwardRef( ({className: e, ...t}, n) => b.jsx(t1, {
    ref: n,
    className: Ze("flex cursor-default items-center justify-center py-1", e),
    ...t,
    children: b.jsx(oT, {
        className: "h-4 w-4"
    })
}));
o1.displayName = t1.displayName;
const a1 = P.forwardRef( ({className: e, ...t}, n) => b.jsx(n1, {
    ref: n,
    className: Ze("flex cursor-default items-center justify-center py-1", e),
    ...t,
    children: b.jsx(cx, {
        className: "h-4 w-4"
    })
}));
a1.displayName = n1.displayName;
const Ap = P.forwardRef( ({className: e, children: t, position: n="popper", ...s}, o) => b.jsx(XM, {
    children: b.jsxs(Jb, {
        ref: o,
        className: Ze("relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2", n === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1", e),
        position: n,
        ...s,
        children: [b.jsx(o1, {}), b.jsx(YM, {
            className: Ze("p-1", n === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"),
            children: t
        }), b.jsx(a1, {})]
    })
}));
Ap.displayName = Jb.displayName;
const e2 = P.forwardRef( ({className: e, ...t}, n) => b.jsx(Zb, {
    ref: n,
    className: Ze("px-2 py-1.5 text-sm font-semibold", e),
    ...t
}));
e2.displayName = Zb.displayName;
const sa = P.forwardRef( ({className: e, children: t, ...n}, s) => b.jsxs(e1, {
    ref: s,
    className: Ze("relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50", e),
    ...n,
    children: [b.jsx("span", {
        className: "absolute right-2 flex h-3.5 w-3.5 items-center justify-center",
        children: b.jsx(ZM, {
            children: b.jsx(rT, {
                className: "h-4 w-4"
            })
        })
    }), b.jsx(JM, {
        children: t
    })]
}));
sa.displayName = e1.displayName;
const t2 = P.forwardRef( ({className: e, ...t}, n) => b.jsx(r1, {
    ref: n,
    className: Ze("-mx-1 my-1 h-px bg-muted", e),
    ...t
}));
t2.displayName = r1.displayName;
const ac = {
    en: {
        premiumQuality: "Premium Quality Adhesives",
        ourInventory: "Our Product Inventory",
        falcofixRange: "Falcofix Product Range",
        falcofixWR: "Falcofix WR",
        falcofixUM: "Falcofix Ultra Marine",
        falcofixEBS: "Falcofix EBS",
        falcofixWRGold: "Falcofix WR Gold",
        threeMProducts: "3M Products",
        otherProducts: "Other Products",
        browseInventory: "Browse our complete inventory of industrial-grade adhesive solutions.",
        industrialGrade: "Industrial-grade adhesive solutions for all your bonding needs. Available in various pack sizes.",
        selectSize: "Select a size below to view pricing and product details.",
        allBrands: "All Brands",
        all: "All",
        viewDetails: "View Details",
        sizes: "Sizes",
        size: "Size",
        selectSizeLabel: "Select Size",
        productDetails: "Product Details",
        weight: "Weight",
        productType: "Product Type",
        brand: "Brand",
        keyFeatures: "Key Features",
        highQuality: "High-quality industrial adhesive",
        strongBonding: "Strong bonding performance",
        variousApplications: "Suitable for various applications",
        trustedProfessionals: "Trusted by professionals",
        whatsappInquiry: "WhatsApp Inquiry",
        callNow: "Call Now",
        needHelp: "Need Help?",
        contactForPricing: "Contact us for pricing, bulk orders, or any questions about this product.",
        availableOnWhatsApp: "Available on WhatsApp",
        availableSizes: "Available Sizes",
        backToProducts: "Back to Products",
        productNotFound: "Product not found",
        noProducts: "No products found",
        comingSoon: "Coming soon! Products will be added shortly.",
        viewAllProducts: "View All Products",
        yearsExperience: "Years Experience",
        happyClients: "Happy Clients",
        productVariants: "Product Variants",
        qualityAssured: "Quality Assured",
        contactUs: "Contact Us",
        siddharthaMarketing: "Siddhartha Marketing",
        since: "Since 1995",
        qualitySolutions: "Quality Adhesive Solutions",
        trustedPartner: "Your trusted partner for premium quality Falcofix adhesive products. Serving businesses across Maharashtra with excellence.",
        contactInformation: "Contact Information",
        getInTouch: "Get in Touch",
        haveQuestions: "Have questions about our products? We're here to help!",
        chatOnWhatsApp: "Chat on WhatsApp",
        allRightsReserved: "All rights reserved"
    },
    hi: {
        premiumQuality: "   ",
        ourInventory: "  ",
        falcofixRange: "  ",
        falcofixWR: " WR",
        falcofixUM: "  ",
        falcofixEBS: " EBS",
        falcofixWRGold: " WR ",
        threeMProducts: "3M ",
        otherProducts: " ",
        browseInventory: "-         ",
        industrialGrade: "      -        ",
        selectSize: "          ",
        allBrands: " ",
        all: "",
        viewDetails: " ",
        sizes: "",
        size: "",
        selectSizeLabel: " ",
        productDetails: " ",
        weight: "",
        productType: " ",
        brand: "",
        keyFeatures: " ",
        highQuality: "     ",
        strongBonding: "  ",
        variousApplications: "    ",
        trustedProfessionals: "  ",
        whatsappInquiry: " ",
        callNow: "  ",
        needHelp: " ?",
        contactForPricing: ",  ,              ",
        availableOnWhatsApp: "  ",
        availableSizes: " ",
        backToProducts: "   ",
        productNotFound: "  ",
        noProducts: "   ",
        comingSoon: "   !     ",
        viewAllProducts: "  ",
        yearsExperience: "  ",
        happyClients: " ",
        productVariants: " ",
        qualityAssured: " ",
        contactUs: " ",
        siddharthaMarketing: " ",
        since: "1995 ",
        qualitySolutions: "   ",
        trustedPartner: "                    ",
        contactInformation: " ",
        getInTouch: "  ",
        haveQuestions: "      ?      !",
        chatOnWhatsApp: "   ",
        allRightsReserved: " "
    },
    mr: {
        premiumQuality: "  ",
        ourInventory: "  ",
        falcofixRange: "  ",
        falcofixWR: " WR",
        falcofixUM: "  ",
        falcofixEBS: " EBS",
        falcofixWRGold: " WR ",
        threeMProducts: "3M ",
        otherProducts: " ",
        browseInventory: "-      ",
        industrialGrade: "    -      ",
        selectSize: "       ",
        allBrands: " ",
        all: "",
        viewDetails: " ",
        sizes: "",
        size: "",
        selectSizeLabel: " ",
        productDetails: " ",
        weight: "",
        productType: " ",
        brand: "",
        keyFeatures: " ",
        highQuality: "-  ",
        strongBonding: "  ",
        variousApplications: "  ",
        trustedProfessionals: " ",
        whatsappInquiry: " ",
        callNow: "  ",
        needHelp: "  ?",
        contactForPricing: ",           ",
        availableOnWhatsApp: " ",
        availableSizes: " ",
        backToProducts: "  ",
        productNotFound: "  ",
        noProducts: "   ",
        comingSoon: "  !    ",
        viewAllProducts: "  ",
        yearsExperience: " ",
        happyClients: " ",
        productVariants: " ",
        qualityAssured: " ",
        contactUs: "  ",
        siddharthaMarketing: " ",
        since: "1995 ",
        qualitySolutions: "  ",
        trustedPartner: "             ",
        contactInformation: " ",
        getInTouch: " ",
        haveQuestions: "   ?    !",
        chatOnWhatsApp: "  ",
        allRightsReserved: "  "
    }
};
function Nh() {
    const [e,t] = P.useState( () => localStorage.getItem("language") || "en");
    P.useEffect( () => {
            localStorage.setItem("language", e),
                window.dispatchEvent(new Event("languageChange"))
        }
        , [e]);
    const n = ac[e];
    return b.jsxs("header", {
        className: "sticky top-0 z-50 bg-white/95 backdrop-blur-md border-b border-slate-100",
        children: [b.jsx("div", {
            className: "bg-blue-900 text-white py-2",
            children: b.jsxs("div", {
                className: "max-w-7xl mx-auto px-4 flex flex-wrap justify-center md:justify-between items-center gap-2 text-xs md:text-sm",
                children: [b.jsxs("div", {
                    className: "flex items-center gap-4 md:gap-6",
                    children: [b.jsxs("a", {
                        href: "tel:+919422163831",
                        className: "flex items-center gap-1.5 hover:text-blue-300 transition-colors",
                        children: [b.jsx(ca, {
                            className: "w-3.5 h-3.5"
                        }), b.jsx("span", {
                            children: "+91 94221 63831"
                        })]
                    }), b.jsxs("a", {
                        href: "mailto:mankashyam@gmail.com",
                        className: "flex items-center gap-1.5 hover:text-blue-300 transition-colors",
                        children: [b.jsx(dx, {
                            className: "w-3.5 h-3.5"
                        }), b.jsx("span", {
                            className: "hidden sm:inline",
                            children: "mankashyam@gmail.com"
                        })]
                    })]
                }), b.jsxs("div", {
                    className: "flex items-center gap-1.5 text-slate-300",
                    children: [b.jsx(fx, {
                        className: "w-3.5 h-3.5"
                    }), b.jsx("span", {
                        className: "hidden md:inline",
                        children: "53, GMD Market, Ranpise Nagar, Akola 444001"
                    }), b.jsx("span", {
                        className: "md:hidden",
                        children: "Akola, Maharashtra"
                    })]
                })]
            })
        }), b.jsx("div", {
            className: "max-w-7xl mx-auto px-4 py-4 md:py-6",
            children: b.jsxs("div", {
                className: "flex items-center justify-between",
                children: [b.jsxs("div", {
                    className: "flex items-center gap-3",
                    children: [b.jsx("div", {
                        className: "w-12 h-12 md:w-14 md:h-14 bg-gradient-to-br from-blue-600 to-blue-700 rounded-xl flex items-center justify-center shadow-lg shadow-blue-200",
                        children: b.jsx("span", {
                            className: "text-white font-bold text-xl md:text-2xl",
                            children: "S"
                        })
                    }), b.jsxs("div", {
                        children: [b.jsx("h1", {
                            className: "text-xl md:text-2xl font-bold text-slate-900 tracking-tight",
                            children: n.siddharthaMarketing
                        }), b.jsx("p", {
                            className: "text-xs md:text-sm text-slate-500 font-medium",
                            children: n.qualitySolutions
                        })]
                    })]
                }), b.jsxs("div", {
                    className: "flex items-center gap-3",
                    children: [b.jsxs(s1, {
                        value: e,
                        onValueChange: t,
                        children: [b.jsxs(Rp, {
                            className: "w-[100px] h-9 border-slate-200",
                            children: [b.jsx(cT, {
                                className: "w-4 h-4 mr-1"
                            }), b.jsx(i1, {})]
                        }), b.jsxs(Ap, {
                            children: [b.jsx(sa, {
                                value: "en",
                                children: "English"
                            }), b.jsx(sa, {
                                value: "hi",
                                children: ""
                            }), b.jsx(sa, {
                                value: "mr",
                                children: ""
                            })]
                        })]
                    }), b.jsxs("a", {
                        href: "https://wa.me/919422163831?text=Hi, I'm interested in your Falcofix products. Please share more details.",
                        target: "_blank",
                        rel: "noopener noreferrer",
                        className: "hidden md:flex items-center gap-2 bg-blue-600 hover:bg-blue-700 text-white px-5 py-2.5 rounded-xl font-medium transition-all duration-300 shadow-lg shadow-blue-200 hover:shadow-blue-300",
                        children: [b.jsx(ca, {
                            className: "w-4 h-4"
                        }), n.contactUs]
                    })]
                })]
            })
        })]
    })
}
function Oh() {
    const [e,t] = P.useState(localStorage.getItem("language") || "en");
    P.useEffect( () => {
            const s = () => {
                    t(localStorage.getItem("language") || "en")
                }
            ;
            return window.addEventListener("languageChange", s),
                () => window.removeEventListener("languageChange", s)
        }
        , []);
    const n = ac[e];
    return b.jsx("footer", {
        className: "bg-blue-900 text-white mt-16",
        children: b.jsxs("div", {
            className: "max-w-7xl mx-auto px-4 py-12 md:py-16",
            children: [b.jsxs("div", {
                className: "grid grid-cols-1 md:grid-cols-3 gap-10 md:gap-8",
                children: [b.jsxs("div", {
                    className: "space-y-4",
                    children: [b.jsxs("div", {
                        className: "flex items-center gap-3",
                        children: [b.jsx("div", {
                            className: "w-12 h-12 bg-gradient-to-br from-blue-500 to-blue-600 rounded-xl flex items-center justify-center",
                            children: b.jsx("span", {
                                className: "text-white font-bold text-xl",
                                children: "S"
                            })
                        }), b.jsxs("div", {
                            children: [b.jsx("h3", {
                                className: "text-xl font-bold",
                                children: n.siddharthaMarketing
                            }), b.jsx("p", {
                                className: "text-sm text-slate-400",
                                children: n.since
                            })]
                        })]
                    }), b.jsx("p", {
                        className: "text-slate-400 text-sm leading-relaxed",
                        children: n.trustedPartner
                    })]
                }), b.jsxs("div", {
                    className: "space-y-4",
                    children: [b.jsx("h4", {
                        className: "text-lg font-semibold",
                        children: n.contactInformation
                    }), b.jsxs("div", {
                        className: "space-y-3",
                        children: [b.jsxs("a", {
                            href: "tel:+919422163831",
                            className: "flex items-center gap-3 text-slate-300 hover:text-blue-300 transition-colors",
                            children: [b.jsx(ca, {
                                className: "w-5 h-5"
                            }), b.jsx("span", {
                                children: "+91 94221 63831"
                            })]
                        }), b.jsxs("a", {
                            href: "mailto:mankashyam@gmail.com",
                            className: "flex items-center gap-3 text-slate-300 hover:text-blue-300 transition-colors",
                            children: [b.jsx(dx, {
                                className: "w-5 h-5"
                            }), b.jsx("span", {
                                children: "mankashyam@gmail.com"
                            })]
                        }), b.jsxs("div", {
                            className: "flex items-start gap-3 text-slate-300",
                            children: [b.jsx(fx, {
                                className: "w-5 h-5 mt-0.5 flex-shrink-0"
                            }), b.jsxs("span", {
                                children: ["53, GMD Market, Ranpise Nagar,", b.jsx("br", {}), "Akola 444001, Maharashtra"]
                            })]
                        })]
                    })]
                }), b.jsxs("div", {
                    className: "space-y-4",
                    children: [b.jsx("h4", {
                        className: "text-lg font-semibold",
                        children: n.getInTouch
                    }), b.jsx("p", {
                        className: "text-slate-400 text-sm",
                        children: n.haveQuestions
                    }), b.jsxs("a", {
                        href: "https://wa.me/919422163831?text=Hi, I'm interested in your Falcofix products. Please share more details.",
                        target: "_blank",
                        rel: "noopener noreferrer",
                        className: "inline-flex items-center gap-2 bg-green-600 hover:bg-green-700 text-white px-6 py-3 rounded-xl font-medium transition-all duration-300",
                        children: [b.jsx(Ru, {
                            className: "w-5 h-5"
                        }), n.chatOnWhatsApp]
                    })]
                })]
            }), b.jsx("div", {
                className: "border-t border-slate-800 mt-10 pt-8 text-center text-slate-400 text-sm",
                children: b.jsxs("p", {
                    children: [" ", new Date().getFullYear(), " ", n.siddharthaMarketing, ". ", n.allRightsReserved, "."]
                })
            })]
        })
    })
}
function Ai(e) {
    return "/" + e.replace(/ /g, "-")
}
const Ir = P.forwardRef( ({className: e, ...t}, n) => b.jsx("div", {
    ref: n,
    className: Ze("rounded-xl border bg-card text-card-foreground shadow", e),
    ...t
}));
Ir.displayName = "Card";
const n2 = P.forwardRef( ({className: e, ...t}, n) => b.jsx("div", {
    ref: n,
    className: Ze("flex flex-col space-y-1.5 p-6", e),
    ...t
}));
n2.displayName = "CardHeader";
const r2 = P.forwardRef( ({className: e, ...t}, n) => b.jsx("div", {
    ref: n,
    className: Ze("font-semibold leading-none tracking-tight", e),
    ...t
}));
r2.displayName = "CardTitle";
const s2 = P.forwardRef( ({className: e, ...t}, n) => b.jsx("div", {
    ref: n,
    className: Ze("text-sm text-muted-foreground", e),
    ...t
}));
s2.displayName = "CardDescription";
const i2 = P.forwardRef( ({className: e, ...t}, n) => b.jsx("div", {
    ref: n,
    className: Ze("p-6 pt-0", e),
    ...t
}));
i2.displayName = "CardContent";
const o2 = P.forwardRef( ({className: e, ...t}, n) => b.jsx("div", {
    ref: n,
    className: Ze("flex items-center p-6 pt-0", e),
    ...t
}));
o2.displayName = "CardFooter";
const a2 = Zh("inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2", {
    variants: {
        variant: {
            default: "border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80",
            secondary: "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
            destructive: "border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80",
            outline: "text-foreground"
        }
    },
    defaultVariants: {
        variant: "default"
    }
});
function ia({className: e, variant: t, ...n}) {
    return b.jsx("div", {
        className: Ze(a2({
            variant: t
        }), e),
        ...n
    })
}
const l2 = Zh("inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0", {
    variants: {
        variant: {
            default: "bg-primary text-primary-foreground shadow hover:bg-primary/90",
            destructive: "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
            outline: "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
            secondary: "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
            ghost: "hover:bg-accent hover:text-accent-foreground",
            link: "text-primary underline-offset-4 hover:underline"
        },
        size: {
            default: "h-9 px-4 py-2",
            sm: "h-8 rounded-md px-3 text-xs",
            lg: "h-10 rounded-md px-8",
            icon: "h-9 w-9"
        }
    },
    defaultVariants: {
        variant: "default",
        size: "default"
    }
})
    , In = P.forwardRef( ({className: e, variant: t, size: n, asChild: s=!1, ...o}, u) => {
        const l = s ? jN : "button";
        return b.jsx(l, {
            className: Ze(l2({
                variant: t,
                size: n,
                className: e
            })),
            ref: u,
            ...o
        })
    }
);
In.displayName = "Button";
const _p = P.createContext(null);
function u2(e) {
    const t = P.useRef(null);
    return t.current === null && (t.current = e()),
        t.current
}
const l1 = P.createContext({
    transformPagePoint: e => e,
    isStatic: !1,
    reducedMotion: "never"
})
    , u1 = P.createContext({})
    , Gt = e => e;
let c1 = Gt;
function Np(e) {
    let t;
    return () => (t === void 0 && (t = e()),
        t)
}
const Wi = (e, t, n) => {
    const s = t - e;
    return s === 0 ? 1 : (n - e) / s
}
    , ir = e => e * 1e3
    , or = e => e / 1e3
    , Op = typeof window < "u"
    , c2 = Op ? P.useLayoutEffect : P.useEffect
    , d2 = {
    useManualTiming: !1
};
function f2(e) {
    let t = new Set
        , n = new Set
        , s = !1
        , o = !1;
    const u = new WeakSet;
    let l = {
        delta: 0,
        timestamp: 0,
        isProcessing: !1
    };
    function d(p) {
        u.has(p) && (f.schedule(p),
            e()),
            p(l)
    }
    const f = {
        schedule: (p, m=!1, y=!1) => {
            const S = y && s ? t : n;
            return m && u.add(p),
            S.has(p) || S.add(p),
                p
        }
        ,
        cancel: p => {
            n.delete(p),
                u.delete(p)
        }
        ,
        process: p => {
            if (l = p,
                s) {
                o = !0;
                return
            }
            s = !0,
                [t,n] = [n, t],
                t.forEach(d),
                t.clear(),
                s = !1,
            o && (o = !1,
                f.process(p))
        }
    };
    return f
}
const uu = ["read", "resolveKeyframes", "update", "preRender", "render", "postRender"]
    , h2 = 40;
function d1(e, t) {
    let n = !1
        , s = !0;
    const o = {
            delta: 0,
            timestamp: 0,
            isProcessing: !1
        }
        , u = () => n = !0
        , l = uu.reduce( (T, k) => (T[k] = f2(u),
            T), {})
        , {read: d, resolveKeyframes: f, update: p, preRender: m, render: y, postRender: v} = l
        , S = () => {
            const T = performance.now();
            n = !1,
                o.delta = s ? 1e3 / 60 : Math.max(Math.min(T - o.timestamp, h2), 1),
                o.timestamp = T,
                o.isProcessing = !0,
                d.process(o),
                f.process(o),
                p.process(o),
                m.process(o),
                y.process(o),
                v.process(o),
                o.isProcessing = !1,
            n && t && (s = !1,
                e(S))
        }
        , E = () => {
            n = !0,
                s = !0,
            o.isProcessing || e(S)
        }
    ;
    return {
        schedule: uu.reduce( (T, k) => {
                const R = l[k];
                return T[k] = (_, D=!1, H=!1) => (n || E(),
                    R.schedule(_, D, H)),
                    T
            }
            , {}),
        cancel: T => {
            for (let k = 0; k < uu.length; k++)
                l[uu[k]].cancel(T)
        }
        ,
        state: o,
        steps: l
    }
}
const {schedule: ze, cancel: Zr, state: yt, steps: Nf} = d1(typeof requestAnimationFrame < "u" ? requestAnimationFrame : Gt, !0)
    , f1 = P.createContext({
    strict: !1
})
    , j0 = {
    animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"]
}
    , Hi = {};
for (const e in j0)
    Hi[e] = {
        isEnabled: t => j0[e].some(n => !!t[n])
    };
function p2(e) {
    for (const t in e)
        Hi[t] = {
            ...Hi[t],
            ...e[t]
        }
}
const m2 = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]);
function Fu(e) {
    return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || m2.has(e)
}
let h1 = e => !Fu(e);
function g2(e) {
    e && (h1 = t => t.startsWith("on") ? !Fu(t) : e(t))
}
try {
    g2(require("@emotion/is-prop-valid").default)
} catch {}
function y2(e, t, n) {
    const s = {};
    for (const o in e)
        o === "values" && typeof e.values == "object" || (h1(o) || n === !0 && Fu(o) || !t && !Fu(o) || e.draggable && o.startsWith("onDrag")) && (s[o] = e[o]);
    return s
}
function v2(e) {
    if (typeof Proxy > "u")
        return e;
    const t = new Map
        , n = (...s) => e(...s);
    return new Proxy(n,{
        get: (s, o) => o === "create" ? e : (t.has(o) || t.set(o, e(o)),
            t.get(o))
    })
}
const lc = P.createContext({});
function va(e) {
    return typeof e == "string" || Array.isArray(e)
}
function uc(e) {
    return e !== null && typeof e == "object" && typeof e.start == "function"
}
const Lp = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"]
    , Mp = ["initial", ...Lp];
function cc(e) {
    return uc(e.animate) || Mp.some(t => va(e[t]))
}
function p1(e) {
    return !!(cc(e) || e.variants)
}
function w2(e, t) {
    if (cc(e)) {
        const {initial: n, animate: s} = e;
        return {
            initial: n === !1 || va(n) ? n : void 0,
            animate: va(s) ? s : void 0
        }
    }
    return e.inherit !== !1 ? t : {}
}
function x2(e) {
    const {initial: t, animate: n} = w2(e, P.useContext(lc));
    return P.useMemo( () => ({
        initial: t,
        animate: n
    }), [D0(t), D0(n)])
}
function D0(e) {
    return Array.isArray(e) ? e.join(" ") : e
}
const S2 = Symbol.for("motionComponentSymbol");
function Si(e) {
    return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current")
}
function b2(e, t, n) {
    return P.useCallback(s => {
            s && e.mount && e.mount(s),
            t && (s ? t.mount(s) : t.unmount()),
            n && (typeof n == "function" ? n(s) : Si(n) && (n.current = s))
        }
        , [t])
}
const jp = e => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase()
    , E2 = "framerAppearId"
    , m1 = "data-" + jp(E2)
    , {schedule: Dp} = d1(queueMicrotask, !1)
    , g1 = P.createContext({});
function C2(e, t, n, s, o) {
    var u, l;
    const {visualElement: d} = P.useContext(lc)
        , f = P.useContext(f1)
        , p = P.useContext(_p)
        , m = P.useContext(l1).reducedMotion
        , y = P.useRef(null);
    s = s || f.renderer,
    !y.current && s && (y.current = s(e, {
        visualState: t,
        parent: d,
        props: n,
        presenceContext: p,
        blockInitialAnimation: p ? p.initial === !1 : !1,
        reducedMotionConfig: m
    }));
    const v = y.current
        , S = P.useContext(g1);
    v && !v.projection && o && (v.type === "html" || v.type === "svg") && P2(y.current, n, o, S);
    const E = P.useRef(!1);
    P.useInsertionEffect( () => {
            v && E.current && v.update(n, p)
        }
    );
    const w = n[m1]
        , x = P.useRef(!!w && !(!((u = window.MotionHandoffIsComplete) === null || u === void 0) && u.call(window, w)) && ((l = window.MotionHasOptimisedAnimation) === null || l === void 0 ? void 0 : l.call(window, w)));
    return c2( () => {
            v && (E.current = !0,
                window.MotionIsMounted = !0,
                v.updateFeatures(),
                Dp.render(v.render),
            x.current && v.animationState && v.animationState.animateChanges())
        }
    ),
        P.useEffect( () => {
                v && (!x.current && v.animationState && v.animationState.animateChanges(),
                x.current && (queueMicrotask( () => {
                        var T;
                        (T = window.MotionHandoffMarkAsComplete) === null || T === void 0 || T.call(window, w)
                    }
                ),
                    x.current = !1))
            }
        ),
        v
}
function P2(e, t, n, s) {
    const {layoutId: o, layout: u, drag: l, dragConstraints: d, layoutScroll: f, layoutRoot: p} = t;
    e.projection = new n(e.latestValues,t["data-framer-portal-id"] ? void 0 : y1(e.parent)),
        e.projection.setOptions({
            layoutId: o,
            layout: u,
            alwaysMeasureLayout: !!l || d && Si(d),
            visualElement: e,
            animationType: typeof u == "string" ? u : "both",
            initialPromotionConfig: s,
            layoutScroll: f,
            layoutRoot: p
        })
}
function y1(e) {
    if (e)
        return e.options.allowProjection !== !1 ? e.projection : y1(e.parent)
}
function T2({preloadedFeatures: e, createVisualElement: t, useRender: n, useVisualState: s, Component: o}) {
    var u, l;
    e && p2(e);
    function d(p, m) {
        let y;
        const v = {
            ...P.useContext(l1),
            ...p,
            layoutId: k2(p)
        }
            , {isStatic: S} = v
            , E = x2(p)
            , w = s(p, S);
        if (!S && Op) {
            R2();
            const x = A2(v);
            y = x.MeasureLayout,
                E.visualElement = C2(o, w, v, t, x.ProjectionNode)
        }
        return b.jsxs(lc.Provider, {
            value: E,
            children: [y && E.visualElement ? b.jsx(y, {
                visualElement: E.visualElement,
                ...v
            }) : null, n(o, p, b2(w, E.visualElement, m), w, S, E.visualElement)]
        })
    }
    d.displayName = `motion.${typeof o == "string" ? o : `create(${(l = (u = o.displayName) !== null && u !== void 0 ? u : o.name) !== null && l !== void 0 ? l : ""})`}`;
    const f = P.forwardRef(d);
    return f[S2] = o,
        f
}
function k2({layoutId: e}) {
    const t = P.useContext(u1).id;
    return t && e !== void 0 ? t + "-" + e : e
}
function R2(e, t) {
    P.useContext(f1).strict
}
function A2(e) {
    const {drag: t, layout: n} = Hi;
    if (!t && !n)
        return {};
    const s = {
        ...t,
        ...n
    };
    return {
        MeasureLayout: t != null && t.isEnabled(e) || n != null && n.isEnabled(e) ? s.MeasureLayout : void 0,
        ProjectionNode: s.ProjectionNode
    }
}
const _2 = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];
function Ip(e) {
    return typeof e != "string" || e.includes("-") ? !1 : !!(_2.indexOf(e) > -1 || /[A-Z]/u.test(e))
}
function v1(e, {style: t, vars: n}, s, o) {
    Object.assign(e.style, t, o && o.getProjectionStyles(s));
    for (const u in n)
        e.style.setProperty(u, n[u])
}
const w1 = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);
function x1(e, t, n, s) {
    v1(e, t, void 0, s);
    for (const o in t.attrs)
        e.setAttribute(w1.has(o) ? o : jp(o), t.attrs[o])
}
const Tt = e => !!(e && e.getVelocity)
    , Bu = {};
function N2(e) {
    Object.assign(Bu, e)
}
const Da = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"]
    , $s = new Set(Da);
function S1(e, {layout: t, layoutId: n}) {
    return $s.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!Bu[e] || e === "opacity")
}
function Fp(e, t, n) {
    var s;
    const {style: o} = e
        , u = {};
    for (const l in o)
        (Tt(o[l]) || t.style && Tt(t.style[l]) || S1(l, e) || ((s = n == null ? void 0 : n.getValue(l)) === null || s === void 0 ? void 0 : s.liveStyle) !== void 0) && (u[l] = o[l]);
    return u
}
function b1(e, t, n) {
    const s = Fp(e, t, n);
    for (const o in e)
        if (Tt(e[o]) || Tt(t[o])) {
            const u = Da.indexOf(o) !== -1 ? "attr" + o.charAt(0).toUpperCase() + o.substring(1) : o;
            s[u] = e[o]
        }
    return s
}
function I0(e) {
    const t = [{}, {}];
    return e == null || e.values.forEach( (n, s) => {
            t[0][s] = n.get(),
                t[1][s] = n.getVelocity()
        }
    ),
        t
}
function Bp(e, t, n, s) {
    if (typeof t == "function") {
        const [o,u] = I0(s);
        t = t(n !== void 0 ? n : e.custom, o, u)
    }
    if (typeof t == "string" && (t = e.variants && e.variants[t]),
    typeof t == "function") {
        const [o,u] = I0(s);
        t = t(n !== void 0 ? n : e.custom, o, u)
    }
    return t
}
const Lh = e => Array.isArray(e)
    , O2 = e => !!(e && typeof e == "object" && e.mix && e.toValue)
    , L2 = e => Lh(e) ? e[e.length - 1] || 0 : e;
function Pu(e) {
    const t = Tt(e) ? e.get() : e;
    return O2(t) ? t.toValue() : t
}
function M2({scrapeMotionValuesFromProps: e, createRenderState: t, onMount: n}, s, o, u) {
    const l = {
        latestValues: j2(s, o, u, e),
        renderState: t()
    };
    return n && (l.mount = d => n(s, d, l)),
        l
}
const E1 = e => (t, n) => {
        const s = P.useContext(lc)
            , o = P.useContext(_p)
            , u = () => M2(e, t, s, o);
        return n ? u() : u2(u)
    }
;
function j2(e, t, n, s) {
    const o = {}
        , u = s(e, {});
    for (const v in u)
        o[v] = Pu(u[v]);
    let {initial: l, animate: d} = e;
    const f = cc(e)
        , p = p1(e);
    t && p && !f && e.inherit !== !1 && (l === void 0 && (l = t.initial),
    d === void 0 && (d = t.animate));
    let m = n ? n.initial === !1 : !1;
    m = m || l === !1;
    const y = m ? d : l;
    if (y && typeof y != "boolean" && !uc(y)) {
        const v = Array.isArray(y) ? y : [y];
        for (let S = 0; S < v.length; S++) {
            const E = Bp(e, v[S]);
            if (E) {
                const {transitionEnd: w, transition: x, ...T} = E;
                for (const k in T) {
                    let R = T[k];
                    if (Array.isArray(R)) {
                        const _ = m ? R.length - 1 : 0;
                        R = R[_]
                    }
                    R !== null && (o[k] = R)
                }
                for (const k in w)
                    o[k] = w[k]
            }
        }
    }
    return o
}
const Vp = () => ({
    style: {},
    transform: {},
    transformOrigin: {},
    vars: {}
})
    , C1 = () => ({
    ...Vp(),
    attrs: {}
})
    , P1 = (e, t) => t && typeof e == "number" ? t.transform(e) : e
    , ur = (e, t, n) => n > t ? t : n < e ? e : n
    , ro = {
    test: e => typeof e == "number",
    parse: parseFloat,
    transform: e => e
}
    , wa = {
    ...ro,
    transform: e => ur(0, 1, e)
}
    , cu = {
    ...ro,
    default: 1
}
    , Ia = e => ({
    test: t => typeof t == "string" && t.endsWith(e) && t.split(" ").length === 1,
    parse: parseFloat,
    transform: t => `${t}${e}`
})
    , Dr = Ia("deg")
    , Vn = Ia("%")
    , Se = Ia("px")
    , D2 = Ia("vh")
    , I2 = Ia("vw")
    , F0 = {
    ...Vn,
    parse: e => Vn.parse(e) / 100,
    transform: e => Vn.transform(e * 100)
}
    , F2 = {
    borderWidth: Se,
    borderTopWidth: Se,
    borderRightWidth: Se,
    borderBottomWidth: Se,
    borderLeftWidth: Se,
    borderRadius: Se,
    radius: Se,
    borderTopLeftRadius: Se,
    borderTopRightRadius: Se,
    borderBottomRightRadius: Se,
    borderBottomLeftRadius: Se,
    width: Se,
    maxWidth: Se,
    height: Se,
    maxHeight: Se,
    top: Se,
    right: Se,
    bottom: Se,
    left: Se,
    padding: Se,
    paddingTop: Se,
    paddingRight: Se,
    paddingBottom: Se,
    paddingLeft: Se,
    margin: Se,
    marginTop: Se,
    marginRight: Se,
    marginBottom: Se,
    marginLeft: Se,
    backgroundPositionX: Se,
    backgroundPositionY: Se
}
    , B2 = {
    rotate: Dr,
    rotateX: Dr,
    rotateY: Dr,
    rotateZ: Dr,
    scale: cu,
    scaleX: cu,
    scaleY: cu,
    scaleZ: cu,
    skew: Dr,
    skewX: Dr,
    skewY: Dr,
    distance: Se,
    translateX: Se,
    translateY: Se,
    translateZ: Se,
    x: Se,
    y: Se,
    z: Se,
    perspective: Se,
    transformPerspective: Se,
    opacity: wa,
    originX: F0,
    originY: F0,
    originZ: Se
}
    , B0 = {
    ...ro,
    transform: Math.round
}
    , Up = {
    ...F2,
    ...B2,
    zIndex: B0,
    size: Se,
    fillOpacity: wa,
    strokeOpacity: wa,
    numOctaves: B0
}
    , V2 = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective"
}
    , U2 = Da.length;
function z2(e, t, n) {
    let s = ""
        , o = !0;
    for (let u = 0; u < U2; u++) {
        const l = Da[u]
            , d = e[l];
        if (d === void 0)
            continue;
        let f = !0;
        if (typeof d == "number" ? f = d === (l.startsWith("scale") ? 1 : 0) : f = parseFloat(d) === 0,
        !f || n) {
            const p = P1(d, Up[l]);
            if (!f) {
                o = !1;
                const m = V2[l] || l;
                s += `${m}(${p}) `
            }
            n && (t[l] = p)
        }
    }
    return s = s.trim(),
        n ? s = n(t, o ? "" : s) : o && (s = "none"),
        s
}
const T1 = e => t => typeof t == "string" && t.startsWith(e)
    , k1 = T1("--")
    , $2 = T1("var(--")
    , zp = e => $2(e) ? W2.test(e.split("/*")[0].trim()) : !1
    , W2 = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;
function $p(e, t, n) {
    const {style: s, vars: o, transformOrigin: u} = e;
    let l = !1
        , d = !1;
    for (const f in t) {
        const p = t[f];
        if ($s.has(f)) {
            l = !0;
            continue
        } else if (k1(f)) {
            o[f] = p;
            continue
        } else {
            const m = P1(p, Up[f]);
            f.startsWith("origin") ? (d = !0,
                u[f] = m) : s[f] = m
        }
    }
    if (t.transform || (l || n ? s.transform = z2(t, e.transform, n) : s.transform && (s.transform = "none")),
        d) {
        const {originX: f="50%", originY: p="50%", originZ: m=0} = u;
        s.transformOrigin = `${f} ${p} ${m}`
    }
}
function V0(e, t, n) {
    return typeof e == "string" ? e : Se.transform(t + n * e)
}
function H2(e, t, n) {
    const s = V0(t, e.x, e.width)
        , o = V0(n, e.y, e.height);
    return `${s} ${o}`
}
const q2 = {
    offset: "stroke-dashoffset",
    array: "stroke-dasharray"
}
    , K2 = {
    offset: "strokeDashoffset",
    array: "strokeDasharray"
};
function Q2(e, t, n=1, s=0, o=!0) {
    e.pathLength = 1;
    const u = o ? q2 : K2;
    e[u.offset] = Se.transform(-s);
    const l = Se.transform(t)
        , d = Se.transform(n);
    e[u.array] = `${l} ${d}`
}
function Wp(e, {attrX: t, attrY: n, attrScale: s, originX: o, originY: u, pathLength: l, pathSpacing: d=1, pathOffset: f=0, ...p}, m, y) {
    if ($p(e, p, y),
        m) {
        e.style.viewBox && (e.attrs.viewBox = e.style.viewBox);
        return
    }
    e.attrs = e.style,
        e.style = {};
    const {attrs: v, style: S, dimensions: E} = e;
    v.transform && (E && (S.transform = v.transform),
        delete v.transform),
    E && (o !== void 0 || u !== void 0 || S.transform) && (S.transformOrigin = H2(E, o !== void 0 ? o : .5, u !== void 0 ? u : .5)),
    t !== void 0 && (v.x = t),
    n !== void 0 && (v.y = n),
    s !== void 0 && (v.scale = s),
    l !== void 0 && Q2(v, l, d, f, !1)
}
const Hp = e => typeof e == "string" && e.toLowerCase() === "svg"
    , G2 = {
    useVisualState: E1({
        scrapeMotionValuesFromProps: b1,
        createRenderState: C1,
        onMount: (e, t, {renderState: n, latestValues: s}) => {
            ze.read( () => {
                    try {
                        n.dimensions = typeof t.getBBox == "function" ? t.getBBox() : t.getBoundingClientRect()
                    } catch {
                        n.dimensions = {
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0
                        }
                    }
                }
            ),
                ze.render( () => {
                        Wp(n, s, Hp(t.tagName), e.transformTemplate),
                            x1(t, n)
                    }
                )
        }
    })
}
    , X2 = {
    useVisualState: E1({
        scrapeMotionValuesFromProps: Fp,
        createRenderState: Vp
    })
};
function R1(e, t, n) {
    for (const s in t)
        !Tt(t[s]) && !S1(s, n) && (e[s] = t[s])
}
function Y2({transformTemplate: e}, t) {
    return P.useMemo( () => {
            const n = Vp();
            return $p(n, t, e),
                Object.assign({}, n.vars, n.style)
        }
        , [t])
}
function J2(e, t) {
    const n = e.style || {}
        , s = {};
    return R1(s, n, e),
        Object.assign(s, Y2(e, t)),
        s
}
function Z2(e, t) {
    const n = {}
        , s = J2(e, t);
    return e.drag && e.dragListener !== !1 && (n.draggable = !1,
        s.userSelect = s.WebkitUserSelect = s.WebkitTouchCallout = "none",
        s.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`),
    e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (n.tabIndex = 0),
        n.style = s,
        n
}
function ej(e, t, n, s) {
    const o = P.useMemo( () => {
            const u = C1();
            return Wp(u, t, Hp(s), e.transformTemplate),
                {
                    ...u.attrs,
                    style: {
                        ...u.style
                    }
                }
        }
        , [t]);
    if (e.style) {
        const u = {};
        R1(u, e.style, e),
            o.style = {
                ...u,
                ...o.style
            }
    }
    return o
}
function tj(e=!1) {
    return (n, s, o, {latestValues: u}, l) => {
        const f = (Ip(n) ? ej : Z2)(s, u, l, n)
            , p = y2(s, typeof n == "string", e)
            , m = n !== P.Fragment ? {
            ...p,
            ...f,
            ref: o
        } : {}
            , {children: y} = s
            , v = P.useMemo( () => Tt(y) ? y.get() : y, [y]);
        return P.createElement(n, {
            ...m,
            children: v
        })
    }
}
function nj(e, t) {
    return function(s, {forwardMotionProps: o}={
        forwardMotionProps: !1
    }) {
        const l = {
            ...Ip(s) ? G2 : X2,
            preloadedFeatures: e,
            useRender: tj(o),
            createVisualElement: t,
            Component: s
        };
        return T2(l)
    }
}
function A1(e, t) {
    if (!Array.isArray(t))
        return !1;
    const n = t.length;
    if (n !== e.length)
        return !1;
    for (let s = 0; s < n; s++)
        if (t[s] !== e[s])
            return !1;
    return !0
}
function dc(e, t, n) {
    const s = e.getProps();
    return Bp(s, t, n !== void 0 ? n : s.custom, e)
}
const rj = Np( () => window.ScrollTimeline !== void 0);
class sj {
    constructor(t) {
        this.stop = () => this.runAll("stop"),
            this.animations = t.filter(Boolean)
    }
    get finished() {
        return Promise.all(this.animations.map(t => "finished"in t ? t.finished : t))
    }
    getAll(t) {
        return this.animations[0][t]
    }
    setAll(t, n) {
        for (let s = 0; s < this.animations.length; s++)
            this.animations[s][t] = n
    }
    attachTimeline(t, n) {
        const s = this.animations.map(o => {
                if (rj() && o.attachTimeline)
                    return o.attachTimeline(t);
                if (typeof n == "function")
                    return n(o)
            }
        );
        return () => {
            s.forEach( (o, u) => {
                    o && o(),
                        this.animations[u].stop()
                }
            )
        }
    }
    get time() {
        return this.getAll("time")
    }
    set time(t) {
        this.setAll("time", t)
    }
    get speed() {
        return this.getAll("speed")
    }
    set speed(t) {
        this.setAll("speed", t)
    }
    get startTime() {
        return this.getAll("startTime")
    }
    get duration() {
        let t = 0;
        for (let n = 0; n < this.animations.length; n++)
            t = Math.max(t, this.animations[n].duration);
        return t
    }
    runAll(t) {
        this.animations.forEach(n => n[t]())
    }
    flatten() {
        this.runAll("flatten")
    }
    play() {
        this.runAll("play")
    }
    pause() {
        this.runAll("pause")
    }
    cancel() {
        this.runAll("cancel")
    }
    complete() {
        this.runAll("complete")
    }
}
class ij extends sj {
    then(t, n) {
        return Promise.all(this.animations).then(t).catch(n)
    }
}
function qp(e, t) {
    return e ? e[t] || e.default || e : void 0
}
const Mh = 2e4;
function _1(e) {
    let t = 0;
    const n = 50;
    let s = e.next(t);
    for (; !s.done && t < Mh; )
        t += n,
            s = e.next(t);
    return t >= Mh ? 1 / 0 : t
}
function Kp(e) {
    return typeof e == "function"
}
function U0(e, t) {
    e.timeline = t,
        e.onfinish = null
}
const Qp = e => Array.isArray(e) && typeof e[0] == "number"
    , oj = {
    linearEasing: void 0
};
function aj(e, t) {
    const n = Np(e);
    return () => {
        var s;
        return (s = oj[t]) !== null && s !== void 0 ? s : n()
    }
}
const Vu = aj( () => {
            try {
                document.createElement("div").animate({
                    opacity: 0
                }, {
                    easing: "linear(0, 1)"
                })
            } catch {
                return !1
            }
            return !0
        }
        , "linearEasing")
    , N1 = (e, t, n=10) => {
        let s = "";
        const o = Math.max(Math.round(t / n), 2);
        for (let u = 0; u < o; u++)
            s += e(Wi(0, o - 1, u)) + ", ";
        return `linear(${s.substring(0, s.length - 2)})`
    }
;
function O1(e) {
    return !!(typeof e == "function" && Vu() || !e || typeof e == "string" && (e in jh || Vu()) || Qp(e) || Array.isArray(e) && e.every(O1))
}
const Zo = ([e,t,n,s]) => `cubic-bezier(${e}, ${t}, ${n}, ${s})`
    , jh = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: Zo([0, .65, .55, 1]),
    circOut: Zo([.55, 0, 1, .45]),
    backIn: Zo([.31, .01, .66, -.59]),
    backOut: Zo([.33, 1.53, .69, .99])
};
function L1(e, t) {
    if (e)
        return typeof e == "function" && Vu() ? N1(e, t) : Qp(e) ? Zo(e) : Array.isArray(e) ? e.map(n => L1(n, t) || jh.easeOut) : jh[e]
}
const vn = {
    x: !1,
    y: !1
};
function M1() {
    return vn.x || vn.y
}
function lj(e, t, n) {
    var s;
    if (e instanceof Element)
        return [e];
    if (typeof e == "string") {
        let o = document;
        const u = (s = void 0) !== null && s !== void 0 ? s : o.querySelectorAll(e);
        return u ? Array.from(u) : []
    }
    return Array.from(e)
}
function j1(e, t) {
    const n = lj(e)
        , s = new AbortController
        , o = {
        passive: !0,
        ...t,
        signal: s.signal
    };
    return [n, o, () => s.abort()]
}
function z0(e) {
    return t => {
        t.pointerType === "touch" || M1() || e(t)
    }
}
function uj(e, t, n={}) {
    const [s,o,u] = j1(e, n)
        , l = z0(d => {
            const {target: f} = d
                , p = t(d);
            if (typeof p != "function" || !f)
                return;
            const m = z0(y => {
                    p(y),
                        f.removeEventListener("pointerleave", m)
                }
            );
            f.addEventListener("pointerleave", m, o)
        }
    );
    return s.forEach(d => {
            d.addEventListener("pointerenter", l, o)
        }
    ),
        u
}
const D1 = (e, t) => t ? e === t ? !0 : D1(e, t.parentElement) : !1
    , Gp = e => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1
    , cj = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]);
function dj(e) {
    return cj.has(e.tagName) || e.tabIndex !== -1
}
const ea = new WeakSet;
function $0(e) {
    return t => {
        t.key === "Enter" && e(t)
    }
}
function Of(e, t) {
    e.dispatchEvent(new PointerEvent("pointer" + t,{
        isPrimary: !0,
        bubbles: !0
    }))
}
const fj = (e, t) => {
        const n = e.currentTarget;
        if (!n)
            return;
        const s = $0( () => {
                if (ea.has(n))
                    return;
                Of(n, "down");
                const o = $0( () => {
                        Of(n, "up")
                    }
                )
                    , u = () => Of(n, "cancel");
                n.addEventListener("keyup", o, t),
                    n.addEventListener("blur", u, t)
            }
        );
        n.addEventListener("keydown", s, t),
            n.addEventListener("blur", () => n.removeEventListener("keydown", s), t)
    }
;
function W0(e) {
    return Gp(e) && !M1()
}
function hj(e, t, n={}) {
    const [s,o,u] = j1(e, n)
        , l = d => {
            const f = d.currentTarget;
            if (!W0(d) || ea.has(f))
                return;
            ea.add(f);
            const p = t(d)
                , m = (S, E) => {
                    window.removeEventListener("pointerup", y),
                        window.removeEventListener("pointercancel", v),
                    !(!W0(S) || !ea.has(f)) && (ea.delete(f),
                    typeof p == "function" && p(S, {
                        success: E
                    }))
                }
                , y = S => {
                    m(S, n.useGlobalTarget || D1(f, S.target))
                }
                , v = S => {
                    m(S, !1)
                }
            ;
            window.addEventListener("pointerup", y, o),
                window.addEventListener("pointercancel", v, o)
        }
    ;
    return s.forEach(d => {
            !dj(d) && d.getAttribute("tabindex") === null && (d.tabIndex = 0),
                (n.useGlobalTarget ? window : d).addEventListener("pointerdown", l, o),
                d.addEventListener("focus", p => fj(p, o), o)
        }
    ),
        u
}
function pj(e) {
    return e === "x" || e === "y" ? vn[e] ? null : (vn[e] = !0,
            () => {
                vn[e] = !1
            }
    ) : vn.x || vn.y ? null : (vn.x = vn.y = !0,
            () => {
                vn.x = vn.y = !1
            }
    )
}
let Tu;
function mj() {
    Tu = void 0
}
const Un = {
    now: () => (Tu === void 0 && Un.set(yt.isProcessing || d2.useManualTiming ? yt.timestamp : performance.now()),
        Tu),
    set: e => {
        Tu = e,
            queueMicrotask(mj)
    }
};
function Xp(e, t) {
    e.indexOf(t) === -1 && e.push(t)
}
function Yp(e, t) {
    const n = e.indexOf(t);
    n > -1 && e.splice(n, 1)
}
class Jp {
    constructor() {
        this.subscriptions = []
    }
    add(t) {
        return Xp(this.subscriptions, t),
            () => Yp(this.subscriptions, t)
    }
    notify(t, n, s) {
        const o = this.subscriptions.length;
        if (o)
            if (o === 1)
                this.subscriptions[0](t, n, s);
            else
                for (let u = 0; u < o; u++) {
                    const l = this.subscriptions[u];
                    l && l(t, n, s)
                }
    }
    getSize() {
        return this.subscriptions.length
    }
    clear() {
        this.subscriptions.length = 0
    }
}
function I1(e, t) {
    return t ? e * (1e3 / t) : 0
}
const H0 = 30
    , gj = e => !isNaN(parseFloat(e));
class yj {
    constructor(t, n={}) {
        this.version = "11.16.4",
            this.canTrackVelocity = null,
            this.events = {},
            this.updateAndNotify = (s, o=!0) => {
                const u = Un.now();
                this.updatedAt !== u && this.setPrevFrameValue(),
                    this.prev = this.current,
                    this.setCurrent(s),
                this.current !== this.prev && this.events.change && this.events.change.notify(this.current),
                o && this.events.renderRequest && this.events.renderRequest.notify(this.current)
            }
            ,
            this.hasAnimated = !1,
            this.setCurrent(t),
            this.owner = n.owner
    }
    setCurrent(t) {
        this.current = t,
            this.updatedAt = Un.now(),
        this.canTrackVelocity === null && t !== void 0 && (this.canTrackVelocity = gj(this.current))
    }
    setPrevFrameValue(t=this.current) {
        this.prevFrameValue = t,
            this.prevUpdatedAt = this.updatedAt
    }
    onChange(t) {
        return this.on("change", t)
    }
    on(t, n) {
        this.events[t] || (this.events[t] = new Jp);
        const s = this.events[t].add(n);
        return t === "change" ? () => {
                s(),
                    ze.read( () => {
                            this.events.change.getSize() || this.stop()
                        }
                    )
            }
            : s
    }
    clearListeners() {
        for (const t in this.events)
            this.events[t].clear()
    }
    attach(t, n) {
        this.passiveEffect = t,
            this.stopPassiveEffect = n
    }
    set(t, n=!0) {
        !n || !this.passiveEffect ? this.updateAndNotify(t, n) : this.passiveEffect(t, this.updateAndNotify)
    }
    setWithVelocity(t, n, s) {
        this.set(n),
            this.prev = void 0,
            this.prevFrameValue = t,
            this.prevUpdatedAt = this.updatedAt - s
    }
    jump(t, n=!0) {
        this.updateAndNotify(t),
            this.prev = t,
            this.prevUpdatedAt = this.prevFrameValue = void 0,
        n && this.stop(),
        this.stopPassiveEffect && this.stopPassiveEffect()
    }
    get() {
        return this.current
    }
    getPrevious() {
        return this.prev
    }
    getVelocity() {
        const t = Un.now();
        if (!this.canTrackVelocity || this.prevFrameValue === void 0 || t - this.updatedAt > H0)
            return 0;
        const n = Math.min(this.updatedAt - this.prevUpdatedAt, H0);
        return I1(parseFloat(this.current) - parseFloat(this.prevFrameValue), n)
    }
    start(t) {
        return this.stop(),
            new Promise(n => {
                    this.hasAnimated = !0,
                        this.animation = t(n),
                    this.events.animationStart && this.events.animationStart.notify()
                }
            ).then( () => {
                    this.events.animationComplete && this.events.animationComplete.notify(),
                        this.clearAnimation()
                }
            )
    }
    stop() {
        this.animation && (this.animation.stop(),
        this.events.animationCancel && this.events.animationCancel.notify()),
            this.clearAnimation()
    }
    isAnimating() {
        return !!this.animation
    }
    clearAnimation() {
        delete this.animation
    }
    destroy() {
        this.clearListeners(),
            this.stop(),
        this.stopPassiveEffect && this.stopPassiveEffect()
    }
}
function xa(e, t) {
    return new yj(e,t)
}
function vj(e, t, n) {
    e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, xa(n))
}
function wj(e, t) {
    const n = dc(e, t);
    let {transitionEnd: s={}, transition: o={}, ...u} = n || {};
    u = {
        ...u,
        ...s
    };
    for (const l in u) {
        const d = L2(u[l]);
        vj(e, l, d)
    }
}
function xj(e) {
    return !!(Tt(e) && e.add)
}
function Dh(e, t) {
    const n = e.getValue("willChange");
    if (xj(n))
        return n.add(t)
}
function F1(e) {
    return e.props[m1]
}
const B1 = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e
    , Sj = 1e-7
    , bj = 12;
function Ej(e, t, n, s, o) {
    let u, l, d = 0;
    do
        l = t + (n - t) / 2,
            u = B1(l, s, o) - e,
            u > 0 ? n = l : t = l;
    while (Math.abs(u) > Sj && ++d < bj);
    return l
}
function Fa(e, t, n, s) {
    if (e === t && n === s)
        return Gt;
    const o = u => Ej(u, 0, 1, e, n);
    return u => u === 0 || u === 1 ? u : B1(o(u), t, s)
}
const V1 = e => t => t <= .5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2
    , U1 = e => t => 1 - e(1 - t)
    , z1 = Fa(.33, 1.53, .69, .99)
    , Zp = U1(z1)
    , $1 = V1(Zp)
    , W1 = e => (e *= 2) < 1 ? .5 * Zp(e) : .5 * (2 - Math.pow(2, -10 * (e - 1)))
    , em = e => 1 - Math.sin(Math.acos(e))
    , H1 = U1(em)
    , q1 = V1(em)
    , K1 = e => /^0[^.\s]+$/u.test(e);
function Cj(e) {
    return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || K1(e) : !0
}
const Q1 = e => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e)
    , Pj = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
function Tj(e) {
    const t = Pj.exec(e);
    if (!t)
        return [, ];
    const [,n,s,o] = t;
    return [`--${n ?? s}`, o]
}
function G1(e, t, n=1) {
    const [s,o] = Tj(e);
    if (!s)
        return;
    const u = window.getComputedStyle(t).getPropertyValue(s);
    if (u) {
        const l = u.trim();
        return Q1(l) ? parseFloat(l) : l
    }
    return zp(o) ? G1(o, t, n + 1) : o
}
const kj = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"])
    , q0 = e => e === ro || e === Se
    , K0 = (e, t) => parseFloat(e.split(", ")[t])
    , Q0 = (e, t) => (n, {transform: s}) => {
    if (s === "none" || !s)
        return 0;
    const o = s.match(/^matrix3d\((.+)\)$/u);
    if (o)
        return K0(o[1], t);
    {
        const u = s.match(/^matrix\((.+)\)$/u);
        return u ? K0(u[1], e) : 0
    }
}
    , Rj = new Set(["x", "y", "z"])
    , Aj = Da.filter(e => !Rj.has(e));
function _j(e) {
    const t = [];
    return Aj.forEach(n => {
            const s = e.getValue(n);
            s !== void 0 && (t.push([n, s.get()]),
                s.set(n.startsWith("scale") ? 1 : 0))
        }
    ),
        t
}
const qi = {
    width: ({x: e}, {paddingLeft: t="0", paddingRight: n="0"}) => e.max - e.min - parseFloat(t) - parseFloat(n),
    height: ({y: e}, {paddingTop: t="0", paddingBottom: n="0"}) => e.max - e.min - parseFloat(t) - parseFloat(n),
    top: (e, {top: t}) => parseFloat(t),
    left: (e, {left: t}) => parseFloat(t),
    bottom: ({y: e}, {top: t}) => parseFloat(t) + (e.max - e.min),
    right: ({x: e}, {left: t}) => parseFloat(t) + (e.max - e.min),
    x: Q0(4, 13),
    y: Q0(5, 14)
};
qi.translateX = qi.x;
qi.translateY = qi.y;
const X1 = e => t => t.test(e)
    , Nj = {
    test: e => e === "auto",
    parse: e => e
}
    , Y1 = [ro, Se, Vn, Dr, I2, D2, Nj]
    , G0 = e => Y1.find(X1(e))
    , Ms = new Set;
let Ih = !1
    , Fh = !1;
function J1() {
    if (Fh) {
        const e = Array.from(Ms).filter(s => s.needsMeasurement)
            , t = new Set(e.map(s => s.element))
            , n = new Map;
        t.forEach(s => {
                const o = _j(s);
                o.length && (n.set(s, o),
                    s.render())
            }
        ),
            e.forEach(s => s.measureInitialState()),
            t.forEach(s => {
                    s.render();
                    const o = n.get(s);
                    o && o.forEach( ([u,l]) => {
                            var d;
                            (d = s.getValue(u)) === null || d === void 0 || d.set(l)
                        }
                    )
                }
            ),
            e.forEach(s => s.measureEndState()),
            e.forEach(s => {
                    s.suspendedScrollY !== void 0 && window.scrollTo(0, s.suspendedScrollY)
                }
            )
    }
    Fh = !1,
        Ih = !1,
        Ms.forEach(e => e.complete()),
        Ms.clear()
}
function Z1() {
    Ms.forEach(e => {
            e.readKeyframes(),
            e.needsMeasurement && (Fh = !0)
        }
    )
}
function Oj() {
    Z1(),
        J1()
}
class tm {
    constructor(t, n, s, o, u, l=!1) {
        this.isComplete = !1,
            this.isAsync = !1,
            this.needsMeasurement = !1,
            this.isScheduled = !1,
            this.unresolvedKeyframes = [...t],
            this.onComplete = n,
            this.name = s,
            this.motionValue = o,
            this.element = u,
            this.isAsync = l
    }
    scheduleResolve() {
        this.isScheduled = !0,
            this.isAsync ? (Ms.add(this),
            Ih || (Ih = !0,
                ze.read(Z1),
                ze.resolveKeyframes(J1))) : (this.readKeyframes(),
                this.complete())
    }
    readKeyframes() {
        const {unresolvedKeyframes: t, name: n, element: s, motionValue: o} = this;
        for (let u = 0; u < t.length; u++)
            if (t[u] === null)
                if (u === 0) {
                    const l = o == null ? void 0 : o.get()
                        , d = t[t.length - 1];
                    if (l !== void 0)
                        t[0] = l;
                    else if (s && n) {
                        const f = s.readValue(n, d);
                        f != null && (t[0] = f)
                    }
                    t[0] === void 0 && (t[0] = d),
                    o && l === void 0 && o.set(t[0])
                } else
                    t[u] = t[u - 1]
    }
    setFinalKeyframe() {}
    measureInitialState() {}
    renderEndStyles() {}
    measureEndState() {}
    complete() {
        this.isComplete = !0,
            this.onComplete(this.unresolvedKeyframes, this.finalKeyframe),
            Ms.delete(this)
    }
    cancel() {
        this.isComplete || (this.isScheduled = !1,
            Ms.delete(this))
    }
    resume() {
        this.isComplete || this.scheduleResolve()
    }
}
const oa = e => Math.round(e * 1e5) / 1e5
    , nm = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function Lj(e) {
    return e == null
}
const Mj = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu
    , rm = (e, t) => n => !!(typeof n == "string" && Mj.test(n) && n.startsWith(e) || t && !Lj(n) && Object.prototype.hasOwnProperty.call(n, t))
    , eE = (e, t, n) => s => {
    if (typeof s != "string")
        return s;
    const [o,u,l,d] = s.match(nm);
    return {
        [e]: parseFloat(o),
        [t]: parseFloat(u),
        [n]: parseFloat(l),
        alpha: d !== void 0 ? parseFloat(d) : 1
    }
}
    , jj = e => ur(0, 255, e)
    , Lf = {
    ...ro,
    transform: e => Math.round(jj(e))
}
    , Es = {
    test: rm("rgb", "red"),
    parse: eE("red", "green", "blue"),
    transform: ({red: e, green: t, blue: n, alpha: s=1}) => "rgba(" + Lf.transform(e) + ", " + Lf.transform(t) + ", " + Lf.transform(n) + ", " + oa(wa.transform(s)) + ")"
};
function Dj(e) {
    let t = ""
        , n = ""
        , s = ""
        , o = "";
    return e.length > 5 ? (t = e.substring(1, 3),
        n = e.substring(3, 5),
        s = e.substring(5, 7),
        o = e.substring(7, 9)) : (t = e.substring(1, 2),
        n = e.substring(2, 3),
        s = e.substring(3, 4),
        o = e.substring(4, 5),
        t += t,
        n += n,
        s += s,
        o += o),
        {
            red: parseInt(t, 16),
            green: parseInt(n, 16),
            blue: parseInt(s, 16),
            alpha: o ? parseInt(o, 16) / 255 : 1
        }
}
const Bh = {
    test: rm("#"),
    parse: Dj,
    transform: Es.transform
}
    , bi = {
    test: rm("hsl", "hue"),
    parse: eE("hue", "saturation", "lightness"),
    transform: ({hue: e, saturation: t, lightness: n, alpha: s=1}) => "hsla(" + Math.round(e) + ", " + Vn.transform(oa(t)) + ", " + Vn.transform(oa(n)) + ", " + oa(wa.transform(s)) + ")"
}
    , Ct = {
    test: e => Es.test(e) || Bh.test(e) || bi.test(e),
    parse: e => Es.test(e) ? Es.parse(e) : bi.test(e) ? bi.parse(e) : Bh.parse(e),
    transform: e => typeof e == "string" ? e : e.hasOwnProperty("red") ? Es.transform(e) : bi.transform(e)
}
    , Ij = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function Fj(e) {
    var t, n;
    return isNaN(e) && typeof e == "string" && (((t = e.match(nm)) === null || t === void 0 ? void 0 : t.length) || 0) + (((n = e.match(Ij)) === null || n === void 0 ? void 0 : n.length) || 0) > 0
}
const tE = "number"
    , nE = "color"
    , Bj = "var"
    , Vj = "var("
    , X0 = "${}"
    , Uj = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function Sa(e) {
    const t = e.toString()
        , n = []
        , s = {
        color: [],
        number: [],
        var: []
    }
        , o = [];
    let u = 0;
    const d = t.replace(Uj, f => (Ct.test(f) ? (s.color.push(u),
        o.push(nE),
        n.push(Ct.parse(f))) : f.startsWith(Vj) ? (s.var.push(u),
        o.push(Bj),
        n.push(f)) : (s.number.push(u),
        o.push(tE),
        n.push(parseFloat(f))),
        ++u,
        X0)).split(X0);
    return {
        values: n,
        split: d,
        indexes: s,
        types: o
    }
}
function rE(e) {
    return Sa(e).values
}
function sE(e) {
    const {split: t, types: n} = Sa(e)
        , s = t.length;
    return o => {
        let u = "";
        for (let l = 0; l < s; l++)
            if (u += t[l],
            o[l] !== void 0) {
                const d = n[l];
                d === tE ? u += oa(o[l]) : d === nE ? u += Ct.transform(o[l]) : u += o[l]
            }
        return u
    }
}
const zj = e => typeof e == "number" ? 0 : e;
function $j(e) {
    const t = rE(e);
    return sE(e)(t.map(zj))
}
const es = {
    test: Fj,
    parse: rE,
    createTransformer: sE,
    getAnimatableNone: $j
}
    , Wj = new Set(["brightness", "contrast", "saturate", "opacity"]);
function Hj(e) {
    const [t,n] = e.slice(0, -1).split("(");
    if (t === "drop-shadow")
        return e;
    const [s] = n.match(nm) || [];
    if (!s)
        return e;
    const o = n.replace(s, "");
    let u = Wj.has(t) ? 1 : 0;
    return s !== n && (u *= 100),
    t + "(" + u + o + ")"
}
const qj = /\b([a-z-]*)\(.*?\)/gu
    , Vh = {
    ...es,
    getAnimatableNone: e => {
        const t = e.match(qj);
        return t ? t.map(Hj).join(" ") : e
    }
}
    , Kj = {
    ...Up,
    color: Ct,
    backgroundColor: Ct,
    outlineColor: Ct,
    fill: Ct,
    stroke: Ct,
    borderColor: Ct,
    borderTopColor: Ct,
    borderRightColor: Ct,
    borderBottomColor: Ct,
    borderLeftColor: Ct,
    filter: Vh,
    WebkitFilter: Vh
}
    , sm = e => Kj[e];
function iE(e, t) {
    let n = sm(e);
    return n !== Vh && (n = es),
        n.getAnimatableNone ? n.getAnimatableNone(t) : void 0
}
const Qj = new Set(["auto", "none", "0"]);
function Gj(e, t, n) {
    let s = 0, o;
    for (; s < e.length && !o; ) {
        const u = e[s];
        typeof u == "string" && !Qj.has(u) && Sa(u).values.length && (o = e[s]),
            s++
    }
    if (o && n)
        for (const u of t)
            e[u] = iE(n, o)
}
class oE extends tm {
    constructor(t, n, s, o, u) {
        super(t, n, s, o, u, !0)
    }
    readKeyframes() {
        const {unresolvedKeyframes: t, element: n, name: s} = this;
        if (!n || !n.current)
            return;
        super.readKeyframes();
        for (let f = 0; f < t.length; f++) {
            let p = t[f];
            if (typeof p == "string" && (p = p.trim(),
                zp(p))) {
                const m = G1(p, n.current);
                m !== void 0 && (t[f] = m),
                f === t.length - 1 && (this.finalKeyframe = p)
            }
        }
        if (this.resolveNoneKeyframes(),
        !kj.has(s) || t.length !== 2)
            return;
        const [o,u] = t
            , l = G0(o)
            , d = G0(u);
        if (l !== d)
            if (q0(l) && q0(d))
                for (let f = 0; f < t.length; f++) {
                    const p = t[f];
                    typeof p == "string" && (t[f] = parseFloat(p))
                }
            else
                this.needsMeasurement = !0
    }
    resolveNoneKeyframes() {
        const {unresolvedKeyframes: t, name: n} = this
            , s = [];
        for (let o = 0; o < t.length; o++)
            Cj(t[o]) && s.push(o);
        s.length && Gj(t, s, n)
    }
    measureInitialState() {
        const {element: t, unresolvedKeyframes: n, name: s} = this;
        if (!t || !t.current)
            return;
        s === "height" && (this.suspendedScrollY = window.pageYOffset),
            this.measuredOrigin = qi[s](t.measureViewportBox(), window.getComputedStyle(t.current)),
            n[0] = this.measuredOrigin;
        const o = n[n.length - 1];
        o !== void 0 && t.getValue(s, o).jump(o, !1)
    }
    measureEndState() {
        var t;
        const {element: n, name: s, unresolvedKeyframes: o} = this;
        if (!n || !n.current)
            return;
        const u = n.getValue(s);
        u && u.jump(this.measuredOrigin, !1);
        const l = o.length - 1
            , d = o[l];
        o[l] = qi[s](n.measureViewportBox(), window.getComputedStyle(n.current)),
        d !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = d),
        !((t = this.removedTransforms) === null || t === void 0) && t.length && this.removedTransforms.forEach( ([f,p]) => {
                n.getValue(f).set(p)
            }
        ),
            this.resolveNoneKeyframes()
    }
}
const Y0 = (e, t) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && (es.test(e) || e === "0") && !e.startsWith("url("));
function Xj(e) {
    const t = e[0];
    if (e.length === 1)
        return !0;
    for (let n = 0; n < e.length; n++)
        if (e[n] !== t)
            return !0
}
function Yj(e, t, n, s) {
    const o = e[0];
    if (o === null)
        return !1;
    if (t === "display" || t === "visibility")
        return !0;
    const u = e[e.length - 1]
        , l = Y0(o, t)
        , d = Y0(u, t);
    return !l || !d ? !1 : Xj(e) || (n === "spring" || Kp(n)) && s
}
const Jj = e => e !== null;
function fc(e, {repeat: t, repeatType: n="loop"}, s) {
    const o = e.filter(Jj)
        , u = t && n !== "loop" && t % 2 === 1 ? 0 : o.length - 1;
    return !u || s === void 0 ? o[u] : s
}
const Zj = 40;
class aE {
    constructor({autoplay: t=!0, delay: n=0, type: s="keyframes", repeat: o=0, repeatDelay: u=0, repeatType: l="loop", ...d}) {
        this.isStopped = !1,
            this.hasAttemptedResolve = !1,
            this.createdAt = Un.now(),
            this.options = {
                autoplay: t,
                delay: n,
                type: s,
                repeat: o,
                repeatDelay: u,
                repeatType: l,
                ...d
            },
            this.updateFinishedPromise()
    }
    calcStartTime() {
        return this.resolvedAt ? this.resolvedAt - this.createdAt > Zj ? this.resolvedAt : this.createdAt : this.createdAt
    }
    get resolved() {
        return !this._resolved && !this.hasAttemptedResolve && Oj(),
            this._resolved
    }
    onKeyframesResolved(t, n) {
        this.resolvedAt = Un.now(),
            this.hasAttemptedResolve = !0;
        const {name: s, type: o, velocity: u, delay: l, onComplete: d, onUpdate: f, isGenerator: p} = this.options;
        if (!p && !Yj(t, s, o, u))
            if (l)
                this.options.duration = 0;
            else {
                f == null || f(fc(t, this.options, n)),
                d == null || d(),
                    this.resolveFinishedPromise();
                return
            }
        const m = this.initPlayback(t, n);
        m !== !1 && (this._resolved = {
            keyframes: t,
            finalKeyframe: n,
            ...m
        },
            this.onPostResolved())
    }
    onPostResolved() {}
    then(t, n) {
        return this.currentFinishedPromise.then(t, n)
    }
    flatten() {
        this.options.type = "keyframes",
            this.options.ease = "linear"
    }
    updateFinishedPromise() {
        this.currentFinishedPromise = new Promise(t => {
                this.resolveFinishedPromise = t
            }
        )
    }
}
const qe = (e, t, n) => e + (t - e) * n;
function Mf(e, t, n) {
    return n < 0 && (n += 1),
    n > 1 && (n -= 1),
        n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e
}
function eD({hue: e, saturation: t, lightness: n, alpha: s}) {
    e /= 360,
        t /= 100,
        n /= 100;
    let o = 0
        , u = 0
        , l = 0;
    if (!t)
        o = u = l = n;
    else {
        const d = n < .5 ? n * (1 + t) : n + t - n * t
            , f = 2 * n - d;
        o = Mf(f, d, e + 1 / 3),
            u = Mf(f, d, e),
            l = Mf(f, d, e - 1 / 3)
    }
    return {
        red: Math.round(o * 255),
        green: Math.round(u * 255),
        blue: Math.round(l * 255),
        alpha: s
    }
}
function Uu(e, t) {
    return n => n > 0 ? t : e
}
const jf = (e, t, n) => {
    const s = e * e
        , o = n * (t * t - s) + s;
    return o < 0 ? 0 : Math.sqrt(o)
}
    , tD = [Bh, Es, bi]
    , nD = e => tD.find(t => t.test(e));
function J0(e) {
    const t = nD(e);
    if (!t)
        return !1;
    let n = t.parse(e);
    return t === bi && (n = eD(n)),
        n
}
const Z0 = (e, t) => {
    const n = J0(e)
        , s = J0(t);
    if (!n || !s)
        return Uu(e, t);
    const o = {
        ...n
    };
    return u => (o.red = jf(n.red, s.red, u),
        o.green = jf(n.green, s.green, u),
        o.blue = jf(n.blue, s.blue, u),
        o.alpha = qe(n.alpha, s.alpha, u),
        Es.transform(o))
}
    , rD = (e, t) => n => t(e(n))
    , Ba = (...e) => e.reduce(rD)
    , Uh = new Set(["none", "hidden"]);
function sD(e, t) {
    return Uh.has(e) ? n => n <= 0 ? e : t : n => n >= 1 ? t : e
}
function iD(e, t) {
    return n => qe(e, t, n)
}
function im(e) {
    return typeof e == "number" ? iD : typeof e == "string" ? zp(e) ? Uu : Ct.test(e) ? Z0 : lD : Array.isArray(e) ? lE : typeof e == "object" ? Ct.test(e) ? Z0 : oD : Uu
}
function lE(e, t) {
    const n = [...e]
        , s = n.length
        , o = e.map( (u, l) => im(u)(u, t[l]));
    return u => {
        for (let l = 0; l < s; l++)
            n[l] = o[l](u);
        return n
    }
}
function oD(e, t) {
    const n = {
        ...e,
        ...t
    }
        , s = {};
    for (const o in n)
        e[o] !== void 0 && t[o] !== void 0 && (s[o] = im(e[o])(e[o], t[o]));
    return o => {
        for (const u in s)
            n[u] = s[u](o);
        return n
    }
}
function aD(e, t) {
    var n;
    const s = []
        , o = {
        color: 0,
        var: 0,
        number: 0
    };
    for (let u = 0; u < t.values.length; u++) {
        const l = t.types[u]
            , d = e.indexes[l][o[l]]
            , f = (n = e.values[d]) !== null && n !== void 0 ? n : 0;
        s[u] = f,
            o[l]++
    }
    return s
}
const lD = (e, t) => {
        const n = es.createTransformer(t)
            , s = Sa(e)
            , o = Sa(t);
        return s.indexes.var.length === o.indexes.var.length && s.indexes.color.length === o.indexes.color.length && s.indexes.number.length >= o.indexes.number.length ? Uh.has(e) && !o.values.length || Uh.has(t) && !s.values.length ? sD(e, t) : Ba(lE(aD(s, o), o.values), n) : Uu(e, t)
    }
;
function uE(e, t, n) {
    return typeof e == "number" && typeof t == "number" && typeof n == "number" ? qe(e, t, n) : im(e)(e, t)
}
const uD = 5;
function cE(e, t, n) {
    const s = Math.max(t - uD, 0);
    return I1(n - e(s), t - s)
}
const Ge = {
    stiffness: 100,
    damping: 10,
    mass: 1,
    velocity: 0,
    duration: 800,
    bounce: .3,
    visualDuration: .3,
    restSpeed: {
        granular: .01,
        default: 2
    },
    restDelta: {
        granular: .005,
        default: .5
    },
    minDuration: .01,
    maxDuration: 10,
    minDamping: .05,
    maxDamping: 1
}
    , Df = .001;
function cD({duration: e=Ge.duration, bounce: t=Ge.bounce, velocity: n=Ge.velocity, mass: s=Ge.mass}) {
    let o, u, l = 1 - t;
    l = ur(Ge.minDamping, Ge.maxDamping, l),
        e = ur(Ge.minDuration, Ge.maxDuration, or(e)),
        l < 1 ? (o = p => {
                const m = p * l
                    , y = m * e
                    , v = m - n
                    , S = zh(p, l)
                    , E = Math.exp(-y);
                return Df - v / S * E
            }
                ,
                u = p => {
                    const y = p * l * e
                        , v = y * n + n
                        , S = Math.pow(l, 2) * Math.pow(p, 2) * e
                        , E = Math.exp(-y)
                        , w = zh(Math.pow(p, 2), l);
                    return (-o(p) + Df > 0 ? -1 : 1) * ((v - S) * E) / w
                }
        ) : (o = p => {
                const m = Math.exp(-p * e)
                    , y = (p - n) * e + 1;
                return -Df + m * y
            }
                ,
                u = p => {
                    const m = Math.exp(-p * e)
                        , y = (n - p) * (e * e);
                    return m * y
                }
        );
    const d = 5 / e
        , f = fD(o, u, d);
    if (e = ir(e),
        isNaN(f))
        return {
            stiffness: Ge.stiffness,
            damping: Ge.damping,
            duration: e
        };
    {
        const p = Math.pow(f, 2) * s;
        return {
            stiffness: p,
            damping: l * 2 * Math.sqrt(s * p),
            duration: e
        }
    }
}
const dD = 12;
function fD(e, t, n) {
    let s = n;
    for (let o = 1; o < dD; o++)
        s = s - e(s) / t(s);
    return s
}
function zh(e, t) {
    return e * Math.sqrt(1 - t * t)
}
const hD = ["duration", "bounce"]
    , pD = ["stiffness", "damping", "mass"];
function ew(e, t) {
    return t.some(n => e[n] !== void 0)
}
function mD(e) {
    let t = {
        velocity: Ge.velocity,
        stiffness: Ge.stiffness,
        damping: Ge.damping,
        mass: Ge.mass,
        isResolvedFromDuration: !1,
        ...e
    };
    if (!ew(e, pD) && ew(e, hD))
        if (e.visualDuration) {
            const n = e.visualDuration
                , s = 2 * Math.PI / (n * 1.2)
                , o = s * s
                , u = 2 * ur(.05, 1, 1 - (e.bounce || 0)) * Math.sqrt(o);
            t = {
                ...t,
                mass: Ge.mass,
                stiffness: o,
                damping: u
            }
        } else {
            const n = cD(e);
            t = {
                ...t,
                ...n,
                mass: Ge.mass
            },
                t.isResolvedFromDuration = !0
        }
    return t
}
function dE(e=Ge.visualDuration, t=Ge.bounce) {
    const n = typeof e != "object" ? {
        visualDuration: e,
        keyframes: [0, 1],
        bounce: t
    } : e;
    let {restSpeed: s, restDelta: o} = n;
    const u = n.keyframes[0]
        , l = n.keyframes[n.keyframes.length - 1]
        , d = {
        done: !1,
        value: u
    }
        , {stiffness: f, damping: p, mass: m, duration: y, velocity: v, isResolvedFromDuration: S} = mD({
        ...n,
        velocity: -or(n.velocity || 0)
    })
        , E = v || 0
        , w = p / (2 * Math.sqrt(f * m))
        , x = l - u
        , T = or(Math.sqrt(f / m))
        , k = Math.abs(x) < 5;
    s || (s = k ? Ge.restSpeed.granular : Ge.restSpeed.default),
    o || (o = k ? Ge.restDelta.granular : Ge.restDelta.default);
    let R;
    if (w < 1) {
        const D = zh(T, w);
        R = H => {
            const $ = Math.exp(-w * T * H);
            return l - $ * ((E + w * T * x) / D * Math.sin(D * H) + x * Math.cos(D * H))
        }
    } else if (w === 1)
        R = D => l - Math.exp(-T * D) * (x + (E + T * x) * D);
    else {
        const D = T * Math.sqrt(w * w - 1);
        R = H => {
            const $ = Math.exp(-w * T * H)
                , O = Math.min(D * H, 300);
            return l - $ * ((E + w * T * x) * Math.sinh(O) + D * x * Math.cosh(O)) / D
        }
    }
    const _ = {
        calculatedDuration: S && y || null,
        next: D => {
            const H = R(D);
            if (S)
                d.done = D >= y;
            else {
                let $ = 0;
                w < 1 && ($ = D === 0 ? ir(E) : cE(R, D, H));
                const O = Math.abs($) <= s
                    , W = Math.abs(l - H) <= o;
                d.done = O && W
            }
            return d.value = d.done ? l : H,
                d
        }
        ,
        toString: () => {
            const D = Math.min(_1(_), Mh)
                , H = N1($ => _.next(D * $).value, D, 30);
            return D + "ms " + H
        }
    };
    return _
}
function tw({keyframes: e, velocity: t=0, power: n=.8, timeConstant: s=325, bounceDamping: o=10, bounceStiffness: u=500, modifyTarget: l, min: d, max: f, restDelta: p=.5, restSpeed: m}) {
    const y = e[0]
        , v = {
        done: !1,
        value: y
    }
        , S = O => d !== void 0 && O < d || f !== void 0 && O > f
        , E = O => d === void 0 ? f : f === void 0 || Math.abs(d - O) < Math.abs(f - O) ? d : f;
    let w = n * t;
    const x = y + w
        , T = l === void 0 ? x : l(x);
    T !== x && (w = T - y);
    const k = O => -w * Math.exp(-O / s)
        , R = O => T + k(O)
        , _ = O => {
            const W = k(O)
                , q = R(O);
            v.done = Math.abs(W) <= p,
                v.value = v.done ? T : q
        }
    ;
    let D, H;
    const $ = O => {
            S(v.value) && (D = O,
                H = dE({
                    keyframes: [v.value, E(v.value)],
                    velocity: cE(R, O, v.value),
                    damping: o,
                    stiffness: u,
                    restDelta: p,
                    restSpeed: m
                }))
        }
    ;
    return $(0),
        {
            calculatedDuration: null,
            next: O => {
                let W = !1;
                return !H && D === void 0 && (W = !0,
                    _(O),
                    $(O)),
                    D !== void 0 && O >= D ? H.next(O - D) : (!W && _(O),
                        v)
            }
        }
}
const gD = Fa(.42, 0, 1, 1)
    , yD = Fa(0, 0, .58, 1)
    , fE = Fa(.42, 0, .58, 1)
    , vD = e => Array.isArray(e) && typeof e[0] != "number"
    , wD = {
        linear: Gt,
        easeIn: gD,
        easeInOut: fE,
        easeOut: yD,
        circIn: em,
        circInOut: q1,
        circOut: H1,
        backIn: Zp,
        backInOut: $1,
        backOut: z1,
        anticipate: W1
    }
    , nw = e => {
        if (Qp(e)) {
            c1(e.length === 4);
            const [t,n,s,o] = e;
            return Fa(t, n, s, o)
        } else if (typeof e == "string")
            return wD[e];
        return e
    }
;
function xD(e, t, n) {
    const s = []
        , o = n || uE
        , u = e.length - 1;
    for (let l = 0; l < u; l++) {
        let d = o(e[l], e[l + 1]);
        if (t) {
            const f = Array.isArray(t) ? t[l] || Gt : t;
            d = Ba(f, d)
        }
        s.push(d)
    }
    return s
}
function SD(e, t, {clamp: n=!0, ease: s, mixer: o}={}) {
    const u = e.length;
    if (c1(u === t.length),
    u === 1)
        return () => t[0];
    if (u === 2 && e[0] === e[1])
        return () => t[1];
    e[0] > e[u - 1] && (e = [...e].reverse(),
        t = [...t].reverse());
    const l = xD(t, s, o)
        , d = l.length
        , f = p => {
            let m = 0;
            if (d > 1)
                for (; m < e.length - 2 && !(p < e[m + 1]); m++)
                    ;
            const y = Wi(e[m], e[m + 1], p);
            return l[m](y)
        }
    ;
    return n ? p => f(ur(e[0], e[u - 1], p)) : f
}
function bD(e, t) {
    const n = e[e.length - 1];
    for (let s = 1; s <= t; s++) {
        const o = Wi(0, t, s);
        e.push(qe(n, 1, o))
    }
}
function ED(e) {
    const t = [0];
    return bD(t, e.length - 1),
        t
}
function CD(e, t) {
    return e.map(n => n * t)
}
function PD(e, t) {
    return e.map( () => t || fE).splice(0, e.length - 1)
}
function zu({duration: e=300, keyframes: t, times: n, ease: s="easeInOut"}) {
    const o = vD(s) ? s.map(nw) : nw(s)
        , u = {
        done: !1,
        value: t[0]
    }
        , l = CD(n && n.length === t.length ? n : ED(t), e)
        , d = SD(l, t, {
        ease: Array.isArray(o) ? o : PD(t, o)
    });
    return {
        calculatedDuration: e,
        next: f => (u.value = d(f),
            u.done = f >= e,
            u)
    }
}
const TD = e => {
    const t = ({timestamp: n}) => e(n);
    return {
        start: () => ze.update(t, !0),
        stop: () => Zr(t),
        now: () => yt.isProcessing ? yt.timestamp : Un.now()
    }
}
    , kD = {
    decay: tw,
    inertia: tw,
    tween: zu,
    keyframes: zu,
    spring: dE
}
    , RD = e => e / 100;
class om extends aE {
    constructor(t) {
        super(t),
            this.holdTime = null,
            this.cancelTime = null,
            this.currentTime = 0,
            this.playbackSpeed = 1,
            this.pendingPlayState = "running",
            this.startTime = null,
            this.state = "idle",
            this.stop = () => {
                if (this.resolver.cancel(),
                    this.isStopped = !0,
                this.state === "idle")
                    return;
                this.teardown();
                const {onStop: f} = this.options;
                f && f()
            }
        ;
        const {name: n, motionValue: s, element: o, keyframes: u} = this.options
            , l = (o == null ? void 0 : o.KeyframeResolver) || tm
            , d = (f, p) => this.onKeyframesResolved(f, p);
        this.resolver = new l(u,d,n,s,o),
            this.resolver.scheduleResolve()
    }
    flatten() {
        super.flatten(),
        this._resolved && Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes))
    }
    initPlayback(t) {
        const {type: n="keyframes", repeat: s=0, repeatDelay: o=0, repeatType: u, velocity: l=0} = this.options
            , d = Kp(n) ? n : kD[n] || zu;
        let f, p;
        d !== zu && typeof t[0] != "number" && (f = Ba(RD, uE(t[0], t[1])),
            t = [0, 100]);
        const m = d({
            ...this.options,
            keyframes: t
        });
        u === "mirror" && (p = d({
            ...this.options,
            keyframes: [...t].reverse(),
            velocity: -l
        })),
        m.calculatedDuration === null && (m.calculatedDuration = _1(m));
        const {calculatedDuration: y} = m
            , v = y + o
            , S = v * (s + 1) - o;
        return {
            generator: m,
            mirroredGenerator: p,
            mapPercentToKeyframes: f,
            calculatedDuration: y,
            resolvedDuration: v,
            totalDuration: S
        }
    }
    onPostResolved() {
        const {autoplay: t=!0} = this.options;
        this.play(),
            this.pendingPlayState === "paused" || !t ? this.pause() : this.state = this.pendingPlayState
    }
    tick(t, n=!1) {
        const {resolved: s} = this;
        if (!s) {
            const {keyframes: O} = this.options;
            return {
                done: !0,
                value: O[O.length - 1]
            }
        }
        const {finalKeyframe: o, generator: u, mirroredGenerator: l, mapPercentToKeyframes: d, keyframes: f, calculatedDuration: p, totalDuration: m, resolvedDuration: y} = s;
        if (this.startTime === null)
            return u.next(0);
        const {delay: v, repeat: S, repeatType: E, repeatDelay: w, onUpdate: x} = this.options;
        this.speed > 0 ? this.startTime = Math.min(this.startTime, t) : this.speed < 0 && (this.startTime = Math.min(t - m / this.speed, this.startTime)),
            n ? this.currentTime = t : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(t - this.startTime) * this.speed;
        const T = this.currentTime - v * (this.speed >= 0 ? 1 : -1)
            , k = this.speed >= 0 ? T < 0 : T > m;
        this.currentTime = Math.max(T, 0),
        this.state === "finished" && this.holdTime === null && (this.currentTime = m);
        let R = this.currentTime
            , _ = u;
        if (S) {
            const O = Math.min(this.currentTime, m) / y;
            let W = Math.floor(O)
                , q = O % 1;
            !q && O >= 1 && (q = 1),
            q === 1 && W--,
                W = Math.min(W, S + 1),
            !!(W % 2) && (E === "reverse" ? (q = 1 - q,
            w && (q -= w / y)) : E === "mirror" && (_ = l)),
                R = ur(0, 1, q) * y
        }
        const D = k ? {
            done: !1,
            value: f[0]
        } : _.next(R);
        d && (D.value = d(D.value));
        let {done: H} = D;
        !k && p !== null && (H = this.speed >= 0 ? this.currentTime >= m : this.currentTime <= 0);
        const $ = this.holdTime === null && (this.state === "finished" || this.state === "running" && H);
        return $ && o !== void 0 && (D.value = fc(f, this.options, o)),
        x && x(D.value),
        $ && this.finish(),
            D
    }
    get duration() {
        const {resolved: t} = this;
        return t ? or(t.calculatedDuration) : 0
    }
    get time() {
        return or(this.currentTime)
    }
    set time(t) {
        t = ir(t),
            this.currentTime = t,
            this.holdTime !== null || this.speed === 0 ? this.holdTime = t : this.driver && (this.startTime = this.driver.now() - t / this.speed)
    }
    get speed() {
        return this.playbackSpeed
    }
    set speed(t) {
        const n = this.playbackSpeed !== t;
        this.playbackSpeed = t,
        n && (this.time = or(this.currentTime))
    }
    play() {
        if (this.resolver.isScheduled || this.resolver.resume(),
            !this._resolved) {
            this.pendingPlayState = "running";
            return
        }
        if (this.isStopped)
            return;
        const {driver: t=TD, onPlay: n, startTime: s} = this.options;
        this.driver || (this.driver = t(u => this.tick(u))),
        n && n();
        const o = this.driver.now();
        this.holdTime !== null ? this.startTime = o - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = o) : this.startTime = s ?? this.calcStartTime(),
        this.state === "finished" && this.updateFinishedPromise(),
            this.cancelTime = this.startTime,
            this.holdTime = null,
            this.state = "running",
            this.driver.start()
    }
    pause() {
        var t;
        if (!this._resolved) {
            this.pendingPlayState = "paused";
            return
        }
        this.state = "paused",
            this.holdTime = (t = this.currentTime) !== null && t !== void 0 ? t : 0
    }
    complete() {
        this.state !== "running" && this.play(),
            this.pendingPlayState = this.state = "finished",
            this.holdTime = null
    }
    finish() {
        this.teardown(),
            this.state = "finished";
        const {onComplete: t} = this.options;
        t && t()
    }
    cancel() {
        this.cancelTime !== null && this.tick(this.cancelTime),
            this.teardown(),
            this.updateFinishedPromise()
    }
    teardown() {
        this.state = "idle",
            this.stopDriver(),
            this.resolveFinishedPromise(),
            this.updateFinishedPromise(),
            this.startTime = this.cancelTime = null,
            this.resolver.cancel()
    }
    stopDriver() {
        this.driver && (this.driver.stop(),
            this.driver = void 0)
    }
    sample(t) {
        return this.startTime = 0,
            this.tick(t, !0)
    }
}
const AD = new Set(["opacity", "clipPath", "filter", "transform"]);
function _D(e, t, n, {delay: s=0, duration: o=300, repeat: u=0, repeatType: l="loop", ease: d="easeInOut", times: f}={}) {
    const p = {
        [t]: n
    };
    f && (p.offset = f);
    const m = L1(d, o);
    return Array.isArray(m) && (p.easing = m),
        e.animate(p, {
            delay: s,
            duration: o,
            easing: Array.isArray(m) ? "linear" : m,
            fill: "both",
            iterations: u + 1,
            direction: l === "reverse" ? "alternate" : "normal"
        })
}
const ND = Np( () => Object.hasOwnProperty.call(Element.prototype, "animate"))
    , $u = 10
    , OD = 2e4;
function LD(e) {
    return Kp(e.type) || e.type === "spring" || !O1(e.ease)
}
function MD(e, t) {
    const n = new om({
        ...t,
        keyframes: e,
        repeat: 0,
        delay: 0,
        isGenerator: !0
    });
    let s = {
        done: !1,
        value: e[0]
    };
    const o = [];
    let u = 0;
    for (; !s.done && u < OD; )
        s = n.sample(u),
            o.push(s.value),
            u += $u;
    return {
        times: void 0,
        keyframes: o,
        duration: u - $u,
        ease: "linear"
    }
}
const hE = {
    anticipate: W1,
    backInOut: $1,
    circInOut: q1
};
function jD(e) {
    return e in hE
}
class rw extends aE {
    constructor(t) {
        super(t);
        const {name: n, motionValue: s, element: o, keyframes: u} = this.options;
        this.resolver = new oE(u, (l, d) => this.onKeyframesResolved(l, d),n,s,o),
            this.resolver.scheduleResolve()
    }
    initPlayback(t, n) {
        var s;
        let {duration: o=300, times: u, ease: l, type: d, motionValue: f, name: p, startTime: m} = this.options;
        if (!(!((s = f.owner) === null || s === void 0) && s.current))
            return !1;
        if (typeof l == "string" && Vu() && jD(l) && (l = hE[l]),
            LD(this.options)) {
            const {onComplete: v, onUpdate: S, motionValue: E, element: w, ...x} = this.options
                , T = MD(t, x);
            t = T.keyframes,
            t.length === 1 && (t[1] = t[0]),
                o = T.duration,
                u = T.times,
                l = T.ease,
                d = "keyframes"
        }
        const y = _D(f.owner.current, p, t, {
            ...this.options,
            duration: o,
            times: u,
            ease: l
        });
        return y.startTime = m ?? this.calcStartTime(),
            this.pendingTimeline ? (U0(y, this.pendingTimeline),
                this.pendingTimeline = void 0) : y.onfinish = () => {
                const {onComplete: v} = this.options;
                f.set(fc(t, this.options, n)),
                v && v(),
                    this.cancel(),
                    this.resolveFinishedPromise()
            }
            ,
            {
                animation: y,
                duration: o,
                times: u,
                type: d,
                ease: l,
                keyframes: t
            }
    }
    get duration() {
        const {resolved: t} = this;
        if (!t)
            return 0;
        const {duration: n} = t;
        return or(n)
    }
    get time() {
        const {resolved: t} = this;
        if (!t)
            return 0;
        const {animation: n} = t;
        return or(n.currentTime || 0)
    }
    set time(t) {
        const {resolved: n} = this;
        if (!n)
            return;
        const {animation: s} = n;
        s.currentTime = ir(t)
    }
    get speed() {
        const {resolved: t} = this;
        if (!t)
            return 1;
        const {animation: n} = t;
        return n.playbackRate
    }
    set speed(t) {
        const {resolved: n} = this;
        if (!n)
            return;
        const {animation: s} = n;
        s.playbackRate = t
    }
    get state() {
        const {resolved: t} = this;
        if (!t)
            return "idle";
        const {animation: n} = t;
        return n.playState
    }
    get startTime() {
        const {resolved: t} = this;
        if (!t)
            return null;
        const {animation: n} = t;
        return n.startTime
    }
    attachTimeline(t) {
        if (!this._resolved)
            this.pendingTimeline = t;
        else {
            const {resolved: n} = this;
            if (!n)
                return Gt;
            const {animation: s} = n;
            U0(s, t)
        }
        return Gt
    }
    play() {
        if (this.isStopped)
            return;
        const {resolved: t} = this;
        if (!t)
            return;
        const {animation: n} = t;
        n.playState === "finished" && this.updateFinishedPromise(),
            n.play()
    }
    pause() {
        const {resolved: t} = this;
        if (!t)
            return;
        const {animation: n} = t;
        n.pause()
    }
    stop() {
        if (this.resolver.cancel(),
            this.isStopped = !0,
        this.state === "idle")
            return;
        this.resolveFinishedPromise(),
            this.updateFinishedPromise();
        const {resolved: t} = this;
        if (!t)
            return;
        const {animation: n, keyframes: s, duration: o, type: u, ease: l, times: d} = t;
        if (n.playState === "idle" || n.playState === "finished")
            return;
        if (this.time) {
            const {motionValue: p, onUpdate: m, onComplete: y, element: v, ...S} = this.options
                , E = new om({
                ...S,
                keyframes: s,
                duration: o,
                type: u,
                ease: l,
                times: d,
                isGenerator: !0
            })
                , w = ir(this.time);
            p.setWithVelocity(E.sample(w - $u).value, E.sample(w).value, $u)
        }
        const {onStop: f} = this.options;
        f && f(),
            this.cancel()
    }
    complete() {
        const {resolved: t} = this;
        t && t.animation.finish()
    }
    cancel() {
        const {resolved: t} = this;
        t && t.animation.cancel()
    }
    static supports(t) {
        const {motionValue: n, name: s, repeatDelay: o, repeatType: u, damping: l, type: d} = t;
        return ND() && s && AD.has(s) && n && n.owner && n.owner.current instanceof HTMLElement && !n.owner.getProps().onUpdate && !o && u !== "mirror" && l !== 0 && d !== "inertia"
    }
}
const DD = {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10
}
    , ID = e => ({
    type: "spring",
    stiffness: 550,
    damping: e === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10
})
    , FD = {
    type: "keyframes",
    duration: .8
}
    , BD = {
    type: "keyframes",
    ease: [.25, .1, .35, 1],
    duration: .3
}
    , VD = (e, {keyframes: t}) => t.length > 2 ? FD : $s.has(e) ? e.startsWith("scale") ? ID(t[1]) : DD : BD;
function UD({when: e, delay: t, delayChildren: n, staggerChildren: s, staggerDirection: o, repeat: u, repeatType: l, repeatDelay: d, from: f, elapsed: p, ...m}) {
    return !!Object.keys(m).length
}
const am = (e, t, n, s={}, o, u) => l => {
        const d = qp(s, e) || {}
            , f = d.delay || s.delay || 0;
        let {elapsed: p=0} = s;
        p = p - ir(f);
        let m = {
            keyframes: Array.isArray(n) ? n : [null, n],
            ease: "easeOut",
            velocity: t.getVelocity(),
            ...d,
            delay: -p,
            onUpdate: v => {
                t.set(v),
                d.onUpdate && d.onUpdate(v)
            }
            ,
            onComplete: () => {
                l(),
                d.onComplete && d.onComplete()
            }
            ,
            name: e,
            motionValue: t,
            element: u ? void 0 : o
        };
        UD(d) || (m = {
            ...m,
            ...VD(e, m)
        }),
        m.duration && (m.duration = ir(m.duration)),
        m.repeatDelay && (m.repeatDelay = ir(m.repeatDelay)),
        m.from !== void 0 && (m.keyframes[0] = m.from);
        let y = !1;
        if ((m.type === !1 || m.duration === 0 && !m.repeatDelay) && (m.duration = 0,
        m.delay === 0 && (y = !0)),
        y && !u && t.get() !== void 0) {
            const v = fc(m.keyframes, d);
            if (v !== void 0)
                return ze.update( () => {
                        m.onUpdate(v),
                            m.onComplete()
                    }
                ),
                    new ij([])
        }
        return !u && rw.supports(m) ? new rw(m) : new om(m)
    }
;
function zD({protectedKeys: e, needsAnimating: t}, n) {
    const s = e.hasOwnProperty(n) && t[n] !== !0;
    return t[n] = !1,
        s
}
function pE(e, t, {delay: n=0, transitionOverride: s, type: o}={}) {
    var u;
    let {transition: l=e.getDefaultTransition(), transitionEnd: d, ...f} = t;
    s && (l = s);
    const p = []
        , m = o && e.animationState && e.animationState.getState()[o];
    for (const y in f) {
        const v = e.getValue(y, (u = e.latestValues[y]) !== null && u !== void 0 ? u : null)
            , S = f[y];
        if (S === void 0 || m && zD(m, y))
            continue;
        const E = {
            delay: n,
            ...qp(l || {}, y)
        };
        let w = !1;
        if (window.MotionHandoffAnimation) {
            const T = F1(e);
            if (T) {
                const k = window.MotionHandoffAnimation(T, y, ze);
                k !== null && (E.startTime = k,
                    w = !0)
            }
        }
        Dh(e, y),
            v.start(am(y, v, S, e.shouldReduceMotion && $s.has(y) ? {
                type: !1
            } : E, e, w));
        const x = v.animation;
        x && p.push(x)
    }
    return d && Promise.all(p).then( () => {
            ze.update( () => {
                    d && wj(e, d)
                }
            )
        }
    ),
        p
}
function $h(e, t, n={}) {
    var s;
    const o = dc(e, t, n.type === "exit" ? (s = e.presenceContext) === null || s === void 0 ? void 0 : s.custom : void 0);
    let {transition: u=e.getDefaultTransition() || {}} = o || {};
    n.transitionOverride && (u = n.transitionOverride);
    const l = o ? () => Promise.all(pE(e, o, n)) : () => Promise.resolve()
        , d = e.variantChildren && e.variantChildren.size ? (p=0) => {
            const {delayChildren: m=0, staggerChildren: y, staggerDirection: v} = u;
            return $D(e, t, m + p, y, v, n)
        }
        : () => Promise.resolve()
        , {when: f} = u;
    if (f) {
        const [p,m] = f === "beforeChildren" ? [l, d] : [d, l];
        return p().then( () => m())
    } else
        return Promise.all([l(), d(n.delay)])
}
function $D(e, t, n=0, s=0, o=1, u) {
    const l = []
        , d = (e.variantChildren.size - 1) * s
        , f = o === 1 ? (p=0) => p * s : (p=0) => d - p * s;
    return Array.from(e.variantChildren).sort(WD).forEach( (p, m) => {
            p.notify("AnimationStart", t),
                l.push($h(p, t, {
                    ...u,
                    delay: n + f(m)
                }).then( () => p.notify("AnimationComplete", t)))
        }
    ),
        Promise.all(l)
}
function WD(e, t) {
    return e.sortNodePosition(t)
}
function HD(e, t, n={}) {
    e.notify("AnimationStart", t);
    let s;
    if (Array.isArray(t)) {
        const o = t.map(u => $h(e, u, n));
        s = Promise.all(o)
    } else if (typeof t == "string")
        s = $h(e, t, n);
    else {
        const o = typeof t == "function" ? dc(e, t, n.custom) : t;
        s = Promise.all(pE(e, o, n))
    }
    return s.then( () => {
            e.notify("AnimationComplete", t)
        }
    )
}
const qD = Mp.length;
function mE(e) {
    if (!e)
        return;
    if (!e.isControllingVariants) {
        const n = e.parent ? mE(e.parent) || {} : {};
        return e.props.initial !== void 0 && (n.initial = e.props.initial),
            n
    }
    const t = {};
    for (let n = 0; n < qD; n++) {
        const s = Mp[n]
            , o = e.props[s];
        (va(o) || o === !1) && (t[s] = o)
    }
    return t
}
const KD = [...Lp].reverse()
    , QD = Lp.length;
function GD(e) {
    return t => Promise.all(t.map( ({animation: n, options: s}) => HD(e, n, s)))
}
function XD(e) {
    let t = GD(e)
        , n = sw()
        , s = !0;
    const o = f => (p, m) => {
            var y;
            const v = dc(e, m, f === "exit" ? (y = e.presenceContext) === null || y === void 0 ? void 0 : y.custom : void 0);
            if (v) {
                const {transition: S, transitionEnd: E, ...w} = v;
                p = {
                    ...p,
                    ...w,
                    ...E
                }
            }
            return p
        }
    ;
    function u(f) {
        t = f(e)
    }
    function l(f) {
        const {props: p} = e
            , m = mE(e.parent) || {}
            , y = []
            , v = new Set;
        let S = {}
            , E = 1 / 0;
        for (let x = 0; x < QD; x++) {
            const T = KD[x]
                , k = n[T]
                , R = p[T] !== void 0 ? p[T] : m[T]
                , _ = va(R)
                , D = T === f ? k.isActive : null;
            D === !1 && (E = x);
            let H = R === m[T] && R !== p[T] && _;
            if (H && s && e.manuallyAnimateOnMount && (H = !1),
                k.protectedKeys = {
                    ...S
                },
            !k.isActive && D === null || !R && !k.prevProp || uc(R) || typeof R == "boolean")
                continue;
            const $ = YD(k.prevProp, R);
            let O = $ || T === f && k.isActive && !H && _ || x > E && _
                , W = !1;
            const q = Array.isArray(R) ? R : [R];
            let X = q.reduce(o(T), {});
            D === !1 && (X = {});
            const {prevResolvedValues: z={}} = k
                , J = {
                    ...z,
                    ...X
                }
                , ae = re => {
                    O = !0,
                    v.has(re) && (W = !0,
                        v.delete(re)),
                        k.needsAnimating[re] = !0;
                    const I = e.getValue(re);
                    I && (I.liveStyle = !1)
                }
            ;
            for (const re in J) {
                const I = X[re]
                    , se = z[re];
                if (S.hasOwnProperty(re))
                    continue;
                let ee = !1;
                Lh(I) && Lh(se) ? ee = !A1(I, se) : ee = I !== se,
                    ee ? I != null ? ae(re) : v.add(re) : I !== void 0 && v.has(re) ? ae(re) : k.protectedKeys[re] = !0
            }
            k.prevProp = R,
                k.prevResolvedValues = X,
            k.isActive && (S = {
                ...S,
                ...X
            }),
            s && e.blockInitialAnimation && (O = !1),
            O && (!(H && $) || W) && y.push(...q.map(re => ({
                animation: re,
                options: {
                    type: T
                }
            })))
        }
        if (v.size) {
            const x = {};
            v.forEach(T => {
                    const k = e.getBaseTarget(T)
                        , R = e.getValue(T);
                    R && (R.liveStyle = !0),
                        x[T] = k ?? null
                }
            ),
                y.push({
                    animation: x
                })
        }
        let w = !!y.length;
        return s && (p.initial === !1 || p.initial === p.animate) && !e.manuallyAnimateOnMount && (w = !1),
            s = !1,
            w ? t(y) : Promise.resolve()
    }
    function d(f, p) {
        var m;
        if (n[f].isActive === p)
            return Promise.resolve();
        (m = e.variantChildren) === null || m === void 0 || m.forEach(v => {
                var S;
                return (S = v.animationState) === null || S === void 0 ? void 0 : S.setActive(f, p)
            }
        ),
            n[f].isActive = p;
        const y = l(f);
        for (const v in n)
            n[v].protectedKeys = {};
        return y
    }
    return {
        animateChanges: l,
        setActive: d,
        setAnimateFunction: u,
        getState: () => n,
        reset: () => {
            n = sw(),
                s = !0
        }
    }
}
function YD(e, t) {
    return typeof t == "string" ? t !== e : Array.isArray(t) ? !A1(t, e) : !1
}
function vs(e=!1) {
    return {
        isActive: e,
        protectedKeys: {},
        needsAnimating: {},
        prevResolvedValues: {}
    }
}
function sw() {
    return {
        animate: vs(!0),
        whileInView: vs(),
        whileHover: vs(),
        whileTap: vs(),
        whileDrag: vs(),
        whileFocus: vs(),
        exit: vs()
    }
}
class rs {
    constructor(t) {
        this.isMounted = !1,
            this.node = t
    }
    update() {}
}
class JD extends rs {
    constructor(t) {
        super(t),
        t.animationState || (t.animationState = XD(t))
    }
    updateAnimationControlsSubscription() {
        const {animate: t} = this.node.getProps();
        uc(t) && (this.unmountControls = t.subscribe(this.node))
    }
    mount() {
        this.updateAnimationControlsSubscription()
    }
    update() {
        const {animate: t} = this.node.getProps()
            , {animate: n} = this.node.prevProps || {};
        t !== n && this.updateAnimationControlsSubscription()
    }
    unmount() {
        var t;
        this.node.animationState.reset(),
        (t = this.unmountControls) === null || t === void 0 || t.call(this)
    }
}
let ZD = 0;
class eI extends rs {
    constructor() {
        super(...arguments),
            this.id = ZD++
    }
    update() {
        if (!this.node.presenceContext)
            return;
        const {isPresent: t, onExitComplete: n} = this.node.presenceContext
            , {isPresent: s} = this.node.prevPresenceContext || {};
        if (!this.node.animationState || t === s)
            return;
        const o = this.node.animationState.setActive("exit", !t);
        n && !t && o.then( () => n(this.id))
    }
    mount() {
        const {register: t} = this.node.presenceContext || {};
        t && (this.unmount = t(this.id))
    }
    unmount() {}
}
const tI = {
    animation: {
        Feature: JD
    },
    exit: {
        Feature: eI
    }
};
function ba(e, t, n, s={
    passive: !0
}) {
    return e.addEventListener(t, n, s),
        () => e.removeEventListener(t, n)
}
function Va(e) {
    return {
        point: {
            x: e.pageX,
            y: e.pageY
        }
    }
}
const nI = e => t => Gp(t) && e(t, Va(t));
function aa(e, t, n, s) {
    return ba(e, t, nI(n), s)
}
const iw = (e, t) => Math.abs(e - t);
function rI(e, t) {
    const n = iw(e.x, t.x)
        , s = iw(e.y, t.y);
    return Math.sqrt(n ** 2 + s ** 2)
}
class gE {
    constructor(t, n, {transformPagePoint: s, contextWindow: o, dragSnapToOrigin: u=!1}={}) {
        if (this.startEvent = null,
            this.lastMoveEvent = null,
            this.lastMoveEventInfo = null,
            this.handlers = {},
            this.contextWindow = window,
            this.updatePoint = () => {
                if (!(this.lastMoveEvent && this.lastMoveEventInfo))
                    return;
                const y = Ff(this.lastMoveEventInfo, this.history)
                    , v = this.startEvent !== null
                    , S = rI(y.offset, {
                    x: 0,
                    y: 0
                }) >= 3;
                if (!v && !S)
                    return;
                const {point: E} = y
                    , {timestamp: w} = yt;
                this.history.push({
                    ...E,
                    timestamp: w
                });
                const {onStart: x, onMove: T} = this.handlers;
                v || (x && x(this.lastMoveEvent, y),
                    this.startEvent = this.lastMoveEvent),
                T && T(this.lastMoveEvent, y)
            }
            ,
            this.handlePointerMove = (y, v) => {
                this.lastMoveEvent = y,
                    this.lastMoveEventInfo = If(v, this.transformPagePoint),
                    ze.update(this.updatePoint, !0)
            }
            ,
            this.handlePointerUp = (y, v) => {
                this.end();
                const {onEnd: S, onSessionEnd: E, resumeAnimation: w} = this.handlers;
                if (this.dragSnapToOrigin && w && w(),
                    !(this.lastMoveEvent && this.lastMoveEventInfo))
                    return;
                const x = Ff(y.type === "pointercancel" ? this.lastMoveEventInfo : If(v, this.transformPagePoint), this.history);
                this.startEvent && S && S(y, x),
                E && E(y, x)
            }
            ,
            !Gp(t))
            return;
        this.dragSnapToOrigin = u,
            this.handlers = n,
            this.transformPagePoint = s,
            this.contextWindow = o || window;
        const l = Va(t)
            , d = If(l, this.transformPagePoint)
            , {point: f} = d
            , {timestamp: p} = yt;
        this.history = [{
            ...f,
            timestamp: p
        }];
        const {onSessionStart: m} = n;
        m && m(t, Ff(d, this.history)),
            this.removeListeners = Ba(aa(this.contextWindow, "pointermove", this.handlePointerMove), aa(this.contextWindow, "pointerup", this.handlePointerUp), aa(this.contextWindow, "pointercancel", this.handlePointerUp))
    }
    updateHandlers(t) {
        this.handlers = t
    }
    end() {
        this.removeListeners && this.removeListeners(),
            Zr(this.updatePoint)
    }
}
function If(e, t) {
    return t ? {
        point: t(e.point)
    } : e
}
function ow(e, t) {
    return {
        x: e.x - t.x,
        y: e.y - t.y
    }
}
function Ff({point: e}, t) {
    return {
        point: e,
        delta: ow(e, yE(t)),
        offset: ow(e, sI(t)),
        velocity: iI(t, .1)
    }
}
function sI(e) {
    return e[0]
}
function yE(e) {
    return e[e.length - 1]
}
function iI(e, t) {
    if (e.length < 2)
        return {
            x: 0,
            y: 0
        };
    let n = e.length - 1
        , s = null;
    const o = yE(e);
    for (; n >= 0 && (s = e[n],
        !(o.timestamp - s.timestamp > ir(t))); )
        n--;
    if (!s)
        return {
            x: 0,
            y: 0
        };
    const u = or(o.timestamp - s.timestamp);
    if (u === 0)
        return {
            x: 0,
            y: 0
        };
    const l = {
        x: (o.x - s.x) / u,
        y: (o.y - s.y) / u
    };
    return l.x === 1 / 0 && (l.x = 0),
    l.y === 1 / 0 && (l.y = 0),
        l
}
const vE = 1e-4
    , oI = 1 - vE
    , aI = 1 + vE
    , wE = .01
    , lI = 0 - wE
    , uI = 0 + wE;
function Xt(e) {
    return e.max - e.min
}
function cI(e, t, n) {
    return Math.abs(e - t) <= n
}
function aw(e, t, n, s=.5) {
    e.origin = s,
        e.originPoint = qe(t.min, t.max, e.origin),
        e.scale = Xt(n) / Xt(t),
        e.translate = qe(n.min, n.max, e.origin) - e.originPoint,
    (e.scale >= oI && e.scale <= aI || isNaN(e.scale)) && (e.scale = 1),
    (e.translate >= lI && e.translate <= uI || isNaN(e.translate)) && (e.translate = 0)
}
function la(e, t, n, s) {
    aw(e.x, t.x, n.x, s ? s.originX : void 0),
        aw(e.y, t.y, n.y, s ? s.originY : void 0)
}
function lw(e, t, n) {
    e.min = n.min + t.min,
        e.max = e.min + Xt(t)
}
function dI(e, t, n) {
    lw(e.x, t.x, n.x),
        lw(e.y, t.y, n.y)
}
function uw(e, t, n) {
    e.min = t.min - n.min,
        e.max = e.min + Xt(t)
}
function ua(e, t, n) {
    uw(e.x, t.x, n.x),
        uw(e.y, t.y, n.y)
}
function fI(e, {min: t, max: n}, s) {
    return t !== void 0 && e < t ? e = s ? qe(t, e, s.min) : Math.max(e, t) : n !== void 0 && e > n && (e = s ? qe(n, e, s.max) : Math.min(e, n)),
        e
}
function cw(e, t, n) {
    return {
        min: t !== void 0 ? e.min + t : void 0,
        max: n !== void 0 ? e.max + n - (e.max - e.min) : void 0
    }
}
function hI(e, {top: t, left: n, bottom: s, right: o}) {
    return {
        x: cw(e.x, n, o),
        y: cw(e.y, t, s)
    }
}
function dw(e, t) {
    let n = t.min - e.min
        , s = t.max - e.max;
    return t.max - t.min < e.max - e.min && ([n,s] = [s, n]),
        {
            min: n,
            max: s
        }
}
function pI(e, t) {
    return {
        x: dw(e.x, t.x),
        y: dw(e.y, t.y)
    }
}
function mI(e, t) {
    let n = .5;
    const s = Xt(e)
        , o = Xt(t);
    return o > s ? n = Wi(t.min, t.max - s, e.min) : s > o && (n = Wi(e.min, e.max - o, t.min)),
        ur(0, 1, n)
}
function gI(e, t) {
    const n = {};
    return t.min !== void 0 && (n.min = t.min - e.min),
    t.max !== void 0 && (n.max = t.max - e.min),
        n
}
const Wh = .35;
function yI(e=Wh) {
    return e === !1 ? e = 0 : e === !0 && (e = Wh),
        {
            x: fw(e, "left", "right"),
            y: fw(e, "top", "bottom")
        }
}
function fw(e, t, n) {
    return {
        min: hw(e, t),
        max: hw(e, n)
    }
}
function hw(e, t) {
    return typeof e == "number" ? e : e[t] || 0
}
const pw = () => ({
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0
})
    , Ei = () => ({
    x: pw(),
    y: pw()
})
    , mw = () => ({
    min: 0,
    max: 0
})
    , Je = () => ({
    x: mw(),
    y: mw()
});
function on(e) {
    return [e("x"), e("y")]
}
function xE({top: e, left: t, right: n, bottom: s}) {
    return {
        x: {
            min: t,
            max: n
        },
        y: {
            min: e,
            max: s
        }
    }
}
function vI({x: e, y: t}) {
    return {
        top: t.min,
        right: e.max,
        bottom: t.max,
        left: e.min
    }
}
function wI(e, t) {
    if (!t)
        return e;
    const n = t({
        x: e.left,
        y: e.top
    })
        , s = t({
        x: e.right,
        y: e.bottom
    });
    return {
        top: n.y,
        left: n.x,
        bottom: s.y,
        right: s.x
    }
}
function Bf(e) {
    return e === void 0 || e === 1
}
function Hh({scale: e, scaleX: t, scaleY: n}) {
    return !Bf(e) || !Bf(t) || !Bf(n)
}
function ws(e) {
    return Hh(e) || SE(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY
}
function SE(e) {
    return gw(e.x) || gw(e.y)
}
function gw(e) {
    return e && e !== "0%"
}
function Wu(e, t, n) {
    const s = e - n
        , o = t * s;
    return n + o
}
function yw(e, t, n, s, o) {
    return o !== void 0 && (e = Wu(e, o, s)),
    Wu(e, n, s) + t
}
function qh(e, t=0, n=1, s, o) {
    e.min = yw(e.min, t, n, s, o),
        e.max = yw(e.max, t, n, s, o)
}
function bE(e, {x: t, y: n}) {
    qh(e.x, t.translate, t.scale, t.originPoint),
        qh(e.y, n.translate, n.scale, n.originPoint)
}
const vw = .999999999999
    , ww = 1.0000000000001;
function xI(e, t, n, s=!1) {
    const o = n.length;
    if (!o)
        return;
    t.x = t.y = 1;
    let u, l;
    for (let d = 0; d < o; d++) {
        u = n[d],
            l = u.projectionDelta;
        const {visualElement: f} = u.options;
        f && f.props.style && f.props.style.display === "contents" || (s && u.options.layoutScroll && u.scroll && u !== u.root && Pi(e, {
            x: -u.scroll.offset.x,
            y: -u.scroll.offset.y
        }),
        l && (t.x *= l.x.scale,
            t.y *= l.y.scale,
            bE(e, l)),
        s && ws(u.latestValues) && Pi(e, u.latestValues))
    }
    t.x < ww && t.x > vw && (t.x = 1),
    t.y < ww && t.y > vw && (t.y = 1)
}
function Ci(e, t) {
    e.min = e.min + t,
        e.max = e.max + t
}
function xw(e, t, n, s, o=.5) {
    const u = qe(e.min, e.max, o);
    qh(e, t, n, u, s)
}
function Pi(e, t) {
    xw(e.x, t.x, t.scaleX, t.scale, t.originX),
        xw(e.y, t.y, t.scaleY, t.scale, t.originY)
}
function EE(e, t) {
    return xE(wI(e.getBoundingClientRect(), t))
}
function SI(e, t, n) {
    const s = EE(e, n)
        , {scroll: o} = t;
    return o && (Ci(s.x, o.offset.x),
        Ci(s.y, o.offset.y)),
        s
}
const CE = ({current: e}) => e ? e.ownerDocument.defaultView : null
    , bI = new WeakMap;
class EI {
    constructor(t) {
        this.openDragLock = null,
            this.isDragging = !1,
            this.currentDirection = null,
            this.originPoint = {
                x: 0,
                y: 0
            },
            this.constraints = !1,
            this.hasMutatedConstraints = !1,
            this.elastic = Je(),
            this.visualElement = t
    }
    start(t, {snapToCursor: n=!1}={}) {
        const {presenceContext: s} = this.visualElement;
        if (s && s.isPresent === !1)
            return;
        const o = m => {
            const {dragSnapToOrigin: y} = this.getProps();
            y ? this.pauseAnimation() : this.stopAnimation(),
            n && this.snapToCursor(Va(m).point)
        }
            , u = (m, y) => {
            const {drag: v, dragPropagation: S, onDragStart: E} = this.getProps();
            if (v && !S && (this.openDragLock && this.openDragLock(),
                this.openDragLock = pj(v),
                !this.openDragLock))
                return;
            this.isDragging = !0,
                this.currentDirection = null,
                this.resolveConstraints(),
            this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0,
                this.visualElement.projection.target = void 0),
                on(x => {
                        let T = this.getAxisMotionValue(x).get() || 0;
                        if (Vn.test(T)) {
                            const {projection: k} = this.visualElement;
                            if (k && k.layout) {
                                const R = k.layout.layoutBox[x];
                                R && (T = Xt(R) * (parseFloat(T) / 100))
                            }
                        }
                        this.originPoint[x] = T
                    }
                ),
            E && ze.postRender( () => E(m, y)),
                Dh(this.visualElement, "transform");
            const {animationState: w} = this.visualElement;
            w && w.setActive("whileDrag", !0)
        }
            , l = (m, y) => {
            const {dragPropagation: v, dragDirectionLock: S, onDirectionLock: E, onDrag: w} = this.getProps();
            if (!v && !this.openDragLock)
                return;
            const {offset: x} = y;
            if (S && this.currentDirection === null) {
                this.currentDirection = CI(x),
                this.currentDirection !== null && E && E(this.currentDirection);
                return
            }
            this.updateAxis("x", y.point, x),
                this.updateAxis("y", y.point, x),
                this.visualElement.render(),
            w && w(m, y)
        }
            , d = (m, y) => this.stop(m, y)
            , f = () => on(m => {
                var y;
                return this.getAnimationState(m) === "paused" && ((y = this.getAxisMotionValue(m).animation) === null || y === void 0 ? void 0 : y.play())
            }
        )
            , {dragSnapToOrigin: p} = this.getProps();
        this.panSession = new gE(t,{
            onSessionStart: o,
            onStart: u,
            onMove: l,
            onSessionEnd: d,
            resumeAnimation: f
        },{
            transformPagePoint: this.visualElement.getTransformPagePoint(),
            dragSnapToOrigin: p,
            contextWindow: CE(this.visualElement)
        })
    }
    stop(t, n) {
        const s = this.isDragging;
        if (this.cancel(),
            !s)
            return;
        const {velocity: o} = n;
        this.startAnimation(o);
        const {onDragEnd: u} = this.getProps();
        u && ze.postRender( () => u(t, n))
    }
    cancel() {
        this.isDragging = !1;
        const {projection: t, animationState: n} = this.visualElement;
        t && (t.isAnimationBlocked = !1),
        this.panSession && this.panSession.end(),
            this.panSession = void 0;
        const {dragPropagation: s} = this.getProps();
        !s && this.openDragLock && (this.openDragLock(),
            this.openDragLock = null),
        n && n.setActive("whileDrag", !1)
    }
    updateAxis(t, n, s) {
        const {drag: o} = this.getProps();
        if (!s || !du(t, o, this.currentDirection))
            return;
        const u = this.getAxisMotionValue(t);
        let l = this.originPoint[t] + s[t];
        this.constraints && this.constraints[t] && (l = fI(l, this.constraints[t], this.elastic[t])),
            u.set(l)
    }
    resolveConstraints() {
        var t;
        const {dragConstraints: n, dragElastic: s} = this.getProps()
            , o = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (t = this.visualElement.projection) === null || t === void 0 ? void 0 : t.layout
            , u = this.constraints;
        n && Si(n) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : n && o ? this.constraints = hI(o.layoutBox, n) : this.constraints = !1,
            this.elastic = yI(s),
        u !== this.constraints && o && this.constraints && !this.hasMutatedConstraints && on(l => {
                this.constraints !== !1 && this.getAxisMotionValue(l) && (this.constraints[l] = gI(o.layoutBox[l], this.constraints[l]))
            }
        )
    }
    resolveRefConstraints() {
        const {dragConstraints: t, onMeasureDragConstraints: n} = this.getProps();
        if (!t || !Si(t))
            return !1;
        const s = t.current
            , {projection: o} = this.visualElement;
        if (!o || !o.layout)
            return !1;
        const u = SI(s, o.root, this.visualElement.getTransformPagePoint());
        let l = pI(o.layout.layoutBox, u);
        if (n) {
            const d = n(vI(l));
            this.hasMutatedConstraints = !!d,
            d && (l = xE(d))
        }
        return l
    }
    startAnimation(t) {
        const {drag: n, dragMomentum: s, dragElastic: o, dragTransition: u, dragSnapToOrigin: l, onDragTransitionEnd: d} = this.getProps()
            , f = this.constraints || {}
            , p = on(m => {
                if (!du(m, n, this.currentDirection))
                    return;
                let y = f && f[m] || {};
                l && (y = {
                    min: 0,
                    max: 0
                });
                const v = o ? 200 : 1e6
                    , S = o ? 40 : 1e7
                    , E = {
                    type: "inertia",
                    velocity: s ? t[m] : 0,
                    bounceStiffness: v,
                    bounceDamping: S,
                    timeConstant: 750,
                    restDelta: 1,
                    restSpeed: 10,
                    ...u,
                    ...y
                };
                return this.startAxisValueAnimation(m, E)
            }
        );
        return Promise.all(p).then(d)
    }
    startAxisValueAnimation(t, n) {
        const s = this.getAxisMotionValue(t);
        return Dh(this.visualElement, t),
            s.start(am(t, s, 0, n, this.visualElement, !1))
    }
    stopAnimation() {
        on(t => this.getAxisMotionValue(t).stop())
    }
    pauseAnimation() {
        on(t => {
                var n;
                return (n = this.getAxisMotionValue(t).animation) === null || n === void 0 ? void 0 : n.pause()
            }
        )
    }
    getAnimationState(t) {
        var n;
        return (n = this.getAxisMotionValue(t).animation) === null || n === void 0 ? void 0 : n.state
    }
    getAxisMotionValue(t) {
        const n = `_drag${t.toUpperCase()}`
            , s = this.visualElement.getProps()
            , o = s[n];
        return o || this.visualElement.getValue(t, (s.initial ? s.initial[t] : void 0) || 0)
    }
    snapToCursor(t) {
        on(n => {
                const {drag: s} = this.getProps();
                if (!du(n, s, this.currentDirection))
                    return;
                const {projection: o} = this.visualElement
                    , u = this.getAxisMotionValue(n);
                if (o && o.layout) {
                    const {min: l, max: d} = o.layout.layoutBox[n];
                    u.set(t[n] - qe(l, d, .5))
                }
            }
        )
    }
    scalePositionWithinConstraints() {
        if (!this.visualElement.current)
            return;
        const {drag: t, dragConstraints: n} = this.getProps()
            , {projection: s} = this.visualElement;
        if (!Si(n) || !s || !this.constraints)
            return;
        this.stopAnimation();
        const o = {
            x: 0,
            y: 0
        };
        on(l => {
                const d = this.getAxisMotionValue(l);
                if (d && this.constraints !== !1) {
                    const f = d.get();
                    o[l] = mI({
                        min: f,
                        max: f
                    }, this.constraints[l])
                }
            }
        );
        const {transformTemplate: u} = this.visualElement.getProps();
        this.visualElement.current.style.transform = u ? u({}, "") : "none",
        s.root && s.root.updateScroll(),
            s.updateLayout(),
            this.resolveConstraints(),
            on(l => {
                    if (!du(l, t, null))
                        return;
                    const d = this.getAxisMotionValue(l)
                        , {min: f, max: p} = this.constraints[l];
                    d.set(qe(f, p, o[l]))
                }
            )
    }
    addListeners() {
        if (!this.visualElement.current)
            return;
        bI.set(this.visualElement, this);
        const t = this.visualElement.current
            , n = aa(t, "pointerdown", f => {
                const {drag: p, dragListener: m=!0} = this.getProps();
                p && m && this.start(f)
            }
        )
            , s = () => {
            const {dragConstraints: f} = this.getProps();
            Si(f) && f.current && (this.constraints = this.resolveRefConstraints())
        }
            , {projection: o} = this.visualElement
            , u = o.addEventListener("measure", s);
        o && !o.layout && (o.root && o.root.updateScroll(),
            o.updateLayout()),
            ze.read(s);
        const l = ba(window, "resize", () => this.scalePositionWithinConstraints())
            , d = o.addEventListener("didUpdate", ( ({delta: f, hasLayoutChanged: p}) => {
                this.isDragging && p && (on(m => {
                        const y = this.getAxisMotionValue(m);
                        y && (this.originPoint[m] += f[m].translate,
                            y.set(y.get() + f[m].translate))
                    }
                ),
                    this.visualElement.render())
            }
        ));
        return () => {
            l(),
                n(),
                u(),
            d && d()
        }
    }
    getProps() {
        const t = this.visualElement.getProps()
            , {drag: n=!1, dragDirectionLock: s=!1, dragPropagation: o=!1, dragConstraints: u=!1, dragElastic: l=Wh, dragMomentum: d=!0} = t;
        return {
            ...t,
            drag: n,
            dragDirectionLock: s,
            dragPropagation: o,
            dragConstraints: u,
            dragElastic: l,
            dragMomentum: d
        }
    }
}
function du(e, t, n) {
    return (t === !0 || t === e) && (n === null || n === e)
}
function CI(e, t=10) {
    let n = null;
    return Math.abs(e.y) > t ? n = "y" : Math.abs(e.x) > t && (n = "x"),
        n
}
class PI extends rs {
    constructor(t) {
        super(t),
            this.removeGroupControls = Gt,
            this.removeListeners = Gt,
            this.controls = new EI(t)
    }
    mount() {
        const {dragControls: t} = this.node.getProps();
        t && (this.removeGroupControls = t.subscribe(this.controls)),
            this.removeListeners = this.controls.addListeners() || Gt
    }
    unmount() {
        this.removeGroupControls(),
            this.removeListeners()
    }
}
const Sw = e => (t, n) => {
        e && ze.postRender( () => e(t, n))
    }
;
class TI extends rs {
    constructor() {
        super(...arguments),
            this.removePointerDownListener = Gt
    }
    onPointerDown(t) {
        this.session = new gE(t,this.createPanHandlers(),{
            transformPagePoint: this.node.getTransformPagePoint(),
            contextWindow: CE(this.node)
        })
    }
    createPanHandlers() {
        const {onPanSessionStart: t, onPanStart: n, onPan: s, onPanEnd: o} = this.node.getProps();
        return {
            onSessionStart: Sw(t),
            onStart: Sw(n),
            onMove: s,
            onEnd: (u, l) => {
                delete this.session,
                o && ze.postRender( () => o(u, l))
            }
        }
    }
    mount() {
        this.removePointerDownListener = aa(this.node.current, "pointerdown", t => this.onPointerDown(t))
    }
    update() {
        this.session && this.session.updateHandlers(this.createPanHandlers())
    }
    unmount() {
        this.removePointerDownListener(),
        this.session && this.session.end()
    }
}
function kI() {
    const e = P.useContext(_p);
    if (e === null)
        return [!0, null];
    const {isPresent: t, onExitComplete: n, register: s} = e
        , o = P.useId();
    P.useEffect( () => s(o), []);
    const u = P.useCallback( () => n && n(o), [o, n]);
    return !t && n ? [!1, u] : [!0]
}
const ku = {
    hasAnimatedSinceResize: !0,
    hasEverUpdated: !1
};
function bw(e, t) {
    return t.max === t.min ? 0 : e / (t.max - t.min) * 100
}
const Qo = {
    correct: (e, t) => {
        if (!t.target)
            return e;
        if (typeof e == "string")
            if (Se.test(e))
                e = parseFloat(e);
            else
                return e;
        const n = bw(e, t.target.x)
            , s = bw(e, t.target.y);
        return `${n}% ${s}%`
    }
}
    , RI = {
    correct: (e, {treeScale: t, projectionDelta: n}) => {
        const s = e
            , o = es.parse(e);
        if (o.length > 5)
            return s;
        const u = es.createTransformer(e)
            , l = typeof o[0] != "number" ? 1 : 0
            , d = n.x.scale * t.x
            , f = n.y.scale * t.y;
        o[0 + l] /= d,
            o[1 + l] /= f;
        const p = qe(d, f, .5);
        return typeof o[2 + l] == "number" && (o[2 + l] /= p),
        typeof o[3 + l] == "number" && (o[3 + l] /= p),
            u(o)
    }
};
class AI extends P.Component {
    componentDidMount() {
        const {visualElement: t, layoutGroup: n, switchLayoutGroup: s, layoutId: o} = this.props
            , {projection: u} = t;
        N2(_I),
        u && (n.group && n.group.add(u),
        s && s.register && o && s.register(u),
            u.root.didUpdate(),
            u.addEventListener("animationComplete", () => {
                    this.safeToRemove()
                }
            ),
            u.setOptions({
                ...u.options,
                onExitComplete: () => this.safeToRemove()
            })),
            ku.hasEverUpdated = !0
    }
    getSnapshotBeforeUpdate(t) {
        const {layoutDependency: n, visualElement: s, drag: o, isPresent: u} = this.props
            , l = s.projection;
        return l && (l.isPresent = u,
            o || t.layoutDependency !== n || n === void 0 ? l.willUpdate() : this.safeToRemove(),
        t.isPresent !== u && (u ? l.promote() : l.relegate() || ze.postRender( () => {
                const d = l.getStack();
                (!d || !d.members.length) && this.safeToRemove()
            }
        ))),
            null
    }
    componentDidUpdate() {
        const {projection: t} = this.props.visualElement;
        t && (t.root.didUpdate(),
            Dp.postRender( () => {
                    !t.currentAnimation && t.isLead() && this.safeToRemove()
                }
            ))
    }
    componentWillUnmount() {
        const {visualElement: t, layoutGroup: n, switchLayoutGroup: s} = this.props
            , {projection: o} = t;
        o && (o.scheduleCheckAfterUnmount(),
        n && n.group && n.group.remove(o),
        s && s.deregister && s.deregister(o))
    }
    safeToRemove() {
        const {safeToRemove: t} = this.props;
        t && t()
    }
    render() {
        return null
    }
}
function PE(e) {
    const [t,n] = kI()
        , s = P.useContext(u1);
    return b.jsx(AI, {
        ...e,
        layoutGroup: s,
        switchLayoutGroup: P.useContext(g1),
        isPresent: t,
        safeToRemove: n
    })
}
const _I = {
    borderRadius: {
        ...Qo,
        applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
    },
    borderTopLeftRadius: Qo,
    borderTopRightRadius: Qo,
    borderBottomLeftRadius: Qo,
    borderBottomRightRadius: Qo,
    boxShadow: RI
};
function NI(e, t, n) {
    const s = Tt(e) ? e : xa(e);
    return s.start(am("", s, t, n)),
        s.animation
}
function OI(e) {
    return e instanceof SVGElement && e.tagName !== "svg"
}
const LI = (e, t) => e.depth - t.depth;
class MI {
    constructor() {
        this.children = [],
            this.isDirty = !1
    }
    add(t) {
        Xp(this.children, t),
            this.isDirty = !0
    }
    remove(t) {
        Yp(this.children, t),
            this.isDirty = !0
    }
    forEach(t) {
        this.isDirty && this.children.sort(LI),
            this.isDirty = !1,
            this.children.forEach(t)
    }
}
function jI(e, t) {
    const n = Un.now()
        , s = ({timestamp: o}) => {
            const u = o - n;
            u >= t && (Zr(s),
                e(u - t))
        }
    ;
    return ze.read(s, !0),
        () => Zr(s)
}
const TE = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"]
    , DI = TE.length
    , Ew = e => typeof e == "string" ? parseFloat(e) : e
    , Cw = e => typeof e == "number" || Se.test(e);
function II(e, t, n, s, o, u) {
    o ? (e.opacity = qe(0, n.opacity !== void 0 ? n.opacity : 1, FI(s)),
        e.opacityExit = qe(t.opacity !== void 0 ? t.opacity : 1, 0, BI(s))) : u && (e.opacity = qe(t.opacity !== void 0 ? t.opacity : 1, n.opacity !== void 0 ? n.opacity : 1, s));
    for (let l = 0; l < DI; l++) {
        const d = `border${TE[l]}Radius`;
        let f = Pw(t, d)
            , p = Pw(n, d);
        if (f === void 0 && p === void 0)
            continue;
        f || (f = 0),
        p || (p = 0),
            f === 0 || p === 0 || Cw(f) === Cw(p) ? (e[d] = Math.max(qe(Ew(f), Ew(p), s), 0),
            (Vn.test(p) || Vn.test(f)) && (e[d] += "%")) : e[d] = p
    }
    (t.rotate || n.rotate) && (e.rotate = qe(t.rotate || 0, n.rotate || 0, s))
}
function Pw(e, t) {
    return e[t] !== void 0 ? e[t] : e.borderRadius
}
const FI = kE(0, .5, H1)
    , BI = kE(.5, .95, Gt);
function kE(e, t, n) {
    return s => s < e ? 0 : s > t ? 1 : n(Wi(e, t, s))
}
function Tw(e, t) {
    e.min = t.min,
        e.max = t.max
}
function sn(e, t) {
    Tw(e.x, t.x),
        Tw(e.y, t.y)
}
function kw(e, t) {
    e.translate = t.translate,
        e.scale = t.scale,
        e.originPoint = t.originPoint,
        e.origin = t.origin
}
function Rw(e, t, n, s, o) {
    return e -= t,
        e = Wu(e, 1 / n, s),
    o !== void 0 && (e = Wu(e, 1 / o, s)),
        e
}
function VI(e, t=0, n=1, s=.5, o, u=e, l=e) {
    if (Vn.test(t) && (t = parseFloat(t),
        t = qe(l.min, l.max, t / 100) - l.min),
    typeof t != "number")
        return;
    let d = qe(u.min, u.max, s);
    e === u && (d -= t),
        e.min = Rw(e.min, t, n, d, o),
        e.max = Rw(e.max, t, n, d, o)
}
function Aw(e, t, [n,s,o], u, l) {
    VI(e, t[n], t[s], t[o], t.scale, u, l)
}
const UI = ["x", "scaleX", "originX"]
    , zI = ["y", "scaleY", "originY"];
function _w(e, t, n, s) {
    Aw(e.x, t, UI, n ? n.x : void 0, s ? s.x : void 0),
        Aw(e.y, t, zI, n ? n.y : void 0, s ? s.y : void 0)
}
function Nw(e) {
    return e.translate === 0 && e.scale === 1
}
function RE(e) {
    return Nw(e.x) && Nw(e.y)
}
function Ow(e, t) {
    return e.min === t.min && e.max === t.max
}
function $I(e, t) {
    return Ow(e.x, t.x) && Ow(e.y, t.y)
}
function Lw(e, t) {
    return Math.round(e.min) === Math.round(t.min) && Math.round(e.max) === Math.round(t.max)
}
function AE(e, t) {
    return Lw(e.x, t.x) && Lw(e.y, t.y)
}
function Mw(e) {
    return Xt(e.x) / Xt(e.y)
}
function jw(e, t) {
    return e.translate === t.translate && e.scale === t.scale && e.originPoint === t.originPoint
}
class WI {
    constructor() {
        this.members = []
    }
    add(t) {
        Xp(this.members, t),
            t.scheduleRender()
    }
    remove(t) {
        if (Yp(this.members, t),
        t === this.prevLead && (this.prevLead = void 0),
        t === this.lead) {
            const n = this.members[this.members.length - 1];
            n && this.promote(n)
        }
    }
    relegate(t) {
        const n = this.members.findIndex(o => t === o);
        if (n === 0)
            return !1;
        let s;
        for (let o = n; o >= 0; o--) {
            const u = this.members[o];
            if (u.isPresent !== !1) {
                s = u;
                break
            }
        }
        return s ? (this.promote(s),
            !0) : !1
    }
    promote(t, n) {
        const s = this.lead;
        if (t !== s && (this.prevLead = s,
            this.lead = t,
            t.show(),
            s)) {
            s.instance && s.scheduleRender(),
                t.scheduleRender(),
                t.resumeFrom = s,
            n && (t.resumeFrom.preserveOpacity = !0),
            s.snapshot && (t.snapshot = s.snapshot,
                t.snapshot.latestValues = s.animationValues || s.latestValues),
            t.root && t.root.isUpdating && (t.isLayoutDirty = !0);
            const {crossfade: o} = t.options;
            o === !1 && s.hide()
        }
    }
    exitAnimationComplete() {
        this.members.forEach(t => {
                const {options: n, resumingFrom: s} = t;
                n.onExitComplete && n.onExitComplete(),
                s && s.options.onExitComplete && s.options.onExitComplete()
            }
        )
    }
    scheduleRender() {
        this.members.forEach(t => {
                t.instance && t.scheduleRender(!1)
            }
        )
    }
    removeLeadSnapshot() {
        this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
    }
}
function HI(e, t, n) {
    let s = "";
    const o = e.x.translate / t.x
        , u = e.y.translate / t.y
        , l = (n == null ? void 0 : n.z) || 0;
    if ((o || u || l) && (s = `translate3d(${o}px, ${u}px, ${l}px) `),
    (t.x !== 1 || t.y !== 1) && (s += `scale(${1 / t.x}, ${1 / t.y}) `),
        n) {
        const {transformPerspective: p, rotate: m, rotateX: y, rotateY: v, skewX: S, skewY: E} = n;
        p && (s = `perspective(${p}px) ${s}`),
        m && (s += `rotate(${m}deg) `),
        y && (s += `rotateX(${y}deg) `),
        v && (s += `rotateY(${v}deg) `),
        S && (s += `skewX(${S}deg) `),
        E && (s += `skewY(${E}deg) `)
    }
    const d = e.x.scale * t.x
        , f = e.y.scale * t.y;
    return (d !== 1 || f !== 1) && (s += `scale(${d}, ${f})`),
    s || "none"
}
const xs = {
    type: "projectionFrame",
    totalNodes: 0,
    resolvedTargetDeltas: 0,
    recalculatedProjection: 0
}
    , ta = typeof window < "u" && window.MotionDebug !== void 0
    , Vf = ["", "X", "Y", "Z"]
    , qI = {
    visibility: "hidden"
}
    , Dw = 1e3;
let KI = 0;
function Uf(e, t, n, s) {
    const {latestValues: o} = t;
    o[e] && (n[e] = o[e],
        t.setStaticValue(e, 0),
    s && (s[e] = 0))
}
function _E(e) {
    if (e.hasCheckedOptimisedAppear = !0,
    e.root === e)
        return;
    const {visualElement: t} = e.options;
    if (!t)
        return;
    const n = F1(t);
    if (window.MotionHasOptimisedAnimation(n, "transform")) {
        const {layout: o, layoutId: u} = e.options;
        window.MotionCancelOptimisedAnimation(n, "transform", ze, !(o || u))
    }
    const {parent: s} = e;
    s && !s.hasCheckedOptimisedAppear && _E(s)
}
function NE({attachResizeListener: e, defaultParent: t, measureScroll: n, checkIsScrollRoot: s, resetTransform: o}) {
    return class {
        constructor(l={}, d=t == null ? void 0 : t()) {
            this.id = KI++,
                this.animationId = 0,
                this.children = new Set,
                this.options = {},
                this.isTreeAnimating = !1,
                this.isAnimationBlocked = !1,
                this.isLayoutDirty = !1,
                this.isProjectionDirty = !1,
                this.isSharedProjectionDirty = !1,
                this.isTransformDirty = !1,
                this.updateManuallyBlocked = !1,
                this.updateBlockedByResize = !1,
                this.isUpdating = !1,
                this.isSVG = !1,
                this.needsReset = !1,
                this.shouldResetTransform = !1,
                this.hasCheckedOptimisedAppear = !1,
                this.treeScale = {
                    x: 1,
                    y: 1
                },
                this.eventHandlers = new Map,
                this.hasTreeAnimated = !1,
                this.updateScheduled = !1,
                this.scheduleUpdate = () => this.update(),
                this.projectionUpdateScheduled = !1,
                this.checkUpdateFailed = () => {
                    this.isUpdating && (this.isUpdating = !1,
                        this.clearAllSnapshots())
                }
                ,
                this.updateProjection = () => {
                    this.projectionUpdateScheduled = !1,
                    ta && (xs.totalNodes = xs.resolvedTargetDeltas = xs.recalculatedProjection = 0),
                        this.nodes.forEach(XI),
                        this.nodes.forEach(tF),
                        this.nodes.forEach(nF),
                        this.nodes.forEach(YI),
                    ta && window.MotionDebug.record(xs)
                }
                ,
                this.resolvedRelativeTargetAt = 0,
                this.hasProjected = !1,
                this.isVisible = !0,
                this.animationProgress = 0,
                this.sharedNodes = new Map,
                this.latestValues = l,
                this.root = d ? d.root || d : this,
                this.path = d ? [...d.path, d] : [],
                this.parent = d,
                this.depth = d ? d.depth + 1 : 0;
            for (let f = 0; f < this.path.length; f++)
                this.path[f].shouldResetTransform = !0;
            this.root === this && (this.nodes = new MI)
        }
        addEventListener(l, d) {
            return this.eventHandlers.has(l) || this.eventHandlers.set(l, new Jp),
                this.eventHandlers.get(l).add(d)
        }
        notifyListeners(l, ...d) {
            const f = this.eventHandlers.get(l);
            f && f.notify(...d)
        }
        hasListeners(l) {
            return this.eventHandlers.has(l)
        }
        mount(l, d=this.root.hasTreeAnimated) {
            if (this.instance)
                return;
            this.isSVG = OI(l),
                this.instance = l;
            const {layoutId: f, layout: p, visualElement: m} = this.options;
            if (m && !m.current && m.mount(l),
                this.root.nodes.add(this),
            this.parent && this.parent.children.add(this),
            d && (p || f) && (this.isLayoutDirty = !0),
                e) {
                let y;
                const v = () => this.root.updateBlockedByResize = !1;
                e(l, () => {
                        this.root.updateBlockedByResize = !0,
                        y && y(),
                            y = jI(v, 250),
                        ku.hasAnimatedSinceResize && (ku.hasAnimatedSinceResize = !1,
                            this.nodes.forEach(Fw))
                    }
                )
            }
            f && this.root.registerSharedNode(f, this),
            this.options.animate !== !1 && m && (f || p) && this.addEventListener("didUpdate", ({delta: y, hasLayoutChanged: v, hasRelativeTargetChanged: S, layout: E}) => {
                    if (this.isTreeAnimationBlocked()) {
                        this.target = void 0,
                            this.relativeTarget = void 0;
                        return
                    }
                    const w = this.options.transition || m.getDefaultTransition() || aF
                        , {onLayoutAnimationStart: x, onLayoutAnimationComplete: T} = m.getProps()
                        , k = !this.targetLayout || !AE(this.targetLayout, E) || S
                        , R = !v && S;
                    if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || R || v && (k || !this.currentAnimation)) {
                        this.resumeFrom && (this.resumingFrom = this.resumeFrom,
                            this.resumingFrom.resumingFrom = void 0),
                            this.setAnimationOrigin(y, R);
                        const _ = {
                            ...qp(w, "layout"),
                            onPlay: x,
                            onComplete: T
                        };
                        (m.shouldReduceMotion || this.options.layoutRoot) && (_.delay = 0,
                            _.type = !1),
                            this.startAnimation(_)
                    } else
                        v || Fw(this),
                        this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
                    this.targetLayout = E
                }
            )
        }
        unmount() {
            this.options.layoutId && this.willUpdate(),
                this.root.nodes.remove(this);
            const l = this.getStack();
            l && l.remove(this),
            this.parent && this.parent.children.delete(this),
                this.instance = void 0,
                Zr(this.updateProjection)
        }
        blockUpdate() {
            this.updateManuallyBlocked = !0
        }
        unblockUpdate() {
            this.updateManuallyBlocked = !1
        }
        isUpdateBlocked() {
            return this.updateManuallyBlocked || this.updateBlockedByResize
        }
        isTreeAnimationBlocked() {
            return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1
        }
        startUpdate() {
            this.isUpdateBlocked() || (this.isUpdating = !0,
            this.nodes && this.nodes.forEach(rF),
                this.animationId++)
        }
        getTransformTemplate() {
            const {visualElement: l} = this.options;
            return l && l.getProps().transformTemplate
        }
        willUpdate(l=!0) {
            if (this.root.hasTreeAnimated = !0,
                this.root.isUpdateBlocked()) {
                this.options.onExitComplete && this.options.onExitComplete();
                return
            }
            if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && _E(this),
            !this.root.isUpdating && this.root.startUpdate(),
                this.isLayoutDirty)
                return;
            this.isLayoutDirty = !0;
            for (let m = 0; m < this.path.length; m++) {
                const y = this.path[m];
                y.shouldResetTransform = !0,
                    y.updateScroll("snapshot"),
                y.options.layoutRoot && y.willUpdate(!1)
            }
            const {layoutId: d, layout: f} = this.options;
            if (d === void 0 && !f)
                return;
            const p = this.getTransformTemplate();
            this.prevTransformTemplateValue = p ? p(this.latestValues, "") : void 0,
                this.updateSnapshot(),
            l && this.notifyListeners("willUpdate")
        }
        update() {
            if (this.updateScheduled = !1,
                this.isUpdateBlocked()) {
                this.unblockUpdate(),
                    this.clearAllSnapshots(),
                    this.nodes.forEach(Iw);
                return
            }
            this.isUpdating || this.nodes.forEach(ZI),
                this.isUpdating = !1,
                this.nodes.forEach(eF),
                this.nodes.forEach(QI),
                this.nodes.forEach(GI),
                this.clearAllSnapshots();
            const d = Un.now();
            yt.delta = ur(0, 1e3 / 60, d - yt.timestamp),
                yt.timestamp = d,
                yt.isProcessing = !0,
                Nf.update.process(yt),
                Nf.preRender.process(yt),
                Nf.render.process(yt),
                yt.isProcessing = !1
        }
        didUpdate() {
            this.updateScheduled || (this.updateScheduled = !0,
                Dp.read(this.scheduleUpdate))
        }
        clearAllSnapshots() {
            this.nodes.forEach(JI),
                this.sharedNodes.forEach(sF)
        }
        scheduleUpdateProjection() {
            this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0,
                ze.preRender(this.updateProjection, !1, !0))
        }
        scheduleCheckAfterUnmount() {
            ze.postRender( () => {
                    this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
                }
            )
        }
        updateSnapshot() {
            this.snapshot || !this.instance || (this.snapshot = this.measure())
        }
        updateLayout() {
            if (!this.instance || (this.updateScroll(),
            !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
                return;
            if (this.resumeFrom && !this.resumeFrom.instance)
                for (let f = 0; f < this.path.length; f++)
                    this.path[f].updateScroll();
            const l = this.layout;
            this.layout = this.measure(!1),
                this.layoutCorrected = Je(),
                this.isLayoutDirty = !1,
                this.projectionDelta = void 0,
                this.notifyListeners("measure", this.layout.layoutBox);
            const {visualElement: d} = this.options;
            d && d.notify("LayoutMeasure", this.layout.layoutBox, l ? l.layoutBox : void 0)
        }
        updateScroll(l="measure") {
            let d = !!(this.options.layoutScroll && this.instance);
            if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === l && (d = !1),
                d) {
                const f = s(this.instance);
                this.scroll = {
                    animationId: this.root.animationId,
                    phase: l,
                    isRoot: f,
                    offset: n(this.instance),
                    wasRoot: this.scroll ? this.scroll.isRoot : f
                }
            }
        }
        resetTransform() {
            if (!o)
                return;
            const l = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout
                , d = this.projectionDelta && !RE(this.projectionDelta)
                , f = this.getTransformTemplate()
                , p = f ? f(this.latestValues, "") : void 0
                , m = p !== this.prevTransformTemplateValue;
            l && (d || ws(this.latestValues) || m) && (o(this.instance, p),
                this.shouldResetTransform = !1,
                this.scheduleRender())
        }
        measure(l=!0) {
            const d = this.measurePageBox();
            let f = this.removeElementScroll(d);
            return l && (f = this.removeTransform(f)),
                lF(f),
                {
                    animationId: this.root.animationId,
                    measuredBox: d,
                    layoutBox: f,
                    latestValues: {},
                    source: this.id
                }
        }
        measurePageBox() {
            var l;
            const {visualElement: d} = this.options;
            if (!d)
                return Je();
            const f = d.measureViewportBox();
            if (!(((l = this.scroll) === null || l === void 0 ? void 0 : l.wasRoot) || this.path.some(uF))) {
                const {scroll: m} = this.root;
                m && (Ci(f.x, m.offset.x),
                    Ci(f.y, m.offset.y))
            }
            return f
        }
        removeElementScroll(l) {
            var d;
            const f = Je();
            if (sn(f, l),
            !((d = this.scroll) === null || d === void 0) && d.wasRoot)
                return f;
            for (let p = 0; p < this.path.length; p++) {
                const m = this.path[p]
                    , {scroll: y, options: v} = m;
                m !== this.root && y && v.layoutScroll && (y.wasRoot && sn(f, l),
                    Ci(f.x, y.offset.x),
                    Ci(f.y, y.offset.y))
            }
            return f
        }
        applyTransform(l, d=!1) {
            const f = Je();
            sn(f, l);
            for (let p = 0; p < this.path.length; p++) {
                const m = this.path[p];
                !d && m.options.layoutScroll && m.scroll && m !== m.root && Pi(f, {
                    x: -m.scroll.offset.x,
                    y: -m.scroll.offset.y
                }),
                ws(m.latestValues) && Pi(f, m.latestValues)
            }
            return ws(this.latestValues) && Pi(f, this.latestValues),
                f
        }
        removeTransform(l) {
            const d = Je();
            sn(d, l);
            for (let f = 0; f < this.path.length; f++) {
                const p = this.path[f];
                if (!p.instance || !ws(p.latestValues))
                    continue;
                Hh(p.latestValues) && p.updateSnapshot();
                const m = Je()
                    , y = p.measurePageBox();
                sn(m, y),
                    _w(d, p.latestValues, p.snapshot ? p.snapshot.layoutBox : void 0, m)
            }
            return ws(this.latestValues) && _w(d, this.latestValues),
                d
        }
        setTargetDelta(l) {
            this.targetDelta = l,
                this.root.scheduleUpdateProjection(),
                this.isProjectionDirty = !0
        }
        setOptions(l) {
            this.options = {
                ...this.options,
                ...l,
                crossfade: l.crossfade !== void 0 ? l.crossfade : !0
            }
        }
        clearMeasurements() {
            this.scroll = void 0,
                this.layout = void 0,
                this.snapshot = void 0,
                this.prevTransformTemplateValue = void 0,
                this.targetDelta = void 0,
                this.target = void 0,
                this.isLayoutDirty = !1
        }
        forceRelativeParentToResolveTarget() {
            this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== yt.timestamp && this.relativeParent.resolveTargetDelta(!0)
        }
        resolveTargetDelta(l=!1) {
            var d;
            const f = this.getLead();
            this.isProjectionDirty || (this.isProjectionDirty = f.isProjectionDirty),
            this.isTransformDirty || (this.isTransformDirty = f.isTransformDirty),
            this.isSharedProjectionDirty || (this.isSharedProjectionDirty = f.isSharedProjectionDirty);
            const p = !!this.resumingFrom || this !== f;
            if (!(l || p && this.isSharedProjectionDirty || this.isProjectionDirty || !((d = this.parent) === null || d === void 0) && d.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
                return;
            const {layout: y, layoutId: v} = this.options;
            if (!(!this.layout || !(y || v))) {
                if (this.resolvedRelativeTargetAt = yt.timestamp,
                !this.targetDelta && !this.relativeTarget) {
                    const S = this.getClosestProjectingParent();
                    S && S.layout && this.animationProgress !== 1 ? (this.relativeParent = S,
                        this.forceRelativeParentToResolveTarget(),
                        this.relativeTarget = Je(),
                        this.relativeTargetOrigin = Je(),
                        ua(this.relativeTargetOrigin, this.layout.layoutBox, S.layout.layoutBox),
                        sn(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                }
                if (!(!this.relativeTarget && !this.targetDelta)) {
                    if (this.target || (this.target = Je(),
                        this.targetWithTransforms = Je()),
                        this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(),
                            dI(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : sn(this.target, this.layout.layoutBox),
                            bE(this.target, this.targetDelta)) : sn(this.target, this.layout.layoutBox),
                        this.attemptToResolveRelativeTarget) {
                        this.attemptToResolveRelativeTarget = !1;
                        const S = this.getClosestProjectingParent();
                        S && !!S.resumingFrom == !!this.resumingFrom && !S.options.layoutScroll && S.target && this.animationProgress !== 1 ? (this.relativeParent = S,
                            this.forceRelativeParentToResolveTarget(),
                            this.relativeTarget = Je(),
                            this.relativeTargetOrigin = Je(),
                            ua(this.relativeTargetOrigin, this.target, S.target),
                            sn(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                    }
                    ta && xs.resolvedTargetDeltas++
                }
            }
        }
        getClosestProjectingParent() {
            if (!(!this.parent || Hh(this.parent.latestValues) || SE(this.parent.latestValues)))
                return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
        }
        isProjecting() {
            return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
        }
        calcProjection() {
            var l;
            const d = this.getLead()
                , f = !!this.resumingFrom || this !== d;
            let p = !0;
            if ((this.isProjectionDirty || !((l = this.parent) === null || l === void 0) && l.isProjectionDirty) && (p = !1),
            f && (this.isSharedProjectionDirty || this.isTransformDirty) && (p = !1),
            this.resolvedRelativeTargetAt === yt.timestamp && (p = !1),
                p)
                return;
            const {layout: m, layoutId: y} = this.options;
            if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation),
            this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0),
            !this.layout || !(m || y))
                return;
            sn(this.layoutCorrected, this.layout.layoutBox);
            const v = this.treeScale.x
                , S = this.treeScale.y;
            xI(this.layoutCorrected, this.treeScale, this.path, f),
            d.layout && !d.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (d.target = d.layout.layoutBox,
                d.targetWithTransforms = Je());
            const {target: E} = d;
            if (!E) {
                this.prevProjectionDelta && (this.createProjectionDeltas(),
                    this.scheduleRender());
                return
            }
            !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (kw(this.prevProjectionDelta.x, this.projectionDelta.x),
                kw(this.prevProjectionDelta.y, this.projectionDelta.y)),
                la(this.projectionDelta, this.layoutCorrected, E, this.latestValues),
            (this.treeScale.x !== v || this.treeScale.y !== S || !jw(this.projectionDelta.x, this.prevProjectionDelta.x) || !jw(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0,
                this.scheduleRender(),
                this.notifyListeners("projectionUpdate", E)),
            ta && xs.recalculatedProjection++
        }
        hide() {
            this.isVisible = !1
        }
        show() {
            this.isVisible = !0
        }
        scheduleRender(l=!0) {
            var d;
            if ((d = this.options.visualElement) === null || d === void 0 || d.scheduleRender(),
                l) {
                const f = this.getStack();
                f && f.scheduleRender()
            }
            this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
        }
        createProjectionDeltas() {
            this.prevProjectionDelta = Ei(),
                this.projectionDelta = Ei(),
                this.projectionDeltaWithTransform = Ei()
        }
        setAnimationOrigin(l, d=!1) {
            const f = this.snapshot
                , p = f ? f.latestValues : {}
                , m = {
                ...this.latestValues
            }
                , y = Ei();
            (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0),
                this.attemptToResolveRelativeTarget = !d;
            const v = Je()
                , S = f ? f.source : void 0
                , E = this.layout ? this.layout.source : void 0
                , w = S !== E
                , x = this.getStack()
                , T = !x || x.members.length <= 1
                , k = !!(w && !T && this.options.crossfade === !0 && !this.path.some(oF));
            this.animationProgress = 0;
            let R;
            this.mixTargetDelta = _ => {
                const D = _ / 1e3;
                Bw(y.x, l.x, D),
                    Bw(y.y, l.y, D),
                    this.setTargetDelta(y),
                this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (ua(v, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
                    iF(this.relativeTarget, this.relativeTargetOrigin, v, D),
                R && $I(this.relativeTarget, R) && (this.isProjectionDirty = !1),
                R || (R = Je()),
                    sn(R, this.relativeTarget)),
                w && (this.animationValues = m,
                    II(m, p, this.latestValues, D, k, T)),
                    this.root.scheduleUpdateProjection(),
                    this.scheduleRender(),
                    this.animationProgress = D
            }
                ,
                this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
        }
        startAnimation(l) {
            this.notifyListeners("animationStart"),
            this.currentAnimation && this.currentAnimation.stop(),
            this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(),
            this.pendingAnimation && (Zr(this.pendingAnimation),
                this.pendingAnimation = void 0),
                this.pendingAnimation = ze.update( () => {
                        ku.hasAnimatedSinceResize = !0,
                            this.currentAnimation = NI(0, Dw, {
                                ...l,
                                onUpdate: d => {
                                    this.mixTargetDelta(d),
                                    l.onUpdate && l.onUpdate(d)
                                }
                                ,
                                onComplete: () => {
                                    l.onComplete && l.onComplete(),
                                        this.completeAnimation()
                                }
                            }),
                        this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation),
                            this.pendingAnimation = void 0
                    }
                )
        }
        completeAnimation() {
            this.resumingFrom && (this.resumingFrom.currentAnimation = void 0,
                this.resumingFrom.preserveOpacity = void 0);
            const l = this.getStack();
            l && l.exitAnimationComplete(),
                this.resumingFrom = this.currentAnimation = this.animationValues = void 0,
                this.notifyListeners("animationComplete")
        }
        finishAnimation() {
            this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(Dw),
                this.currentAnimation.stop()),
                this.completeAnimation()
        }
        applyTransformsToTarget() {
            const l = this.getLead();
            let {targetWithTransforms: d, target: f, layout: p, latestValues: m} = l;
            if (!(!d || !f || !p)) {
                if (this !== l && this.layout && p && OE(this.options.animationType, this.layout.layoutBox, p.layoutBox)) {
                    f = this.target || Je();
                    const y = Xt(this.layout.layoutBox.x);
                    f.x.min = l.target.x.min,
                        f.x.max = f.x.min + y;
                    const v = Xt(this.layout.layoutBox.y);
                    f.y.min = l.target.y.min,
                        f.y.max = f.y.min + v
                }
                sn(d, f),
                    Pi(d, m),
                    la(this.projectionDeltaWithTransform, this.layoutCorrected, d, m)
            }
        }
        registerSharedNode(l, d) {
            this.sharedNodes.has(l) || this.sharedNodes.set(l, new WI),
                this.sharedNodes.get(l).add(d);
            const p = d.options.initialPromotionConfig;
            d.promote({
                transition: p ? p.transition : void 0,
                preserveFollowOpacity: p && p.shouldPreserveFollowOpacity ? p.shouldPreserveFollowOpacity(d) : void 0
            })
        }
        isLead() {
            const l = this.getStack();
            return l ? l.lead === this : !0
        }
        getLead() {
            var l;
            const {layoutId: d} = this.options;
            return d ? ((l = this.getStack()) === null || l === void 0 ? void 0 : l.lead) || this : this
        }
        getPrevLead() {
            var l;
            const {layoutId: d} = this.options;
            return d ? (l = this.getStack()) === null || l === void 0 ? void 0 : l.prevLead : void 0
        }
        getStack() {
            const {layoutId: l} = this.options;
            if (l)
                return this.root.sharedNodes.get(l)
        }
        promote({needsReset: l, transition: d, preserveFollowOpacity: f}={}) {
            const p = this.getStack();
            p && p.promote(this, f),
            l && (this.projectionDelta = void 0,
                this.needsReset = !0),
            d && this.setOptions({
                transition: d
            })
        }
        relegate() {
            const l = this.getStack();
            return l ? l.relegate(this) : !1
        }
        resetSkewAndRotation() {
            const {visualElement: l} = this.options;
            if (!l)
                return;
            let d = !1;
            const {latestValues: f} = l;
            if ((f.z || f.rotate || f.rotateX || f.rotateY || f.rotateZ || f.skewX || f.skewY) && (d = !0),
                !d)
                return;
            const p = {};
            f.z && Uf("z", l, p, this.animationValues);
            for (let m = 0; m < Vf.length; m++)
                Uf(`rotate${Vf[m]}`, l, p, this.animationValues),
                    Uf(`skew${Vf[m]}`, l, p, this.animationValues);
            l.render();
            for (const m in p)
                l.setStaticValue(m, p[m]),
                this.animationValues && (this.animationValues[m] = p[m]);
            l.scheduleRender()
        }
        getProjectionStyles(l) {
            var d, f;
            if (!this.instance || this.isSVG)
                return;
            if (!this.isVisible)
                return qI;
            const p = {
                visibility: ""
            }
                , m = this.getTransformTemplate();
            if (this.needsReset)
                return this.needsReset = !1,
                    p.opacity = "",
                    p.pointerEvents = Pu(l == null ? void 0 : l.pointerEvents) || "",
                    p.transform = m ? m(this.latestValues, "") : "none",
                    p;
            const y = this.getLead();
            if (!this.projectionDelta || !this.layout || !y.target) {
                const w = {};
                return this.options.layoutId && (w.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1,
                    w.pointerEvents = Pu(l == null ? void 0 : l.pointerEvents) || ""),
                this.hasProjected && !ws(this.latestValues) && (w.transform = m ? m({}, "") : "none",
                    this.hasProjected = !1),
                    w
            }
            const v = y.animationValues || y.latestValues;
            this.applyTransformsToTarget(),
                p.transform = HI(this.projectionDeltaWithTransform, this.treeScale, v),
            m && (p.transform = m(v, p.transform));
            const {x: S, y: E} = this.projectionDelta;
            p.transformOrigin = `${S.origin * 100}% ${E.origin * 100}% 0`,
                y.animationValues ? p.opacity = y === this ? (f = (d = v.opacity) !== null && d !== void 0 ? d : this.latestValues.opacity) !== null && f !== void 0 ? f : 1 : this.preserveOpacity ? this.latestValues.opacity : v.opacityExit : p.opacity = y === this ? v.opacity !== void 0 ? v.opacity : "" : v.opacityExit !== void 0 ? v.opacityExit : 0;
            for (const w in Bu) {
                if (v[w] === void 0)
                    continue;
                const {correct: x, applyTo: T} = Bu[w]
                    , k = p.transform === "none" ? v[w] : x(v[w], y);
                if (T) {
                    const R = T.length;
                    for (let _ = 0; _ < R; _++)
                        p[T[_]] = k
                } else
                    p[w] = k
            }
            return this.options.layoutId && (p.pointerEvents = y === this ? Pu(l == null ? void 0 : l.pointerEvents) || "" : "none"),
                p
        }
        clearSnapshot() {
            this.resumeFrom = this.snapshot = void 0
        }
        resetTree() {
            this.root.nodes.forEach(l => {
                    var d;
                    return (d = l.currentAnimation) === null || d === void 0 ? void 0 : d.stop()
                }
            ),
                this.root.nodes.forEach(Iw),
                this.root.sharedNodes.clear()
        }
    }
}
function QI(e) {
    e.updateLayout()
}
function GI(e) {
    var t;
    const n = ((t = e.resumeFrom) === null || t === void 0 ? void 0 : t.snapshot) || e.snapshot;
    if (e.isLead() && e.layout && n && e.hasListeners("didUpdate")) {
        const {layoutBox: s, measuredBox: o} = e.layout
            , {animationType: u} = e.options
            , l = n.source !== e.layout.source;
        u === "size" ? on(y => {
                const v = l ? n.measuredBox[y] : n.layoutBox[y]
                    , S = Xt(v);
                v.min = s[y].min,
                    v.max = v.min + S
            }
        ) : OE(u, n.layoutBox, s) && on(y => {
                const v = l ? n.measuredBox[y] : n.layoutBox[y]
                    , S = Xt(s[y]);
                v.max = v.min + S,
                e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0,
                    e.relativeTarget[y].max = e.relativeTarget[y].min + S)
            }
        );
        const d = Ei();
        la(d, s, n.layoutBox);
        const f = Ei();
        l ? la(f, e.applyTransform(o, !0), n.measuredBox) : la(f, s, n.layoutBox);
        const p = !RE(d);
        let m = !1;
        if (!e.resumeFrom) {
            const y = e.getClosestProjectingParent();
            if (y && !y.resumeFrom) {
                const {snapshot: v, layout: S} = y;
                if (v && S) {
                    const E = Je();
                    ua(E, n.layoutBox, v.layoutBox);
                    const w = Je();
                    ua(w, s, S.layoutBox),
                    AE(E, w) || (m = !0),
                    y.options.layoutRoot && (e.relativeTarget = w,
                        e.relativeTargetOrigin = E,
                        e.relativeParent = y)
                }
            }
        }
        e.notifyListeners("didUpdate", {
            layout: s,
            snapshot: n,
            delta: f,
            layoutDelta: d,
            hasLayoutChanged: p,
            hasRelativeTargetChanged: m
        })
    } else if (e.isLead()) {
        const {onExitComplete: s} = e.options;
        s && s()
    }
    e.options.transition = void 0
}
function XI(e) {
    ta && xs.totalNodes++,
    e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty),
    e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)),
    e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty))
}
function YI(e) {
    e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1
}
function JI(e) {
    e.clearSnapshot()
}
function Iw(e) {
    e.clearMeasurements()
}
function ZI(e) {
    e.isLayoutDirty = !1
}
function eF(e) {
    const {visualElement: t} = e.options;
    t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"),
        e.resetTransform()
}
function Fw(e) {
    e.finishAnimation(),
        e.targetDelta = e.relativeTarget = e.target = void 0,
        e.isProjectionDirty = !0
}
function tF(e) {
    e.resolveTargetDelta()
}
function nF(e) {
    e.calcProjection()
}
function rF(e) {
    e.resetSkewAndRotation()
}
function sF(e) {
    e.removeLeadSnapshot()
}
function Bw(e, t, n) {
    e.translate = qe(t.translate, 0, n),
        e.scale = qe(t.scale, 1, n),
        e.origin = t.origin,
        e.originPoint = t.originPoint
}
function Vw(e, t, n, s) {
    e.min = qe(t.min, n.min, s),
        e.max = qe(t.max, n.max, s)
}
function iF(e, t, n, s) {
    Vw(e.x, t.x, n.x, s),
        Vw(e.y, t.y, n.y, s)
}
function oF(e) {
    return e.animationValues && e.animationValues.opacityExit !== void 0
}
const aF = {
    duration: .45,
    ease: [.4, 0, .1, 1]
}
    , Uw = e => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e)
    , zw = Uw("applewebkit/") && !Uw("chrome/") ? Math.round : Gt;
function $w(e) {
    e.min = zw(e.min),
        e.max = zw(e.max)
}
function lF(e) {
    $w(e.x),
        $w(e.y)
}
function OE(e, t, n) {
    return e === "position" || e === "preserve-aspect" && !cI(Mw(t), Mw(n), .2)
}
function uF(e) {
    var t;
    return e !== e.root && ((t = e.scroll) === null || t === void 0 ? void 0 : t.wasRoot)
}
const cF = NE({
    attachResizeListener: (e, t) => ba(e, "resize", t),
    measureScroll: () => ({
        x: document.documentElement.scrollLeft || document.body.scrollLeft,
        y: document.documentElement.scrollTop || document.body.scrollTop
    }),
    checkIsScrollRoot: () => !0
})
    , zf = {
    current: void 0
}
    , LE = NE({
    measureScroll: e => ({
        x: e.scrollLeft,
        y: e.scrollTop
    }),
    defaultParent: () => {
        if (!zf.current) {
            const e = new cF({});
            e.mount(window),
                e.setOptions({
                    layoutScroll: !0
                }),
                zf.current = e
        }
        return zf.current
    }
    ,
    resetTransform: (e, t) => {
        e.style.transform = t !== void 0 ? t : "none"
    }
    ,
    checkIsScrollRoot: e => window.getComputedStyle(e).position === "fixed"
})
    , dF = {
    pan: {
        Feature: TI
    },
    drag: {
        Feature: PI,
        ProjectionNode: LE,
        MeasureLayout: PE
    }
};
function Ww(e, t, n) {
    const {props: s} = e;
    e.animationState && s.whileHover && e.animationState.setActive("whileHover", n === "Start");
    const o = "onHover" + n
        , u = s[o];
    u && ze.postRender( () => u(t, Va(t)))
}
class fF extends rs {
    mount() {
        const {current: t} = this.node;
        t && (this.unmount = uj(t, n => (Ww(this.node, n, "Start"),
            s => Ww(this.node, s, "End"))))
    }
    unmount() {}
}
class hF extends rs {
    constructor() {
        super(...arguments),
            this.isActive = !1
    }
    onFocus() {
        let t = !1;
        try {
            t = this.node.current.matches(":focus-visible")
        } catch {
            t = !0
        }
        !t || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0),
            this.isActive = !0)
    }
    onBlur() {
        !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1),
            this.isActive = !1)
    }
    mount() {
        this.unmount = Ba(ba(this.node.current, "focus", () => this.onFocus()), ba(this.node.current, "blur", () => this.onBlur()))
    }
    unmount() {}
}
function Hw(e, t, n) {
    const {props: s} = e;
    e.animationState && s.whileTap && e.animationState.setActive("whileTap", n === "Start");
    const o = "onTap" + (n === "End" ? "" : n)
        , u = s[o];
    u && ze.postRender( () => u(t, Va(t)))
}
class pF extends rs {
    mount() {
        const {current: t} = this.node;
        t && (this.unmount = hj(t, n => (Hw(this.node, n, "Start"),
            (s, {success: o}) => Hw(this.node, s, o ? "End" : "Cancel")), {
            useGlobalTarget: this.node.props.globalTapTarget
        }))
    }
    unmount() {}
}
const Kh = new WeakMap
    , $f = new WeakMap
    , mF = e => {
        const t = Kh.get(e.target);
        t && t(e)
    }
    , gF = e => {
        e.forEach(mF)
    }
;
function yF({root: e, ...t}) {
    const n = e || document;
    $f.has(n) || $f.set(n, {});
    const s = $f.get(n)
        , o = JSON.stringify(t);
    return s[o] || (s[o] = new IntersectionObserver(gF,{
        root: e,
        ...t
    })),
        s[o]
}
function vF(e, t, n) {
    const s = yF(t);
    return Kh.set(e, n),
        s.observe(e),
        () => {
            Kh.delete(e),
                s.unobserve(e)
        }
}
const wF = {
    some: 0,
    all: 1
};
class xF extends rs {
    constructor() {
        super(...arguments),
            this.hasEnteredView = !1,
            this.isInView = !1
    }
    startObserver() {
        this.unmount();
        const {viewport: t={}} = this.node.getProps()
            , {root: n, margin: s, amount: o="some", once: u} = t
            , l = {
                root: n ? n.current : void 0,
                rootMargin: s,
                threshold: typeof o == "number" ? o : wF[o]
            }
            , d = f => {
                const {isIntersecting: p} = f;
                if (this.isInView === p || (this.isInView = p,
                u && !p && this.hasEnteredView))
                    return;
                p && (this.hasEnteredView = !0),
                this.node.animationState && this.node.animationState.setActive("whileInView", p);
                const {onViewportEnter: m, onViewportLeave: y} = this.node.getProps()
                    , v = p ? m : y;
                v && v(f)
            }
        ;
        return vF(this.node.current, l, d)
    }
    mount() {
        this.startObserver()
    }
    update() {
        if (typeof IntersectionObserver > "u")
            return;
        const {props: t, prevProps: n} = this.node;
        ["amount", "margin", "root"].some(SF(t, n)) && this.startObserver()
    }
    unmount() {}
}
function SF({viewport: e={}}, {viewport: t={}}={}) {
    return n => e[n] !== t[n]
}
const bF = {
    inView: {
        Feature: xF
    },
    tap: {
        Feature: pF
    },
    focus: {
        Feature: hF
    },
    hover: {
        Feature: fF
    }
}
    , EF = {
    layout: {
        ProjectionNode: LE,
        MeasureLayout: PE
    }
}
    , Qh = {
    current: null
}
    , ME = {
    current: !1
};
function CF() {
    if (ME.current = !0,
        !!Op)
        if (window.matchMedia) {
            const e = window.matchMedia("(prefers-reduced-motion)")
                , t = () => Qh.current = e.matches;
            e.addListener(t),
                t()
        } else
            Qh.current = !1
}
function PF(e, t, n) {
    for (const s in t) {
        const o = t[s]
            , u = n[s];
        if (Tt(o))
            e.addValue(s, o);
        else if (Tt(u))
            e.addValue(s, xa(o, {
                owner: e
            }));
        else if (u !== o)
            if (e.hasValue(s)) {
                const l = e.getValue(s);
                l.liveStyle === !0 ? l.jump(o) : l.hasAnimated || l.set(o)
            } else {
                const l = e.getStaticValue(s);
                e.addValue(s, xa(l !== void 0 ? l : o, {
                    owner: e
                }))
            }
    }
    for (const s in n)
        t[s] === void 0 && e.removeValue(s);
    return t
}
const qw = new WeakMap
    , TF = [...Y1, Ct, es]
    , kF = e => TF.find(X1(e))
    , Kw = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"];
class RF {
    scrapeMotionValuesFromProps(t, n, s) {
        return {}
    }
    constructor({parent: t, props: n, presenceContext: s, reducedMotionConfig: o, blockInitialAnimation: u, visualState: l}, d={}) {
        this.current = null,
            this.children = new Set,
            this.isVariantNode = !1,
            this.isControllingVariants = !1,
            this.shouldReduceMotion = null,
            this.values = new Map,
            this.KeyframeResolver = tm,
            this.features = {},
            this.valueSubscriptions = new Map,
            this.prevMotionValues = {},
            this.events = {},
            this.propEventSubscriptions = {},
            this.notifyUpdate = () => this.notify("Update", this.latestValues),
            this.render = () => {
                this.current && (this.triggerBuild(),
                    this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
            }
            ,
            this.renderScheduledAt = 0,
            this.scheduleRender = () => {
                const v = Un.now();
                this.renderScheduledAt < v && (this.renderScheduledAt = v,
                    ze.render(this.render, !1, !0))
            }
        ;
        const {latestValues: f, renderState: p} = l;
        this.latestValues = f,
            this.baseTarget = {
                ...f
            },
            this.initialValues = n.initial ? {
                ...f
            } : {},
            this.renderState = p,
            this.parent = t,
            this.props = n,
            this.presenceContext = s,
            this.depth = t ? t.depth + 1 : 0,
            this.reducedMotionConfig = o,
            this.options = d,
            this.blockInitialAnimation = !!u,
            this.isControllingVariants = cc(n),
            this.isVariantNode = p1(n),
        this.isVariantNode && (this.variantChildren = new Set),
            this.manuallyAnimateOnMount = !!(t && t.current);
        const {willChange: m, ...y} = this.scrapeMotionValuesFromProps(n, {}, this);
        for (const v in y) {
            const S = y[v];
            f[v] !== void 0 && Tt(S) && S.set(f[v], !1)
        }
    }
    mount(t) {
        this.current = t,
            qw.set(t, this),
        this.projection && !this.projection.instance && this.projection.mount(t),
        this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)),
            this.values.forEach( (n, s) => this.bindToMotionValue(s, n)),
        ME.current || CF(),
            this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : Qh.current,
        this.parent && this.parent.children.add(this),
            this.update(this.props, this.presenceContext)
    }
    unmount() {
        qw.delete(this.current),
        this.projection && this.projection.unmount(),
            Zr(this.notifyUpdate),
            Zr(this.render),
            this.valueSubscriptions.forEach(t => t()),
            this.valueSubscriptions.clear(),
        this.removeFromVariantTree && this.removeFromVariantTree(),
        this.parent && this.parent.children.delete(this);
        for (const t in this.events)
            this.events[t].clear();
        for (const t in this.features) {
            const n = this.features[t];
            n && (n.unmount(),
                n.isMounted = !1)
        }
        this.current = null
    }
    bindToMotionValue(t, n) {
        this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)();
        const s = $s.has(t)
            , o = n.on("change", d => {
                this.latestValues[t] = d,
                this.props.onUpdate && ze.preRender(this.notifyUpdate),
                s && this.projection && (this.projection.isTransformDirty = !0)
            }
        )
            , u = n.on("renderRequest", this.scheduleRender);
        let l;
        window.MotionCheckAppearSync && (l = window.MotionCheckAppearSync(this, t, n)),
            this.valueSubscriptions.set(t, () => {
                    o(),
                        u(),
                    l && l(),
                    n.owner && n.stop()
                }
            )
    }
    sortNodePosition(t) {
        return !this.current || !this.sortInstanceNodePosition || this.type !== t.type ? 0 : this.sortInstanceNodePosition(this.current, t.current)
    }
    updateFeatures() {
        let t = "animation";
        for (t in Hi) {
            const n = Hi[t];
            if (!n)
                continue;
            const {isEnabled: s, Feature: o} = n;
            if (!this.features[t] && o && s(this.props) && (this.features[t] = new o(this)),
                this.features[t]) {
                const u = this.features[t];
                u.isMounted ? u.update() : (u.mount(),
                    u.isMounted = !0)
            }
        }
    }
    triggerBuild() {
        this.build(this.renderState, this.latestValues, this.props)
    }
    measureViewportBox() {
        return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Je()
    }
    getStaticValue(t) {
        return this.latestValues[t]
    }
    setStaticValue(t, n) {
        this.latestValues[t] = n
    }
    update(t, n) {
        (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(),
            this.prevProps = this.props,
            this.props = t,
            this.prevPresenceContext = this.presenceContext,
            this.presenceContext = n;
        for (let s = 0; s < Kw.length; s++) {
            const o = Kw[s];
            this.propEventSubscriptions[o] && (this.propEventSubscriptions[o](),
                delete this.propEventSubscriptions[o]);
            const u = "on" + o
                , l = t[u];
            l && (this.propEventSubscriptions[o] = this.on(o, l))
        }
        this.prevMotionValues = PF(this, this.scrapeMotionValuesFromProps(t, this.prevProps, this), this.prevMotionValues),
        this.handleChildMotionValue && this.handleChildMotionValue()
    }
    getProps() {
        return this.props
    }
    getVariant(t) {
        return this.props.variants ? this.props.variants[t] : void 0
    }
    getDefaultTransition() {
        return this.props.transition
    }
    getTransformPagePoint() {
        return this.props.transformPagePoint
    }
    getClosestVariantNode() {
        return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
    }
    addVariantChild(t) {
        const n = this.getClosestVariantNode();
        if (n)
            return n.variantChildren && n.variantChildren.add(t),
                () => n.variantChildren.delete(t)
    }
    addValue(t, n) {
        const s = this.values.get(t);
        n !== s && (s && this.removeValue(t),
            this.bindToMotionValue(t, n),
            this.values.set(t, n),
            this.latestValues[t] = n.get())
    }
    removeValue(t) {
        this.values.delete(t);
        const n = this.valueSubscriptions.get(t);
        n && (n(),
            this.valueSubscriptions.delete(t)),
            delete this.latestValues[t],
            this.removeValueFromRenderState(t, this.renderState)
    }
    hasValue(t) {
        return this.values.has(t)
    }
    getValue(t, n) {
        if (this.props.values && this.props.values[t])
            return this.props.values[t];
        let s = this.values.get(t);
        return s === void 0 && n !== void 0 && (s = xa(n === null ? void 0 : n, {
            owner: this
        }),
            this.addValue(t, s)),
            s
    }
    readValue(t, n) {
        var s;
        let o = this.latestValues[t] !== void 0 || !this.current ? this.latestValues[t] : (s = this.getBaseTargetFromProps(this.props, t)) !== null && s !== void 0 ? s : this.readValueFromInstance(this.current, t, this.options);
        return o != null && (typeof o == "string" && (Q1(o) || K1(o)) ? o = parseFloat(o) : !kF(o) && es.test(n) && (o = iE(t, n)),
            this.setBaseTarget(t, Tt(o) ? o.get() : o)),
            Tt(o) ? o.get() : o
    }
    setBaseTarget(t, n) {
        this.baseTarget[t] = n
    }
    getBaseTarget(t) {
        var n;
        const {initial: s} = this.props;
        let o;
        if (typeof s == "string" || typeof s == "object") {
            const l = Bp(this.props, s, (n = this.presenceContext) === null || n === void 0 ? void 0 : n.custom);
            l && (o = l[t])
        }
        if (s && o !== void 0)
            return o;
        const u = this.getBaseTargetFromProps(this.props, t);
        return u !== void 0 && !Tt(u) ? u : this.initialValues[t] !== void 0 && o === void 0 ? void 0 : this.baseTarget[t]
    }
    on(t, n) {
        return this.events[t] || (this.events[t] = new Jp),
            this.events[t].add(n)
    }
    notify(t, ...n) {
        this.events[t] && this.events[t].notify(...n)
    }
}
class jE extends RF {
    constructor() {
        super(...arguments),
            this.KeyframeResolver = oE
    }
    sortInstanceNodePosition(t, n) {
        return t.compareDocumentPosition(n) & 2 ? 1 : -1
    }
    getBaseTargetFromProps(t, n) {
        return t.style ? t.style[n] : void 0
    }
    removeValueFromRenderState(t, {vars: n, style: s}) {
        delete n[t],
            delete s[t]
    }
    handleChildMotionValue() {
        this.childSubscription && (this.childSubscription(),
            delete this.childSubscription);
        const {children: t} = this.props;
        Tt(t) && (this.childSubscription = t.on("change", n => {
                this.current && (this.current.textContent = `${n}`)
            }
        ))
    }
}
function AF(e) {
    return window.getComputedStyle(e)
}
class _F extends jE {
    constructor() {
        super(...arguments),
            this.type = "html",
            this.renderInstance = v1
    }
    readValueFromInstance(t, n) {
        if ($s.has(n)) {
            const s = sm(n);
            return s && s.default || 0
        } else {
            const s = AF(t)
                , o = (k1(n) ? s.getPropertyValue(n) : s[n]) || 0;
            return typeof o == "string" ? o.trim() : o
        }
    }
    measureInstanceViewportBox(t, {transformPagePoint: n}) {
        return EE(t, n)
    }
    build(t, n, s) {
        $p(t, n, s.transformTemplate)
    }
    scrapeMotionValuesFromProps(t, n, s) {
        return Fp(t, n, s)
    }
}
class NF extends jE {
    constructor() {
        super(...arguments),
            this.type = "svg",
            this.isSVGTag = !1,
            this.measureInstanceViewportBox = Je
    }
    getBaseTargetFromProps(t, n) {
        return t[n]
    }
    readValueFromInstance(t, n) {
        if ($s.has(n)) {
            const s = sm(n);
            return s && s.default || 0
        }
        return n = w1.has(n) ? n : jp(n),
            t.getAttribute(n)
    }
    scrapeMotionValuesFromProps(t, n, s) {
        return b1(t, n, s)
    }
    build(t, n, s) {
        Wp(t, n, this.isSVGTag, s.transformTemplate)
    }
    renderInstance(t, n, s, o) {
        x1(t, n, s, o)
    }
    mount(t) {
        this.isSVGTag = Hp(t.tagName),
            super.mount(t)
    }
}
const OF = (e, t) => Ip(e) ? new NF(t) : new _F(t,{
    allowProjection: e !== P.Fragment
})
    , LF = nj({
    ...tI,
    ...bF,
    ...dF,
    ...EF
}, OF)
    , bn = v2(LF);
function MF({product: e, allProducts: t=[]}) {
    const [n,s] = P.useState(localStorage.getItem("language") || "en");
    P.useEffect( () => {
            const y = () => {
                    s(localStorage.getItem("language") || "en")
                }
            ;
            return window.addEventListener("languageChange", y),
                () => window.removeEventListener("languageChange", y)
        }
        , []);
    const o = ac[n]
        , u = Math.round((e.price - e.sale_price) / e.price * 100)
        , l = y => y < 1 ? `${y * 1e3}g` : `${y} KG`
        , d = t.filter(y => y.title === e.title)
        , f = d.length > 1 ? `${l(Math.min(...d.map(y => y.weight)))} - ${l(Math.max(...d.map(y => y.weight)))}` : l(e.weight)
        , p = d.length > 1 ? `${Math.min(...d.map(y => y.sale_price)).toLocaleString("en-IN")} - ${Math.max(...d.map(y => y.sale_price)).toLocaleString("en-IN")}` : `${e.sale_price.toLocaleString("en-IN")}`
        , m = encodeURIComponent(`Hi, I'm interested in ${e.title}. Please share more details.`);
    return b.jsx(bn.div, {
        initial: {
            opacity: 0,
            y: 20
        },
        animate: {
            opacity: 1,
            y: 0
        },
        transition: {
            duration: .4
        },
        children: b.jsxs(Ir, {
            className: "group overflow-hidden bg-white border-0 shadow-sm hover:shadow-xl transition-all duration-500 rounded-2xl",
            children: [b.jsx(Ti, {
                to: Ai(`ProductDetails?id=${e.product_id}`),
                className: "block",
                children: b.jsxs("div", {
                    className: "relative overflow-hidden bg-gradient-to-br from-blue-50 to-blue-100",
                    children: [b.jsx("div", {
                        className: "aspect-square p-6 flex items-center justify-center",
                        children: b.jsx("img", {
                            src: e.image,
                            alt: e.title,
                            crossOrigin: "anonymous",
                            className: "w-full h-full object-contain group-hover:scale-105 transition-transform duration-500"
                        })
                    }), d.length > 1 && b.jsxs(ia, {
                        className: "absolute top-4 left-4 bg-blue-600 hover:bg-blue-700 text-white font-semibold px-3 py-1 rounded-full",
                        children: [d.length, " Sizes"]
                    }), u > 0 && d.length === 1 && b.jsxs(ia, {
                        className: "absolute top-4 left-4 bg-emerald-500 hover:bg-emerald-600 text-white font-semibold px-3 py-1 rounded-full",
                        children: [u, "% OFF"]
                    })]
                })
            }), b.jsxs("div", {
                className: "p-5 space-y-4",
                children: [b.jsx(Ti, {
                    to: Ai(`ProductDetails?id=${e.product_id}`),
                    className: "block",
                    children: b.jsxs("div", {
                        className: "mb-3",
                        children: [b.jsx(ia, {
                            variant: "outline",
                            className: "border-blue-200 text-blue-700 mb-2",
                            children: e.brand || "Falcofix"
                        }), b.jsx("p", {
                            className: "text-xs font-medium text-slate-400 uppercase tracking-wider mb-1",
                            children: e.product_id
                        }), b.jsx("h3", {
                            className: "text-lg font-semibold text-slate-800 leading-tight hover:text-blue-600 transition-colors",
                            children: e.title
                        })]
                    })
                }), b.jsxs("div", {
                    children: [b.jsxs("div", {
                        className: "flex items-center gap-2 mb-2",
                        children: [b.jsx(Au, {
                            className: "w-4 h-4 text-slate-400"
                        }), b.jsx("span", {
                            className: "text-sm text-slate-500 font-medium",
                            children: d.length > 1 ? `${o.sizes}: ${f}` : `${o.size}: ${f}`
                        })]
                    }), b.jsx("div", {
                        className: "flex items-baseline gap-3",
                        children: b.jsx("span", {
                            className: "text-2xl font-bold text-slate-900",
                            children: p
                        })
                    })]
                }), b.jsxs("div", {
                    className: "flex gap-2 pt-2",
                    children: [b.jsx(In, {
                        asChild: !0,
                        className: "flex-1 bg-blue-600 hover:bg-blue-700 text-white rounded-xl h-11 font-medium shadow-lg shadow-blue-200",
                        children: b.jsx(Ti, {
                            to: Ai(`ProductDetails?id=${e.product_id}`),
                            children: o.viewDetails
                        })
                    }), b.jsx(In, {
                        asChild: !0,
                        className: "bg-green-600 hover:bg-green-700 text-white rounded-xl h-11 px-4",
                        children: b.jsx("a", {
                            href: `https://wa.me/919422163831?text=${m}`,
                            target: "_blank",
                            rel: "noopener noreferrer",
                            children: b.jsx(Ru, {
                                className: "w-4 h-4"
                            })
                        })
                    })]
                })]
            })]
        })
    })
}
function jF({activeFilter: e, setActiveFilter: t, activeBrand: n, setActiveBrand: s}) {
    const o = [{
        id: "all",
        label: "All Brands"
    }, {
        id: "3M",
        label: "3M"
    }, {
        id: "Falcofix",
        label: "Falcofix"
    }, {
        id: "Others",
        label: "Others"
    }]
        , u = n === "Falcofix" ? [{
        id: "all",
        label: "All Products"
    }, {
        id: "wr",
        label: "Falcofix WR"
    }, {
        id: "um",
        label: "Ultra Marine"
    }, {
        id: "ebs",
        label: "Falcofix EBS"
    }, {
        id: "wrgold",
        label: "WR Gold"
    }, {
        id: "others",
        label: "Others"
    }] : [];
    return b.jsxs("div", {
        className: "space-y-4",
        children: [b.jsx("div", {
            className: "flex flex-wrap justify-center gap-2 md:gap-3",
            children: o.map(l => b.jsx(In, {
                onClick: () => {
                    s(l.id),
                        t("all")
                }
                ,
                variant: n === l.id ? "default" : "outline",
                className: `
                            rounded-full px-5 md:px-6 py-2 font-medium transition-all duration-300
                            ${n === l.id ? "bg-blue-600 text-white shadow-lg shadow-blue-300" : "bg-white border-slate-200 text-slate-600 hover:bg-slate-50 hover:border-slate-300"}
                        `,
                children: l.label
            }, l.id))
        }), u.length > 0 && b.jsx("div", {
            className: "flex flex-wrap justify-center gap-2 md:gap-3",
            children: u.map(l => b.jsx(In, {
                onClick: () => t(l.id),
                variant: e === l.id ? "default" : "outline",
                className: `
                                rounded-full px-5 md:px-6 py-2 font-medium transition-all duration-300
                                ${e === l.id ? "bg-slate-900 text-white shadow-lg shadow-slate-300" : "bg-white border-slate-200 text-slate-600 hover:bg-slate-50 hover:border-slate-300"}
                            `,
                children: l.label
            }, l.id))
        })]
    })
}
function DE() {
    return b.jsx("div", {
        className: "fixed inset-0 bg-gradient-to-br from-blue-50 to-white flex items-center justify-center z-50",
        children: b.jsxs("div", {
            className: "text-center",
            children: [b.jsx(bn.div, {
                initial: {
                    scale: .8,
                    opacity: 0
                },
                animate: {
                    scale: 1,
                    opacity: 1
                },
                transition: {
                    duration: .5
                },
                className: "mb-6",
                children: b.jsx("div", {
                    className: "w-20 h-20 mx-auto bg-gradient-to-br from-blue-600 to-blue-700 rounded-2xl flex items-center justify-center shadow-2xl shadow-blue-300",
                    children: b.jsx("span", {
                        className: "text-white font-bold text-3xl",
                        children: "S"
                    })
                })
            }), b.jsxs(bn.div, {
                initial: {
                    opacity: 0,
                    y: 10
                },
                animate: {
                    opacity: 1,
                    y: 0
                },
                transition: {
                    duration: .5,
                    delay: .2
                },
                children: [b.jsx("h2", {
                    className: "text-2xl font-bold text-slate-900 mb-2",
                    children: "Siddhartha Marketing"
                }), b.jsx("p", {
                    className: "text-slate-500 mb-6",
                    children: "Loading products..."
                })]
            }), b.jsx("div", {
                className: "flex justify-center gap-2",
                children: [0, 1, 2].map(e => b.jsx(bn.div, {
                    className: "w-2.5 h-2.5 bg-blue-600 rounded-full",
                    animate: {
                        scale: [1, 1.3, 1],
                        opacity: [.5, 1, .5]
                    },
                    transition: {
                        duration: 1,
                        repeat: 1 / 0,
                        delay: e * .2
                    }
                }, e))
            })]
        })
    })
}
function DF() {
    const [e,t] = P.useState("all")
        , [n,s] = P.useState("all")
        , [o,u] = P.useState(localStorage.getItem("language") || "en");
    P.useEffect( () => {
            const v = () => {
                    u(localStorage.getItem("language") || "en")
                }
            ;
            return window.addEventListener("languageChange", v),
                () => window.removeEventListener("languageChange", v)
        }
        , []);
    const l = ac[o]
        , {data: d=[], isLoading: f} = ip({
        queryKey: ["products"],
        queryFn: () => Kr.entities.Product.list()
    })
        , m = d.filter(v => {
            const S = n === "all" || v.brand === n;
            let E = !0;
            return n === "Falcofix" && e !== "all" && (e === "wr" && (E = v.title === "Falcofix WR"),
            e === "um" && (E = v.title === "Falcofix Ultra Marine"),
            e === "ebs" && (E = v.title === "Falcofix EBS"),
            e === "wrgold" && (E = v.title === "Falcofix WR Gold")),
            S && E
        }
    ).reduce( (v, S) => (v[S.title] || (v[S.title] = []),
        v[S.title].push(S),
        v), {})
        , y = Object.values(m).map(v => v.sort( (S, E) => S.weight - E.weight)[0]);
    return f ? b.jsx(DE, {}) : b.jsxs("div", {
        className: "min-h-screen bg-gradient-to-b from-blue-50 to-white",
        children: [b.jsx(Nh, {}), b.jsxs("main", {
            className: "max-w-7xl mx-auto px-4 py-8 md:py-12",
            children: [b.jsxs(bn.div, {
                initial: {
                    opacity: 0,
                    y: 20
                },
                animate: {
                    opacity: 1,
                    y: 0
                },
                transition: {
                    duration: .6
                },
                className: "text-center mb-10 md:mb-14",
                children: [b.jsx("span", {
                    className: "inline-block bg-blue-100 text-blue-700 px-4 py-1.5 rounded-full text-sm font-semibold mb-4",
                    children: l.premiumQuality
                }), n === "Falcofix" && b.jsxs("div", {
                    className: "flex items-center justify-center gap-6 mb-6",
                    children: [b.jsx("img", {
                        src: "https://qtrypzzcjebvfcihiynt.supabase.co/storage/v1/object/public/base44-prod/public/69355685b7ba1c4a22697f76/8cead059c_pidilite-logo-1.png",
                        alt: "Pidilite",
                        crossOrigin: "anonymous",
                        className: "h-16 md:h-20 object-contain"
                    }), b.jsx("img", {
                        src: "https://qtrypzzcjebvfcihiynt.supabase.co/storage/v1/object/public/base44-prod/public/69355685b7ba1c4a22697f76/c45c91ab2_falcofix-brand.jpg",
                        alt: "Falcofix",
                        crossOrigin: "anonymous",
                        className: "h-16 md:h-20 object-contain"
                    })]
                }), n === "3M" && b.jsx("div", {
                    className: "flex items-center justify-center mb-6",
                    children: b.jsx("img", {
                        src: "https://qtrypzzcjebvfcihiynt.supabase.co/storage/v1/object/public/base44-prod/public/69355685b7ba1c4a22697f76/b35f79d2b_3mlogo.png",
                        alt: "3M",
                        crossOrigin: "anonymous",
                        className: "h-16 md:h-20 object-contain"
                    })
                }), b.jsx("h2", {
                    className: "text-3xl md:text-5xl font-bold text-slate-900 mb-4 tracking-tight",
                    children: n === "all" ? l.ourInventory : n === "Falcofix" && e === "all" ? l.falcofixRange : n === "Falcofix" && e === "wr" ? l.falcofixWR : n === "Falcofix" && e === "um" ? l.falcofixUM : n === "Falcofix" && e === "ebs" ? l.falcofixEBS : n === "Falcofix" && e === "wrgold" ? l.falcofixWRGold : n === "3M" ? l.threeMProducts : l.otherProducts
                }), b.jsx("p", {
                    className: "text-slate-500 text-lg max-w-2xl mx-auto leading-relaxed",
                    children: n === "all" ? l.browseInventory : n === "Falcofix" && e === "all" ? l.industrialGrade : l.selectSize
                })]
            }), b.jsx("div", {
                className: "mb-8 md:mb-10",
                children: b.jsx(jF, {
                    activeFilter: e,
                    setActiveFilter: t,
                    activeBrand: n,
                    setActiveBrand: s
                })
            }), y.length === 0 ? b.jsxs("div", {
                className: "flex flex-col items-center justify-center py-20",
                children: [b.jsx(Au, {
                    className: "w-16 h-16 text-slate-300 mb-4"
                }), b.jsx("p", {
                    className: "text-slate-500 text-lg",
                    children: n === "Falcofix" && e === "others" ? l.noProducts : n === "3M" || n === "Others" ? l.comingSoon : l.noProducts
                }), b.jsx(Ti, {
                    to: Ai("Home"),
                    children: b.jsx(In, {
                        className: "mt-4 bg-blue-600 hover:bg-blue-700",
                        onClick: () => {
                            s("all"),
                                t("all")
                        }
                        ,
                        children: l.viewAllProducts
                    })
                })]
            }) : b.jsx(bn.div, {
                layout: !0,
                className: "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-5 md:gap-6",
                children: y.map( (v, S) => b.jsx(bn.div, {
                    initial: {
                        opacity: 0,
                        y: 20
                    },
                    animate: {
                        opacity: 1,
                        y: 0
                    },
                    transition: {
                        duration: .4,
                        delay: S * .05
                    },
                    children: b.jsx(MF, {
                        product: v,
                        allProducts: d
                    })
                }, v.product_id))
            }), n === "all" && b.jsx(bn.div, {
                initial: {
                    opacity: 0
                },
                animate: {
                    opacity: 1
                },
                transition: {
                    duration: .6,
                    delay: .3
                },
                className: "mt-16 md:mt-20 grid grid-cols-2 md:grid-cols-4 gap-4 md:gap-6",
                children: [{
                    value: "25+",
                    label: l.yearsExperience
                }, {
                    value: "500+",
                    label: l.happyClients
                }, {
                    value: `${d.length}`,
                    label: l.productVariants
                }, {
                    value: "100%",
                    label: l.qualityAssured
                }].map( (v, S) => b.jsxs("div", {
                    className: "bg-white rounded-2xl p-6 text-center shadow-sm border border-slate-100",
                    children: [b.jsx("div", {
                        className: "text-2xl md:text-3xl font-bold text-slate-900 mb-1",
                        children: v.value
                    }), b.jsx("div", {
                        className: "text-sm text-slate-500 font-medium",
                        children: v.label
                    })]
                }, S))
            })]
        }), b.jsx(Oh, {})]
    })
}
function IF() {
    const t = new URLSearchParams(window.location.search).get("id")
        , {data: n=[], isLoading: s} = ip({
        queryKey: ["products"],
        queryFn: () => Kr.entities.Product.list()
    })
        , o = n.find(v => v.product_id === t)
        , u = n.filter(v => o && v.title === o.title).sort( (v, S) => v.weight - S.weight)
        , [l,d] = P.useState(t);
    if (s)
        return b.jsx(DE, {});
    if (!o)
        return b.jsxs("div", {
            className: "min-h-screen bg-gradient-to-b from-blue-50 to-white",
            children: [b.jsx(Nh, {}), b.jsxs("div", {
                className: "max-w-7xl mx-auto px-4 py-20 text-center",
                children: [b.jsx("h2", {
                    className: "text-2xl font-bold text-slate-900 mb-4",
                    children: "Product not found"
                }), b.jsx(Ti, {
                    to: Ai("Home"),
                    children: b.jsxs(In, {
                        className: "bg-blue-600 hover:bg-blue-700",
                        children: [b.jsx(dv, {
                            className: "w-4 h-4 mr-2"
                        }), "Back to Products"]
                    })
                })]
            }), b.jsx(Oh, {})]
        });
    const f = u.find(v => v.product_id === l) || o
        , p = Math.round((f.price - f.sale_price) / f.price * 100)
        , m = v => v < 1 ? `${v * 1e3}g` : `${v} KG`
        , y = encodeURIComponent(`Hi, I'm interested in ${f.title} (${m(f.weight)}) - SKU: ${f.product_id}. Price: ${f.sale_price}. Please share more details.`);
    return b.jsxs("div", {
        className: "min-h-screen bg-gradient-to-b from-blue-50 to-white",
        children: [b.jsx(Nh, {}), b.jsxs("main", {
            className: "max-w-7xl mx-auto px-4 py-8 md:py-12",
            children: [b.jsx(Ti, {
                to: Ai("Home"),
                children: b.jsxs(In, {
                    variant: "ghost",
                    className: "mb-6 hover:bg-blue-50",
                    children: [b.jsx(dv, {
                        className: "w-4 h-4 mr-2"
                    }), "Back to Products"]
                })
            }), b.jsxs("div", {
                className: "grid md:grid-cols-2 gap-8 md:gap-12",
                children: [b.jsx(bn.div, {
                    initial: {
                        opacity: 0,
                        x: -20
                    },
                    animate: {
                        opacity: 1,
                        x: 0
                    },
                    transition: {
                        duration: .5
                    },
                    children: b.jsx(Ir, {
                        className: "overflow-hidden bg-white border-0 shadow-xl rounded-2xl sticky top-24",
                        children: b.jsxs("div", {
                            className: "relative bg-gradient-to-br from-blue-50 to-blue-100 p-8 md:p-12",
                            children: [b.jsx("img", {
                                src: f.image,
                                alt: f.title,
                                crossOrigin: "anonymous",
                                className: "w-full h-auto object-contain"
                            }), p > 0 && b.jsxs(ia, {
                                className: "absolute top-6 left-6 bg-emerald-500 text-white font-bold px-4 py-2 rounded-full text-base",
                                children: [p, "% OFF"]
                            })]
                        })
                    })
                }), b.jsxs(bn.div, {
                    initial: {
                        opacity: 0,
                        x: 20
                    },
                    animate: {
                        opacity: 1,
                        x: 0
                    },
                    transition: {
                        duration: .5
                    },
                    className: "space-y-6",
                    children: [b.jsxs("div", {
                        children: [b.jsx(ia, {
                            variant: "outline",
                            className: "border-blue-200 text-blue-700 mb-3 px-3 py-1",
                            children: f.brand || "Falcofix"
                        }), b.jsxs("p", {
                            className: "text-sm font-medium text-slate-400 uppercase tracking-wider mb-2",
                            children: ["SKU: ", f.product_id]
                        }), b.jsx("h1", {
                            className: "text-3xl md:text-4xl font-bold text-slate-900 mb-4",
                            children: f.title
                        }), b.jsxs("div", {
                            className: "flex items-baseline gap-4 mb-6",
                            children: [b.jsxs("span", {
                                className: "text-4xl font-bold text-slate-900",
                                children: ["", f.sale_price.toLocaleString("en-IN")]
                            }), f.price !== f.sale_price && b.jsxs("span", {
                                className: "text-xl text-slate-400 line-through",
                                children: ["", f.price.toLocaleString("en-IN")]
                            })]
                        })]
                    }), u.length > 1 && b.jsxs(Ir, {
                        className: "p-6 bg-blue-50 border-blue-100",
                        children: [b.jsxs("label", {
                            className: "block text-sm font-semibold text-slate-700 mb-3 flex items-center gap-2",
                            children: [b.jsx(Au, {
                                className: "w-4 h-4"
                            }), "Select Size"]
                        }), b.jsxs(s1, {
                            value: l,
                            onValueChange: d,
                            children: [b.jsx(Rp, {
                                className: "w-full bg-white border-blue-200 h-12 text-base",
                                children: b.jsx(i1, {})
                            }), b.jsx(Ap, {
                                children: u.map(v => b.jsx(sa, {
                                    value: v.product_id,
                                    className: "text-base py-3",
                                    children: b.jsxs("div", {
                                        className: "flex justify-between items-center w-full gap-8",
                                        children: [b.jsx("span", {
                                            className: "font-medium",
                                            children: m(v.weight)
                                        }), b.jsxs("span", {
                                            className: "text-slate-600",
                                            children: ["", v.sale_price.toLocaleString("en-IN")]
                                        })]
                                    })
                                }, v.product_id))
                            })]
                        })]
                    }), b.jsxs(Ir, {
                        className: "p-6",
                        children: [b.jsxs("h3", {
                            className: "font-semibold text-lg mb-4 flex items-center gap-2",
                            children: [b.jsx(fT, {
                                className: "w-5 h-5 text-blue-600"
                            }), "Product Details"]
                        }), b.jsxs("div", {
                            className: "space-y-3",
                            children: [b.jsxs("div", {
                                className: "flex justify-between py-2 border-b border-slate-100",
                                children: [b.jsx("span", {
                                    className: "text-slate-600",
                                    children: "Weight"
                                }), b.jsx("span", {
                                    className: "font-semibold",
                                    children: m(f.weight)
                                })]
                            }), b.jsxs("div", {
                                className: "flex justify-between py-2 border-b border-slate-100",
                                children: [b.jsx("span", {
                                    className: "text-slate-600",
                                    children: "Product Type"
                                }), b.jsx("span", {
                                    className: "font-semibold capitalize",
                                    children: f.product_type
                                })]
                            }), b.jsxs("div", {
                                className: "flex justify-between py-2",
                                children: [b.jsx("span", {
                                    className: "text-slate-600",
                                    children: "Brand"
                                }), b.jsx("span", {
                                    className: "font-semibold",
                                    children: f.brand || "Falcofix"
                                })]
                            })]
                        })]
                    }), b.jsxs(Ir, {
                        className: "p-6 bg-gradient-to-br from-blue-50 to-white",
                        children: [b.jsx("h3", {
                            className: "font-semibold text-lg mb-4",
                            children: "Key Features"
                        }), b.jsx("div", {
                            className: "space-y-3",
                            children: ["High-quality industrial adhesive", "Strong bonding performance", "Suitable for various applications", "Trusted by professionals"].map( (v, S) => b.jsxs("div", {
                                className: "flex items-start gap-3",
                                children: [b.jsx(lT, {
                                    className: "w-5 h-5 text-green-600 mt-0.5 flex-shrink-0"
                                }), b.jsx("span", {
                                    className: "text-slate-700",
                                    children: v
                                })]
                            }, S))
                        })]
                    }), b.jsxs("div", {
                        className: "flex gap-3 pt-4",
                        children: [b.jsx(In, {
                            asChild: !0,
                            className: "flex-1 bg-green-600 hover:bg-green-700 text-white h-14 text-base rounded-xl font-semibold shadow-lg shadow-green-200",
                            children: b.jsxs("a", {
                                href: `https://wa.me/919422163831?text=${y}`,
                                target: "_blank",
                                rel: "noopener noreferrer",
                                children: [b.jsx(Ru, {
                                    className: "w-5 h-5 mr-2"
                                }), "WhatsApp Inquiry"]
                            })
                        }), b.jsx(In, {
                            asChild: !0,
                            variant: "outline",
                            className: "flex-1 border-2 border-blue-600 text-blue-600 hover:bg-blue-50 h-14 text-base rounded-xl font-semibold",
                            children: b.jsxs("a", {
                                href: "tel:+919422163831",
                                children: [b.jsx(ca, {
                                    className: "w-5 h-5 mr-2"
                                }), "Call Now"]
                            })
                        })]
                    }), b.jsxs(Ir, {
                        className: "p-6 bg-slate-50",
                        children: [b.jsx("h3", {
                            className: "font-semibold mb-3",
                            children: "Need Help?"
                        }), b.jsx("p", {
                            className: "text-slate-600 text-sm mb-3",
                            children: "Contact us for pricing, bulk orders, or any questions about this product."
                        }), b.jsxs("div", {
                            className: "space-y-2 text-sm",
                            children: [b.jsxs("p", {
                                className: "flex items-center gap-2 text-slate-700",
                                children: [b.jsx(ca, {
                                    className: "w-4 h-4 text-blue-600"
                                }), b.jsx("a", {
                                    href: "tel:+919422163831",
                                    className: "hover:text-blue-600",
                                    children: "+91 94221 63831"
                                })]
                            }), b.jsxs("p", {
                                className: "flex items-center gap-2 text-slate-700",
                                children: [b.jsx(Ru, {
                                    className: "w-4 h-4 text-green-600"
                                }), "Available on WhatsApp"]
                            })]
                        })]
                    })]
                })]
            }), u.length > 1 && b.jsxs(bn.div, {
                initial: {
                    opacity: 0,
                    y: 20
                },
                animate: {
                    opacity: 1,
                    y: 0
                },
                transition: {
                    duration: .5,
                    delay: .3
                },
                className: "mt-16",
                children: [b.jsx("h2", {
                    className: "text-2xl md:text-3xl font-bold text-slate-900 mb-6",
                    children: "Available Sizes"
                }), b.jsx("div", {
                    className: "grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4",
                    children: u.map(v => b.jsx(Ir, {
                        onClick: () => d(v.product_id),
                        className: `p-4 cursor-pointer transition-all duration-300 hover:shadow-lg ${v.product_id === l ? "ring-2 ring-blue-600 bg-blue-50" : "hover:bg-slate-50"}`,
                        children: b.jsxs("div", {
                            className: "text-center",
                            children: [b.jsx(Au, {
                                className: `w-8 h-8 mx-auto mb-2 ${v.product_id === l ? "text-blue-600" : "text-slate-400"}`
                            }), b.jsx("p", {
                                className: "font-bold text-slate-900 mb-1",
                                children: m(v.weight)
                            }), b.jsxs("p", {
                                className: "text-sm text-slate-600",
                                children: ["", v.sale_price.toLocaleString("en-IN")]
                            })]
                        })
                    }, v.product_id))
                })]
            })]
        }), b.jsx(Oh, {})]
    })
}
const FF = {
    Home: DF,
    ProductDetails: IF
}
    , IE = {
    mainPage: "Home",
    Pages: FF
};
function BF() {
    const e = Xi()
        , {isAuthenticated: t} = IS()
        , {Pages: n, mainPage: s} = IE
        , o = s;
    return P.useEffect( () => {
            var u;
            (u = window.parent) == null || u.postMessage({
                type: "app_changed_url",
                url: window.location.href
            }, "*")
        }
        , [e]),
        P.useEffect( () => {
                const u = e.pathname;
                let l;
                if (u === "/" || u === "")
                    l = o;
                else {
                    const d = u.replace(/^\//, "").split("/")[0];
                    l = Object.keys(n).find(m => m.toLowerCase() === d.toLowerCase()) || null
                }
                t && l && Kr.appLogs.logUserInApp(l).catch( () => {}
                )
            }
            , [e, t, n, o]),
        null
}
function VF({}) {
    var o;
    const t = Xi().pathname.substring(1)
        , {data: n, isFetched: s} = ip({
        queryKey: ["user"],
        queryFn: async () => {
            try {
                return {
                    user: await Kr.auth.me(),
                    isAuthenticated: !0
                }
            } catch {
                return {
                    user: null,
                    isAuthenticated: !1
                }
            }
        }
    });
    return b.jsx("div", {
        className: "min-h-screen flex items-center justify-center p-6 bg-slate-50",
        children: b.jsx("div", {
            className: "max-w-md w-full",
            children: b.jsxs("div", {
                className: "text-center space-y-6",
                children: [b.jsxs("div", {
                    className: "space-y-2",
                    children: [b.jsx("h1", {
                        className: "text-7xl font-light text-slate-300",
                        children: "404"
                    }), b.jsx("div", {
                        className: "h-0.5 w-16 bg-slate-200 mx-auto"
                    })]
                }), b.jsxs("div", {
                    className: "space-y-3",
                    children: [b.jsx("h2", {
                        className: "text-2xl font-medium text-slate-800",
                        children: "Page Not Found"
                    }), b.jsxs("p", {
                        className: "text-slate-600 leading-relaxed",
                        children: ["The page ", b.jsxs("span", {
                            className: "font-medium text-slate-700",
                            children: ['"', t, '"']
                        }), " could not be found in this application."]
                    })]
                }), s && n.isAuthenticated && ((o = n.user) == null ? void 0 : o.role) === "admin" && b.jsx("div", {
                    className: "mt-8 p-4 bg-slate-100 rounded-lg border border-slate-200",
                    children: b.jsxs("div", {
                        className: "flex items-start space-x-3",
                        children: [b.jsx("div", {
                            className: "flex-shrink-0 w-5 h-5 rounded-full bg-orange-100 flex items-center justify-center mt-0.5",
                            children: b.jsx("div", {
                                className: "w-2 h-2 rounded-full bg-orange-400"
                            })
                        }), b.jsxs("div", {
                            className: "text-left space-y-1",
                            children: [b.jsx("p", {
                                className: "text-sm font-medium text-slate-700",
                                children: "Admin Note"
                            }), b.jsx("p", {
                                className: "text-sm text-slate-600 leading-relaxed",
                                children: "This could mean that the AI hasn't implemented this page yet. Ask it to implement it in the chat."
                            })]
                        })]
                    })
                }), b.jsx("div", {
                    className: "pt-6",
                    children: b.jsxs("button", {
                        onClick: () => window.location.href = "/",
                        className: "inline-flex items-center px-4 py-2 text-sm font-medium text-slate-700 bg-white border border-slate-200 rounded-lg hover:bg-slate-50 hover:border-slate-300 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-slate-500",
                        children: [b.jsx("svg", {
                            className: "w-4 h-4 mr-2",
                            fill: "none",
                            stroke: "currentColor",
                            viewBox: "0 0 24 24",
                            children: b.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                strokeWidth: 2,
                                d: "M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"
                            })
                        }), "Go Home"]
                    })
                })]
            })
        })
    })
}
const UF = () => b.jsx("div", {
        className: "flex flex-col items-center justify-center min-h-screen bg-gradient-to-b from-white to-slate-50",
        children: b.jsx("div", {
            className: "max-w-md w-full p-8 bg-white rounded-lg shadow-lg border border-slate-100",
            children: b.jsxs("div", {
                className: "text-center",
                children: [b.jsx("div", {
                    className: "inline-flex items-center justify-center w-16 h-16 mb-6 rounded-full bg-orange-100",
                    children: b.jsx("svg", {
                        className: "w-8 h-8 text-orange-600",
                        fill: "none",
                        stroke: "currentColor",
                        viewBox: "0 0 24 24",
                        children: b.jsx("path", {
                            strokeLinecap: "round",
                            strokeLinejoin: "round",
                            strokeWidth: "2",
                            d: "M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
                        })
                    })
                }), b.jsx("h1", {
                    className: "text-3xl font-bold text-slate-900 mb-4",
                    children: "Access Restricted"
                }), b.jsx("p", {
                    className: "text-slate-600 mb-8",
                    children: "You are not registered to use this application. Please contact the app administrator to request access."
                }), b.jsxs("div", {
                    className: "p-4 bg-slate-50 rounded-md text-sm text-slate-600",
                    children: [b.jsx("p", {
                        children: "If you believe this is an error, you can:"
                    }), b.jsxs("ul", {
                        className: "list-disc list-inside mt-2 space-y-1",
                        children: [b.jsx("li", {
                            children: "Verify you are logged in with the correct account"
                        }), b.jsx("li", {
                            children: "Contact the app administrator for access"
                        }), b.jsx("li", {
                            children: "Try logging out and back in again"
                        })]
                    })]
                })]
            })
        })
    })
    , {Pages: FE, Layout: Qw, mainPage: zF} = IE
    , BE = zF
    , $F = FE[BE]
    , Gw = ({children: e, currentPageName: t}) => Qw ? b.jsx(Qw, {
        currentPageName: t,
        children: e
    }) : b.jsx(b.Fragment, {
        children: e
    })
    , WF = () => {
        const {isLoadingAuth: e, isLoadingPublicSettings: t, authError: n, isAuthenticated: s, navigateToLogin: o} = IS();
        if (t || e)
            return b.jsx("div", {
                className: "fixed inset-0 flex items-center justify-center",
                children: b.jsx("div", {
                    className: "w-8 h-8 border-4 border-slate-200 border-t-slate-800 rounded-full animate-spin"
                })
            });
        if (n) {
            if (n.type === "user_not_registered")
                return b.jsx(UF, {});
            if (n.type === "auth_required")
                return o(),
                    null
        }
        return b.jsxs(LR, {
            children: [b.jsx(pu, {
                path: "/",
                element: b.jsx(Gw, {
                    currentPageName: BE,
                    children: b.jsx($F, {})
                })
            }), Object.entries(FE).map( ([u,l]) => b.jsx(pu, {
                path: `/${u}`,
                element: b.jsx(Gw, {
                    currentPageName: u,
                    children: b.jsx(l, {})
                })
            }, u)), b.jsx(pu, {
                path: "*",
                element: b.jsx(VF, {})
            })]
        })
    }
;
function HF() {
    return b.jsx(LN, {
        children: b.jsxs(kk, {
            client: Bk,
            children: [b.jsxs(VR, {
                children: [b.jsx(BF, {}), b.jsx(WF, {})]
            }), b.jsx(tk, {}), b.jsx(Vk, {})]
        })
    })
}
HP.createRoot(document.getElementById("root")).render(b.jsx(HF, {}));
